<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Notes on CastOff</title>
    <link>http://www.sdlinks.net/categories/notes/</link>
    <description>Recent content in Notes on CastOff</description>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <lastBuildDate>Tue, 25 Feb 2020 11:50:04 +0800</lastBuildDate>
    <atom:link href="http://www.sdlinks.net/categories/notes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Some Bitwise Tricks</title>
      <link>http://www.sdlinks.net/posts/2020/some-bitwise-tricks/</link>
      <pubDate>Tue, 25 Feb 2020 11:50:04 +0800</pubDate>
      <guid>http://www.sdlinks.net/posts/2020/some-bitwise-tricks/</guid>
      <description>&lt;h2 id=&#34;bitwise-tricks&#34;&gt;Bitwise tricks&lt;/h2&gt;
&lt;p&gt;近来翻到一本&amp;quot;Hackers Delight&amp;quot;的书, 其主要介绍基于二进制运算的算法. 初读来大感震撼, 其结果之巧妙,过程之精简, 于仅仅是了解计算机数是用补码所表示, 并未深入了解过二进制运算的人而言不可谓不精美. 正如Dijkstra所言, 计算机程序是集逻辑美感与机械实现的矛盾体. 本文姑且将其中的一些皮毛摘录如下, 以便日后之使用, 目前倒是难以得到应用.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使最右位的1变成0&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 01011000 -&amp;gt; 01010000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// if no one then return 0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上式也可以用来判断一个无符号的整数是否是$ 2^n $的形式.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使最右位的0变成1&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 10100111 -&amp;gt; 10101111&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// if no zero then return -1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使尾部的1变成0&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 10100111 -&amp;gt; 10100000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// if no trailing 1s then identity&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上式也可以用来判断一个无符号的整数是否是$ 2^n - 1 $的形式.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Object Lifetime and Storage Management</title>
      <link>http://www.sdlinks.net/posts/2018/object-lifetime-and-storage-management/</link>
      <pubDate>Sat, 08 Dec 2018 16:48:49 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/object-lifetime-and-storage-management/</guid>
      <description>&lt;p&gt;在考虑标识符和绑定(&lt;em&gt;bindings&lt;/em&gt;)的时候, 关键在于区分标识符和它们所引用的对象, 以及以下事件:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象的创建&lt;/li&gt;
&lt;li&gt;绑定的创建&lt;/li&gt;
&lt;li&gt;所有使用绑定的情况, 诸如引用变量, 子程序, 类型等&lt;/li&gt;
&lt;li&gt;停用和重用那些暂时没有用的绑定&lt;/li&gt;
&lt;li&gt;绑定的析构(&lt;em&gt;destruction&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;对象的析构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;绑定的生命周期指的是这个绑定从创建到析构的整个过程, 类似的可以定义对象的生命周期. 通常情况下, 一个对象的生命周期可能会大于对应的绑定的生命周期, 即当
标识符不再引用该对象时, 该对象依然存在(例如在子程序中传入某个对象的引用, 如C++中的&lt;code&gt;&amp;amp;&lt;/code&gt;参数). 当然, 一个绑定的生命周期也有可能大于对应对象的生命周期,
虽然这通常被认为是一个BUG.&lt;/p&gt;
&lt;p&gt;对象的生命周期通常与以下内存分配(&lt;em&gt;storage allocation&lt;/em&gt;)机制有关:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态(&lt;em&gt;static&lt;/em&gt;)对象会在程序的整个运行过程中被分配一个绝对地址.&lt;/li&gt;
&lt;li&gt;栈(&lt;em&gt;stack&lt;/em&gt;)对象随着子程序的调用和返回而被创建以及按照LIFO的顺序析构.&lt;/li&gt;
&lt;li&gt;堆(&lt;em&gt;heap&lt;/em&gt;)对象可以在任何时候创建和析构, 其额外要求更加通用和昂贵的内存分配算法.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;静态分配_static-allocation_&#34;&gt;静态分配(&lt;em&gt;static allocation&lt;/em&gt;)&lt;/h2&gt;
&lt;p&gt;静态分配最明显的例子就是全局对象, 当然全局对象不是唯一的例子. 构成程序机器语言翻译的指令也可以认为是静态分配的变量; 数字和字符串的常量当然也是静态分配
的; 另外很多编译器会产生一系列的表用于支持运行时的debug, 动态类型检查, 垃圾回收, 异常处理等, 这些表也都是静态分配的. 静态分配的对象通常希望它们的值
不在变化, 因此经常被分配在被保护的只读的内存中以方便在试图修改其值产生中断并抛出运行时错误.&lt;/p&gt;
&lt;p&gt;在很多语言中,一个具名常量通常要求有一个能够在编译期确定的初始值. 通常这些初始值都被限制在那些已知的常量以及内置的函数. 这些具名常量加上字面常量通常被
叫做表现常量(&lt;em&gt;manifest constants&lt;/em&gt;)或者编译期常量(&lt;em&gt;compile-time constants&lt;/em&gt;). 在某些语言中(C, Ada), 常量仅仅只是那些无法在elaboration
time之后改变的值, 这些值可能依赖与其他在运行时才能确定的值. 这些elaboration-time的常量在作为递归函数的局部变量时必须要分配在栈上. C#显示提供了
声明两种常量的方法, 即&lt;code&gt;const&lt;/code&gt;和&lt;code&gt;readonly&lt;/code&gt;关键字.&lt;/p&gt;
&lt;p&gt;另外编译器通常对于子程序的某些值采用特定的分配策略:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参数和返回值, 编译器通常会尽可能的将这些值存在寄存器中.&lt;/li&gt;
&lt;li&gt;临时变量, 通常是那些复杂计算过程的中间值, 一个优秀的编译器也会将它们保存在寄存器内.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;bookkeeping information&lt;/em&gt;, 这些通常包含子程序的返回地址.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基于栈的分配_stack-based-allocation_&#34;&gt;基于栈的分配(&lt;em&gt;stack-based allocation&lt;/em&gt;)&lt;/h2&gt;
&lt;p&gt;一门语言如果想要支持递归, 那么在局部变量上采用静态分配的策略将不再适用(Fortran90之前不支持递归), 因为需要变量的个数是未知的. 所幸的是递归天然地适用
于栈结构的分配策略. 每一个子程序在运行时都有一个栈帧(&lt;em&gt;frame&lt;/em&gt;, 或者称为活动记录, &lt;em&gt;activation record&lt;/em&gt;), 包含了传入参数, 局部变量, 临时变量, 以及
bookkeeping信息. 通常传入参数位于帧的顶部, 方便被调用者定位参数, 而其他的布局则依赖于实现. 栈的维护是子程序调用序列的责任, 即调用者在调用前(序言,
&lt;em&gt;prologue&lt;/em&gt;)和调用后(尾声, &lt;em&gt;epilogue&lt;/em&gt;)执行的代码. 通常有一个帧指针(&lt;em&gt;frame pointer&lt;/em&gt;)来保存当前帧的地址, 在大多数语言的实现中, 栈都是往地址减
小的方向增长的. 在这样的实现方式下, 局部变量, 临时变量, bookkeeping信息对于帧指针有一个负的偏移, 而传入参数和返回对于帧指针则有一个正的偏移, 因为
这些都保存在调用者的帧上.&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程</title>
      <link>http://www.sdlinks.net/posts/2018/process/</link>
      <pubDate>Fri, 03 Aug 2018 13:10:58 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/process/</guid>
      <description>&lt;p&gt;The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be
included in any interface of an operating system:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;create&lt;/li&gt;
&lt;li&gt;destroy&lt;/li&gt;
&lt;li&gt;wait&lt;/li&gt;
&lt;li&gt;miscellaneous control, most OS provide some kind of method to suspend a process and resume it.&lt;/li&gt;
&lt;li&gt;status, there are usually interfaces to get some status information about a process.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address
space of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to
do before running the process. Some memory must be allocated for the program&amp;rsquo;s &lt;em&gt;run-time stack&lt;/em&gt;, and the OS may also
allocate smoe memory for the program&amp;rsquo;s heap. Also, the os will do some other intialization tasks, particularly as related
to I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Functional Data Structure 2</title>
      <link>http://www.sdlinks.net/posts/2018/functional-data-structure-2/</link>
      <pubDate>Tue, 24 Jul 2018 15:54:24 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/functional-data-structure-2/</guid>
      <description>&lt;h2 id=&#34;amortization&#34;&gt;Amortization&lt;/h2&gt;
&lt;p&gt;Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case
bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about
the running time of any individual operation.&lt;/p&gt;
&lt;p&gt;For instance, given a sequence of n operations, we may wish to bound the
total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might
be satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n).
This freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and
faster than worst-case solutions with equivalent bounds.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Functional Data Structure 1</title>
      <link>http://www.sdlinks.net/posts/2018/functional-data-structure-1/</link>
      <pubDate>Thu, 19 Jul 2018 17:00:11 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/functional-data-structure-1/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;To implement data structure in a functional way, there are two basic problems. First, from the point of view of designing
and implementing efficient data structures, functional programming&amp;rsquo;s stricture against destructive updates(i.e. assignments)
is a staggering handicap, tantamount to confiscating a master chef&amp;rsquo;s knives.&lt;/p&gt;
&lt;p&gt;Imperative data structures often rely on
assignments in crucial ways, and so different solutions must be found for functional programs. The second difficulty is
that functional data strcutures are expected to be more flexible than their imperative counterparts. In particular, when
we update an imperative data structure we typically accept that the old version of the data strcuture will no longer
be available, but when we update a functional data structure, we expect that both the old and the new version of the data
structure will be available for further processing, this is called &lt;em&gt;persistent&lt;/em&gt;, while the other is called &lt;em&gt;ephemeral&lt;/em&gt;.
And we are not surprised if the persistent version is more complicated and even less efficient that the ephemeral one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Address Space</title>
      <link>http://www.sdlinks.net/posts/2018/address-space/</link>
      <pubDate>Sun, 24 Jun 2018 23:54:04 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/address-space/</guid>
      <description>&lt;h2 id=&#34;the-address-space&#34;&gt;The Address Space&lt;/h2&gt;
&lt;p&gt;The address space is the abstraction that OS is providing to the running program. The address space of a process contains
all of the memory state of the running program. For example, the code of the program, the stack and the heap. In the sight
of the program, it loaded into at a particular address and has a potentially very large address space, thus, we say that
the OS is &lt;em&gt;virtualizing memory&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Computer System 4</title>
      <link>http://www.sdlinks.net/posts/2018/computer-system-4/</link>
      <pubDate>Sun, 10 Jun 2018 19:14:22 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/computer-system-4/</guid>
      <description>&lt;h2 id=&#34;linking&#34;&gt;Linking&lt;/h2&gt;
&lt;p&gt;Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded
(copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into
machine code; at load time, when the program is loaded into memory and executed by the &lt;em&gt;loader&lt;/em&gt;; and even at run time, by
application programs. On modern systems, linking is performed automatically by programs called &lt;em&gt;linkers&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Computer System 3</title>
      <link>http://www.sdlinks.net/posts/2018/computer-system-3/</link>
      <pubDate>Fri, 01 Jun 2018 23:23:16 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/computer-system-3/</guid>
      <description>&lt;h2 id=&#34;optimization&#34;&gt;Optimization&lt;/h2&gt;
&lt;p&gt;Writing an efficient program requires several type of activities. First, we must select an appropriate set of algorithms
and data structures. Second, we must write source code that the compiler can effectively optimize to turn into efficient
executable code. A third technique for dealing with especially demanding computations is to divide a task into portions
that can be computed in parallel, on some combination of multiple cores and multiple processors.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Computer System 2</title>
      <link>http://www.sdlinks.net/posts/2018/computer-system-2/</link>
      <pubDate>Mon, 28 May 2018 17:20:36 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/computer-system-2/</guid>
      <description>&lt;h2 id=&#34;assembler&#34;&gt;Assembler&lt;/h2&gt;
&lt;p&gt;Computer execute machine code, sequences of bytes encoding the low-level operations that manipulate data manage memory,
read and write data on storage devices, and communicate over networks.&lt;/p&gt;
&lt;p&gt;We will focus on x86-64, the commonest machine language used in processor with laptop and PC, also it&amp;rsquo;s widely used in
supercomputer and lager data center.&lt;/p&gt;
&lt;p&gt;the x86-64 machine code is much different with the corresponding C code, the processor states below are everywhere:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Computer System 1</title>
      <link>http://www.sdlinks.net/posts/2018/computer-system-1/</link>
      <pubDate>Wed, 23 May 2018 23:54:04 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/computer-system-1/</guid>
      <description>&lt;h2 id=&#34;hardware-organization-of-a-system&#34;&gt;Hardware Organization of A System&lt;/h2&gt;
&lt;p&gt;A typical system has those hadrware below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Buses: Running throughout the system is a collection of electrical conduits called buses that carry bytes of ingormation
back and forth betweent the components. Buses are typically designed to transfer fiexed sized chunks of bytes know as words.
The number of bytes in a word is a fundamental system parameter that varies across systems. Most have word sizes of 8 bytes
(64 bits)today&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
