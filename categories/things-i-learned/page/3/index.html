<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Things I Learned | Neo VRAINS</title><meta name=keywords content><meta name=description content="Christophe's blog site"><meta name=author content="Christophe"><link rel=canonical href=https://www.sdlinks.net/categories/things-i-learned/><meta name=google-site-verification content="Neo VRAINS"><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://www.sdlinks.net/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.sdlinks.net/images/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.sdlinks.net/images/favicon-32x32.png><link rel=apple-touch-icon href=https://www.sdlinks.net/images/apple-touch-icon.png><link rel=mask-icon href=https://www.sdlinks.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://www.sdlinks.net/categories/things-i-learned/index.xml title=rss><link rel=alternate hreflang=en href=https://www.sdlinks.net/categories/things-i-learned/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=/css/katex.min.css><script defer src=/js/katex.min.js></script><script defer src=/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RH029G1TZ5"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RH029G1TZ5")}</script><meta property="og:url" content="https://www.sdlinks.net/categories/things-i-learned/"><meta property="og:site_name" content="Neo VRAINS"><meta property="og:title" content="Things I Learned"><meta property="og:description" content="Christophe's blog site"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Things I Learned"><meta name=twitter:description content="Christophe's blog site"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://www.sdlinks.net/ accesskey=h title="Neo VRAINS (Alt + H)">Neo VRAINS</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.sdlinks.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.sdlinks.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.sdlinks.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://www.sdlinks.net/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Things I Learned</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Address Space</h2></header><div class=entry-content><p>The Address Space The address space is the abstraction that OS is providing to the running program. The address space of a process contains all of the memory state of the running program. For example, the code of the program, the stack and the heap. In the sight of the program, it loaded into at a particular address and has a potentially very large address space, thus, we say that the OS is virtualizing memory.
...</p></div><footer class=entry-footer><span title='2018-06-24 23:54:04 +0000 UTC'>June 24, 2018</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to Address Space" href=https://www.sdlinks.net/posts/2018/address-space/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Computer System 4</h2></header><div class=entry-content><p>Linking Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into machine code; at load time, when the program is loaded into memory and executed by the loader; and even at run time, by application programs. On modern systems, linking is performed automatically by programs called linkers.
...</p></div><footer class=entry-footer><span title='2018-06-10 19:14:22 +0000 UTC'>June 10, 2018</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to Computer System 4" href=https://www.sdlinks.net/posts/2018/computer-system-4/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Computer System 3</h2></header><div class=entry-content><p>Optimization Writing an efficient program requires several type of activities. First, we must select an appropriate set of algorithms and data structures. Second, we must write source code that the compiler can effectively optimize to turn into efficient executable code. A third technique for dealing with especially demanding computations is to divide a task into portions that can be computed in parallel, on some combination of multiple cores and multiple processors.
...</p></div><footer class=entry-footer><span title='2018-06-01 23:23:16 +0000 UTC'>June 1, 2018</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to Computer System 3" href=https://www.sdlinks.net/posts/2018/computer-system-3/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Computer System 2</h2></header><div class=entry-content><p>Assembler Computer execute machine code, sequences of bytes encoding the low-level operations that manipulate data manage memory, read and write data on storage devices, and communicate over networks.
We will focus on x86-64, the commonest machine language used in processor with laptop and PC, also it’s widely used in supercomputer and lager data center.
the x86-64 machine code is much different with the corresponding C code, the processor states below are everywhere:
...</p></div><footer class=entry-footer><span title='2018-05-28 17:20:36 +0000 UTC'>May 28, 2018</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to Computer System 2" href=https://www.sdlinks.net/posts/2018/computer-system-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Computer System 1</h2></header><div class=entry-content><p>Hardware Organization of A System A typical system has those hadrware below:
Buses: Running throughout the system is a collection of electrical conduits called buses that carry bytes of ingormation back and forth betweent the components. Buses are typically designed to transfer fiexed sized chunks of bytes know as words. The number of bytes in a word is a fundamental system parameter that varies across systems. Most have word sizes of 8 bytes (64 bits)today
...</p></div><footer class=entry-footer><span title='2018-05-23 23:54:04 +0000 UTC'>May 23, 2018</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to Computer System 1" href=https://www.sdlinks.net/posts/2018/computer-system-1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>字符串处理算法</h2></header><div class=entry-content><p>字符串处理算法具有很高的重要性以及应用领域的多样性. 以下讨论默认的是扩展的ASCII字符集(R=256).
字符串排序算法 对于许多排序应用而言, 决定顺序的键都是字符串. 利用字符串的特殊性质来将其排序通常能够获得更高的效率.
键索引计数法 我们首先介绍一种适用于小整数键的简单排序算法.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class KeyIndexedCount { public static void sort(char[] chr, int R) { int[] count = new int[R + 1]; char[] temp = new char[chr.length]; for (char aChr : chr) { count[aChr + 1]++; } for (int i = 0; i &lt; R; i++) { count[i + 1] += count[i]; } for (char aChr : chr) { temp[count[aChr]] = aChr; count[aChr]++; } System.arraycopy(temp, 0, chr, 0, chr.length); } public static void sort(char chr[]) { sort(chr, 256); } } 进行频率统计, 将频率转换为索引, 任意一个键的起始位置总是在比它小的键的频率之和的后面, 用一个辅助数组进行排序, 将排序好的内容回写到原来的数组. 很容易发现, 算法仅仅使用了四个循环, 所以其时间复杂度是线性的(四次循环共访问数组10N+3R次). 上述算法的另一个显而易见的特性是排序的稳定性(因为该算法 按顺序遍历数组来排序).
...</p></div><footer class=entry-footer><span title='2018-05-07 21:18:59 +0000 UTC'>May 7, 2018</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to 字符串处理算法" href=https://www.sdlinks.net/posts/2018/string-algorithms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>图算法</h2></header><div class=entry-content><p>采用哪种数据结构来表示图, 主要考虑以下两个方面:
必须为可能在应用中碰到的各种类型的图预留出足够的空间, 以及 Graph的实例方法一定要高效. 常见的表示方法有以下几种:
邻接矩阵, 对于有N个顶点的图而言, 邻接矩阵需要$ N^2 $的空间. 边的数组, 通过定义边来定义图, 这种方法在寻找相邻的点时需要遍历整个数组. 邻接表数组, 使用一个顶点为索引的列表数组, 其中每个元素都是和该顶点相邻的顶点列表. 这种结构能够满足上述的两个条件. 常见实现的性能比较(V表示结点数, E表示边数):
数据结构 所需空间 添加边 检查顶点是否相邻 遍历所有相邻顶点 边的列表 E 1 E E 邻接矩阵 $ V^2 $ 1 1 V 邻接表 E+V 1 degree(V) degree(V) 非稠密图的标准表示是邻接表, 这种表示具有以下特性:
使用的空间和V+E成正比, 添加一条边所需要的时间为常数, 以及 遍历顶点v的所有相邻顶点所需要的时间和v的度数成正比. 无向图 无向图只定义了顶点以及顶点之间的关系.
深度优先搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class DepthFirstSearch { private boolean[] marked; private int count; public DepthFirstSearch(Graph G, int s) { marked = new boolean[G.V()]; dfs(G, s); } private void dfs(Graph G, int v) { marked[v] = true; count++; for (int w : G.adj(v)) { if (!marked[w]) { dfs(G, w); } } } public boolean marked(int w) { return marked[w]; } public int count() { return count; } } 深度优先搜索能够所有与起点相连的顶点, 且所需时间和所有连通顶点的度数之和成正比.
...</p></div><footer class=entry-footer><span title='2018-04-20 19:21:30 +0000 UTC'>April 20, 2018</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to 图算法" href=https://www.sdlinks.net/posts/2018/graph-algorithms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>查找算法</h2></header><div class=entry-content><p>符号表是一种存储键值对的数据结构, 支持插入和查找操作. 要确定一个给定的键是否存在于符号表中, 首先要建立对象等价性的概念. 为了保证一致性, 最好选择不 可变的数据类型作为键. 成本模型: 统计比较的次数, 在内循环不进行比较的情况下, 转为统计数组的访问次数.
二叉查找树 每个结点的键都大于其左子树的任意结点的键而小于右子树的任一结点的键. 一棵二叉查找树代表了一组键(及其相应的值)的集合, 同一个集合可以用多棵不同的二叉树 表示, 如果将所有键都投影到一条直线上, 则可以保证得到一个有序的键列.
查找的惯用做法是: 如果含有该键的结点存在于表中, 则返回相应的值或者返回null. 我们将采用Java 8的Optional类型使得查找的结果总是返回Optional, 将 显示的调用交给使用者.
使用二叉查找树的算法的运行时间取决于树的形状. 在最好的情况下, 一棵含有N个结点的树是完全平衡的, 每条空链接和根结点的距离都为lgN; 而在最坏的情况下 树的高度为N. 当键的分布是随机的情况下, 二叉查找树一般具有较好的平衡性, 此时查找或者插入操作平均所需的次数为2lnN(1.39lgN). 虽然二叉查找树的查找 成本比二分查找高约39%, 但插入操作是对数级别的.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class BST&lt;Key extends Comparable&lt;Key>, Value> { private Node root; private class Node { private Node left, right; private Key key; private Value val; private int N; Node(Key key, Value val, int N) { this.key = key; this.val = val; this.N = N; } } public int size() { return size(root); } private int size(Node node) { if (node == null) return 0; return node.N; } public Optional&lt;Value> get(Key key) { return Optional.of(get(root, key)); } private Value get(Node node, Key key) { if (node == null) return null; int cmp = key.compareTo(node.key); if (cmp > 0) get(node.right, key); else if (cmp &lt; 0) get(node.left, key); return node.val; } public void put(Key key, Value val) { root = put(root, key, val); } private Node put(Node node, Key key, Value val) { if (node == null) return new Node(key, val, 1); int cmp = key.compareTo(node.key); if (cmp > 0) node.right = put(node.right, key, val); else if (cmp &lt; 0) node.left = put(node.left, key, val); else node.val = val; node.N = size(node.left) + size(node.right) + 1; return node; } } 平衡查找树 2-3查找树 一棵2-3查找树或为一棵空树, 或者由以下结点组成:
...</p></div><footer class=entry-footer><span title='2018-04-05 15:21:41 +0000 UTC'>April 5, 2018</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to 查找算法" href=https://www.sdlinks.net/posts/2018/search-algorithms/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://www.sdlinks.net/categories/things-i-learned/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://www.sdlinks.net/categories/things-i-learned/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://www.sdlinks.net/>Neo VRAINS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>