<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>OCaml on CastOff</title>
    <link>http://www.sdlinks.net/tags/ocaml/</link>
    <description>Recent content in OCaml on CastOff</description>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <lastBuildDate>Fri, 13 Dec 2019 19:47:37 +0800</lastBuildDate>
    <atom:link href="http://www.sdlinks.net/tags/ocaml/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Value restriction，从OCaml到F#</title>
      <link>http://www.sdlinks.net/posts/2018/value-restriction/</link>
      <pubDate>Fri, 13 Dec 2019 19:47:37 +0800</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/value-restriction/</guid>
      <description>&lt;h2 id=&#34;value-restriction是什么&#34;&gt;Value Restriction是什么？&lt;/h2&gt;
&lt;p&gt;Value restriction是用于控制类型推断能否对值声明进行多态泛化的规则（&lt;a href=&#34;http://mlton.org/ValueRestriction&#34;&gt;MLton原文&lt;/a&gt;：“&lt;em&gt;The value restriction is a rule that governs when type inference is allowed to polymorphically generalize a value declaration.&lt;/em&gt;”）。常出现在ML系的语言中，如&lt;a href=&#34;https://www.smlnj.org/&#34;&gt;SML&lt;/a&gt;，&lt;a href=&#34;https://ocaml.org/&#34;&gt;OCaml&lt;/a&gt;，&lt;a href=&#34;https://fsharp.org/&#34;&gt;F#&lt;/a&gt;中，其实value restriction产生的本质原因是为了保证类型系统在结合参数多态与命令式特性（&lt;em&gt;imperative feature&lt;/em&gt;，如&lt;code&gt;ref&lt;/code&gt;）时候的可靠性（&lt;em&gt;soundness&lt;/em&gt;）。一个典型的例子就是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 如果没有value restriction
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ref&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;None&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// &amp;#39;a option ref
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;option&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ref&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// type checked
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;option&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ref&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// type checked
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Some&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// type checked
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt;  &lt;span class=&#34;nv&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;z&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 破坏了类型安全
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;限制了什么&#34;&gt;限制了什么？&lt;/h2&gt;
&lt;p&gt;简单来讲，value restriction限制了类型泛化只能发生在表达式的右边是句法意义上的值。那么什么是句法意义上的值呢，SML的&lt;a href=&#34;http://sml-family.org/sml97-defn.pdf&#34;&gt;语言规范&lt;/a&gt;上明确给出了什么样的表达式是句法意义上的值（准确来说是&lt;em&gt;non-expansive&lt;/em&gt;）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常量，如&lt;code&gt;13，&amp;quot;string&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;变量，如&lt;code&gt;x,y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数，如&lt;code&gt;fn x =&amp;gt; e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;除了&lt;code&gt;ref&lt;/code&gt;以外的构造函数在值上的调用，如&lt;code&gt;Foo v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;类型上受约束的值，如&lt;code&gt;v: t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每一个元素都是值的&lt;strong&gt;tuple&lt;/strong&gt;, 如&lt;code&gt;(v1, v2, v3)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每一个字段都是值的&lt;strong&gt;record&lt;/strong&gt;, 如&lt;code&gt;{l1 = v1, l2 = v2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每一个元素都是值的&lt;strong&gt;list&lt;/strong&gt;, 如&lt;code&gt;[v1, v2, v3]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确切的来讲，只要是协变（covariant）的类型并且不和可变的特性相结合，那么它总是可以类型安全的泛化（&lt;a href=&#34;https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html&#34;&gt;OCaml manual&lt;/a&gt;原文：“&lt;em&gt;As a corollary, covariant variables will never denote mutable locations and can be safely generalized.&lt;/em&gt;”）。即：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Functional Data Structure 2</title>
      <link>http://www.sdlinks.net/posts/2018/functional-data-structure-2/</link>
      <pubDate>Tue, 24 Jul 2018 15:54:24 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/functional-data-structure-2/</guid>
      <description>&lt;h2 id=&#34;amortization&#34;&gt;Amortization&lt;/h2&gt;
&lt;p&gt;Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case
bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about
the running time of any individual operation.&lt;/p&gt;
&lt;p&gt;For instance, given a sequence of n operations, we may wish to bound the
total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might
be satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n).
This freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and
faster than worst-case solutions with equivalent bounds.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Functional Data Structure 1</title>
      <link>http://www.sdlinks.net/posts/2018/functional-data-structure-1/</link>
      <pubDate>Thu, 19 Jul 2018 17:00:11 +0000</pubDate>
      <guid>http://www.sdlinks.net/posts/2018/functional-data-structure-1/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;To implement data structure in a functional way, there are two basic problems. First, from the point of view of designing
and implementing efficient data structures, functional programming&amp;rsquo;s stricture against destructive updates(i.e. assignments)
is a staggering handicap, tantamount to confiscating a master chef&amp;rsquo;s knives.&lt;/p&gt;
&lt;p&gt;Imperative data structures often rely on
assignments in crucial ways, and so different solutions must be found for functional programs. The second difficulty is
that functional data strcutures are expected to be more flexible than their imperative counterparts. In particular, when
we update an imperative data structure we typically accept that the old version of the data strcuture will no longer
be available, but when we update a functional data structure, we expect that both the old and the new version of the data
structure will be available for further processing, this is called &lt;em&gt;persistent&lt;/em&gt;, while the other is called &lt;em&gt;ephemeral&lt;/em&gt;.
And we are not surprised if the persistent version is more complicated and even less efficient that the ephemeral one.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
