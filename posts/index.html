<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Neo VRAINS</title><meta name=keywords content><meta name=description content="Posts - Neo VRAINS"><meta name=author content="Christophe"><link rel=canonical href=https://www.sdlinks.net/posts/><meta name=google-site-verification content="Neo VRAINS"><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://www.sdlinks.net/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.sdlinks.net/images/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.sdlinks.net/images/favicon-32x32.png><link rel=apple-touch-icon href=https://www.sdlinks.net/images/apple-touch-icon.png><link rel=mask-icon href=https://www.sdlinks.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://www.sdlinks.net/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://www.sdlinks.net/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=/css/katex.min.css><script defer src=/js/katex.min.js></script><script defer src=/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RH029G1TZ5"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RH029G1TZ5")}</script><meta property="og:url" content="https://www.sdlinks.net/posts/"><meta property="og:site_name" content="Neo VRAINS"><meta property="og:title" content="Posts"><meta property="og:description" content="Christophe's blog site"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Christophe's blog site"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.sdlinks.net/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://www.sdlinks.net/ accesskey=h title="Neo VRAINS (Alt + H)">Neo VRAINS</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.sdlinks.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.sdlinks.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.sdlinks.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://www.sdlinks.net/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Zvec：阿里巴巴开源的轻量级进程内向量数据库</h2></header><div class=entry-content><p>阿里巴巴开源的 Zvec 向量数据库是一个轻量级、快速的进程内向量数据库，为开发者提供了一个简单而强大的方式来构建向量搜索应用。在 AI 和向量搜索技术快速发展的今天，我们来深入了解这个值得关注的项目。
什么是 Zvec？ Zvec 是一个开源的进程内向量数据库，主打"轻量级、闪电般快速"。与传统的独立向量数据库服务不同，Zvec 采用进程内架构，可以直接嵌入到应用程序中运行。它基于阿里巴巴经过实战检验的 Proxima 向量搜索引擎构建，继承了阿里巴巴在高并发、大规模场景下的技术积累。
核心特性 极快的速度：能够在毫秒级别搜索数十亿个向量，性能表现优异 开箱即用：安装后几秒钟即可开始使用，无需复杂的服务器配置 多种向量支持：同时支持密集向量（dense vectors）和稀疏向量（sparse vectors） 混合搜索：可以结合语义相似度和结构化过滤条件进行精确搜索 跨平台运行：作为进程内库，可以在笔记本、服务器、CLI 工具甚至边缘设备上运行 数据持久化：支持本地文件存储，数据不会因为进程退出而丢失 快速上手 Zvec 目前支持 Python 和 Node.js 两种语言，Python 版本支持 3.10-3.12，覆盖了主流的开发环境。
安装 1 pip install zvec 或者使用 Node.js：
1 npm install @zvec/zvec 基本使用示例 让我们通过一个完整的例子来了解 Zvec 的基本用法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import zvec # 定义集合 schema schema = zvec.CollectionSchema( name="example", vectors=zvec.VectorSchema("embedding", zvec.DataType.VECTOR_FP32, 4), ) # 创建集合（本地文件存储） collection = zvec.create_and_open(path="./zvec_example", schema=schema) # 插入文档 collection.insert([ zvec.Doc(id="doc_1", vectors={"embedding": [0.1, 0.2, 0.3, 0.4]}), zvec.Doc(id="doc_2", vectors={"embedding": [0.2, 0.3, 0.4, 0.1]}), ]) # 按向量相似度搜索 results = collection.query( zvec.VectorQuery("embedding", vector=[0.4, 0.3, 0.3, 0.1]), topk=10 ) # 结果按相关性排序 print(results) 这个简单的例子展示了 Zvec 的三个核心操作：定义 schema、插入数据和搜索查询。
...</p></div><footer class=entry-footer><span title='2026-02-15 15:58:00 +0800 +0800'>February 15, 2026</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to Zvec：阿里巴巴开源的轻量级进程内向量数据库" href=https://www.sdlinks.net/posts/2026/zvec-lightweight-vector-database/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用 mcporter 发现和管理 MCP 工具</h2></header><div class=entry-content><p>最近在探索 AI 工具生态时，发现了一个很有用的工具——mcporter。这是一个专门用于 Model Context Protocol (MCP) 的 CLI 工具和生成器，可以帮助我们更方便地发现和使用各种 MCP 服务器提供的工具。
什么是 MCP？ Model Context Protocol (MCP) 是一个开放标准，定义了 AI 助手如何与外部工具和服务进行通信。通过 MCP，我们可以将各种功能集成到 AI 助手中，比如文档查询、数据库访问、API 调用等。
mcporter 的核心功能 mcporter 提供了几个关键功能：
1. 服务器管理 1 2 mcporter list # 列出所有配置的 MCP 服务器 mcporter list &lt;server> --schema # 查看特定服务器的工具定义 这个功能让我能够快速了解有哪些可用的工具，以及每个工具的输入输出格式。
2. 工具调用 1 mcporter call &lt;selector> [key=value ...] 可以直接调用 MCP 工具，支持通过 HTTP URL 或服务器名.工具名的选择器来定位。
3. 配置管理 mcporter 会自动从 config/mcporter.json 加载服务器配置，也支持从编辑器（如 Cursor、Claude）导入配置。
实际应用场景 配置好 mcporter 后，我发现它在以下几个场景特别有用：
...</p></div><footer class=entry-footer><span title='2026-02-14 01:03:00 +0800 +0800'>February 14, 2026</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to 使用 mcporter 发现和管理 MCP 工具" href=https://www.sdlinks.net/posts/2026/discovering-mcp-tools-with-mcporter/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>My LLM codegen workflow atm</h2></header><div class=entry-content><p>My LLM codegen workflow atm, Harper Reed在文中介绍了基于LLM的代码生成工作流。主要介绍了两种场景，开发一个新项目（Greenfield）以及老项目的持续迭代(Non-greenfield)。
新项目基于需求细化（spec），计划制定（todo）以及代码生成三部分来开展。老项目则通过生成代码上下文（repomix）来制定测试回归和代码审查任务。这对我来说是一个巨大的启发，准备找时间试一下其中描述的工作流程。
同时Harper Reed也给出了具体的Prompt，局限于目前LLM的特性，仍然需要通过提示工程来引导AI生成我们需要的内容。前一阵子较火的DeepSeek从入门到精通也指出掌握提示语设计是AIGC时代的必备技能，在平时使用这些LLM工具中也感受到怎么清晰的向AI表达需求非常重要，因为你的提示语完全决定了AI生成的质量，进而决定了AI是否好用或者为你带来提效。另外，由于中文的特性（高上下文依赖）以及模型的训练数据分布，可能会出现提示效果不如英文的情况。</p></div><footer class=entry-footer><span title='2025-02-23 21:05:33 +0800 +0800'>February 23, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;<a href=/categories/things-ive-found> Things I've Found</a></footer><a class=entry-link aria-label="post link to My LLM codegen workflow atm" href=https://www.sdlinks.net/posts/2025/my-llm-codegen-workflow-atm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 1.24</h2></header><div class=entry-content><p>Go 1.24 Release Notes， Go 1.24已经于2.11正式发布，主要语言特性为泛型类型别名和基于Swiss Tables的map实现，通过轻微的delete性能损耗来显著提升查询和插入的性能（via）。</p></div><footer class=entry-footer><span title='2025-02-16 17:23:47 +0800 +0800'>February 16, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;<a href=/categories/things-ive-found> Things I've Found</a></footer><a class=entry-link aria-label="post link to Go 1.24" href=https://www.sdlinks.net/posts/2025/go1-24/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Three Observations</h2></header><div class=entry-content><p>Three Observations, 奥尔特曼提出了关于AI经济学的3个论断：
AI模型的智能水平大致等于用于训练和运行它的资源的对数； 使用特定水平的AI的成本每12个月大约下降10倍（摩尔定律18个月才有2倍）； 线性增加的智能所带来的社会经济价值是超指数级的。 随着DeepSeek-R1的火爆，整个社会更广泛的进入了AI时代，一众大厂应用纷纷接入，普通人使用的成本进一步下降。之前一直有观点认为AI会逐步淘汰部分岗位，并且这种事情会首先发生在程序员这个职业上。目前就我个人的体验来讲，AI现在已经能做到生成不错的代码，处理较为复杂的任务。虽然在整个公司层面还没有开始大规模在开发流程中使用AI，但我认为这是未来近几年的方向，届时会出现Cursor、通义灵码这些产品的终极形态，AI变成你的同事。而作为程序员的我们，工作方式会更向需求分析、架构设计和团队协作等需要人类创造力和判断力的方向靠拢（via）。</p></div><footer class=entry-footer><span title='2025-02-11 19:36:13 +0800 +0800'>February 11, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;<a href=/categories/things-ive-found> Things I've Found</a></footer><a class=entry-link aria-label="post link to Three Observations" href=https://www.sdlinks.net/posts/2025/three-observations/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Restart As a Link Blog</h2></header><div class=entry-content><p>Build a link blog, 最近从Simon Willison看到的想法，觉得是一个重新捡起Blog的机会。这个依托于Github Pages 的博客站点荒废了好久，最早可以追溯到2018年，彼时还未大学毕业，中间有一段时间荒废，后续迁移到博客园上重启，过来一段时间后又荒废。如今又重新捡起，说实话整体感受还是比较复杂的，之前荒废的原因无外乎以下几点：
懒； 觉得无法输出有意思的观点，只是在拾人牙慧； 由于2，导致写blog过程中没收到什么反馈，没有反馈的事情，对人类来说还是太难坚持了。 但是近期从Simon Willison那了解到了关于blog内容的新思路：
It’s easy to get hung up on this. I’ve definitely felt the self-imposed pressure to only write something if it’s new, and unique, and feels like it’s never been said before. This is a mental trap that does nothing but hold you back.
这个我深有同感，一开始其实整体内容围绕着一些常见的学习知识点、读书内容，慢慢就发现，如果说我不能输出独特的观点，这值得我写一篇文章/博客吗？进而转到如果我的博客没人看，我还要花时间在上面吗？甚至之前还觉得我应该写英文文章，这样部署在Github Pages才有更多的读者。说回来，Simon Willison认为blog的价值在于保持长期的写作习惯，同时随着时间的推移有所收获， 同时Simon Willison给出了写blog的几个内容(via)：
TIL(Things I Learned)； DMP(Descriptions of My Projects)； TIF(Things I’ve Found)。 基于3就衍生出了本文的主题，“links”, 也就是说通过blog的形式分享记录自己阅读的内容。作为一个Link Blog, 可以包含以下内容：
...</p></div><footer class=entry-footer><span title='2025-02-09 12:59:29 +0800 +0800'>February 9, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;<a href=/categories/things-ive-found> Things I've Found</a></footer><a class=entry-link aria-label="post link to Restart As a Link Blog" href=https://www.sdlinks.net/posts/2025/restart-a-link-blog/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>函数式数据结构漫谈（一）</h2></header><div class=entry-content><p>近期计划开这个系列的坑，内容大多都是“Purely Functional Data Structures”内容加一点自己的理解（改一张牌就是我的了:），算是打磨文笔？
数据结构是什么 当我们在讨论数据结构的时候，我们在讨论什么。常见的介绍有“数据结构是一种数据组织、管理和存储的格式，它可以帮助我们实现对数据高效的访问和修改，更准确地说， 数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作”。然而到更具体的场景，数据结构的概念还能够细化，比如我们经常会 讨论函数栈怎么怎么样，这里的“函数栈”也是数据结构，但它是一个泛指，是一个在程序执行过程中存在的概念，或者叫标识。Okasaki在他的“Purely Functional Data Structures”里指出，数据结构这一概念通常有四种含义：
抽象，即抽象数据类型(abstract data type，可以用Java中的interface理解)，即表示数据的类型和一组适用于该类型的函数； 实现，即对应于ADT的一个具体实现，通常是指对于该ADT做的具体设计； 实例，即在程序运行中对应于一个数据类型的具体实例； 泛指，即在程序运行中一个泛指的概念，不涉及具体的实例，例如上文提到的函数栈。 本系列将使用Haskell作为描述语言，则其中class可对应抽象的概念，data可对应实现的概念。具体到Java，可以用interface对应抽象的概念，用class对应实现 的概念。 函数式强调的是什么 抛开函数式编程本身强调的函数以外（不然就没法讲了），函数式编程通常还强调不可变（immutable）。因此，当我们说一个数据结构符合函数式的特性的时候主要在讨论不可变， 或者说持久性（persistence）。换句话说，在更新一个函数式的数据结构之后，它更新前的版本我们仍然能够访问到。这意味着所有有着破坏式更新的数据结构都不符合这一性质， 同时也表明相较于能够进行破坏式更新的数据结构，函数式数据结构的性能可能会更差，通常会有一个对数阶的更新代价在里面。实现持久性的方式非常简单，只需要将原有的数据结构 复制一遍，然后在复制后的数据结构上更新，由于没有破坏式的更，可以通过共享不变的部分来减少开销。下面讨论在函数式编程中经典的list。
List list在任何编程语言中都是非常常见的存在，函数式编程对其讨论则更多，著名的Lisp就取自“LISt Processor”。我们首先来看广泛的list定义
1 2 3 4 5 6 7 class List t where empty :: t a isEmpty :: t a -> Bool cons :: a -> t a -> t a -- error if the list is empty. head :: t a -> a tail :: t a -> t a 这里可以考虑将head和tail的结果包装一个Maybe，使之适合空的list，在这种情况下isEmpty就不再需要，因为head ls = Nothing或 tail ls = Nothing已经暗含isEmpty ls = true。本文为了偷懒就没用这种定义）。有了这些，我们就可以实现list上的各种“更高级的” 操作，例如经典的map：
1 2 3 4 map :: List t => (a -> b) -> t a -> t b map f ls = if isEmpty ls then emptll else cons (f $ head ls) (map f $ tail ls) 从这个定义上可以直接看出，这个List是不支持随机访问的。因此，我们额外定义支持“按下标”随机访问的class：
...</p></div><footer class=entry-footer><span title='2021-04-06 23:26:20 +0800 +0800'>April 6, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to 函数式数据结构漫谈（一）" href=https://www.sdlinks.net/posts/2021/fp-data-structure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Memoization in Haskell</h2></header><div class=entry-content><p>Memoization是动态规划(Dynamic Programming)中自顶向下处理问题采用的策略, 其基本想法是通过将子问题的解保存起来避免重复计算来优化算法. 这个概念本身很简单, 在其他有明显mutable语义的语言中, 实现起来也非常简单. 但是在Haskell中问题就变的复杂了不少, 对于一个原始的函数f :: a -> b你如果要用ref, 比如说IORef, 你必须要把它放到IO monad中, 你的memoize函数就变成了... -> IO (a -> b). 我们希望是能够找到一个memoize :: ... -> (a -> b), 这样memoize之后得到的和原函数类型是一致的. 为了讨论的方便, 我们主要关注两个例子的memoization, 一个是经典的Fibonacci数列:
1 2 3 4 fib :: Int -> Integer fib 0 = 0 fib 1 = 1 fib n = fib (n - 2) + fib (n - 1) 另一个则是动态规划(自底向上)中典型的最小编辑距离的问题, 所谓的最小编辑距离就是一个字符串通过增加, 删除, 替换的操作得到另一个字符串所需要的操作次数:
1 2 3 4 5 6 minEditDist :: String -> String -> Int minEditDist [] [] = 0 minEditDist s [] = length s minEditDist [] s = length s minEditDist (x:xs) (y:ys) | x == y = minEditDist xs ys | otherwise = 1 + minimum [minEditDist xs ys, minEditDist xs (y:ys), minEditDist (x:xs) ys] Memoizing with specific problem 首先来看fib的问题, wiki给出了一个非常elegant的解(就fib本身而言, 还有更经典的解, fib = (fibs !!) where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)):
...</p></div><footer class=entry-footer><span title='2020-06-19 21:39:35 +0800 +0800'>June 19, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></footer><a class=entry-link aria-label="post link to Memoization in Haskell" href=https://www.sdlinks.net/posts/2020/memoization-in-haskell/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://www.sdlinks.net/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://www.sdlinks.net/>Neo VRAINS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>