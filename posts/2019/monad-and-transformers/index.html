<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Monad and Transformers | CastOff</title>
<meta name=keywords content="Haskell"><meta name=description content="Monad是Haskell中讨论最多的结构, 需要更详细的探讨其相关内容, 即使它对于Haskell而言不是必须的:(.
参考: All about Monads
Monad Support
除了之前介绍过的一些基本函数, Haskell本身定义了一些辅助函数配合Monad一起使用:


sequence


1
2
3
4


-- 任意一个fail会导致整个fail
sequence :: Monad m => [m a] -> m [a]
sequence = foldr mcons (return [])
						where mcons p q = p >>= \x -> q >>= \y -> return (x : y)




sequence_和sequence类似但其不返回值, 在只关心序列的副作用时其非常有用.


1
2


sequence_ :: Monad m => [m a] -> m ()
sequence_ = flodr (>>) (return ())




mapM其由sequence和map定义


1
2


mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f as = sequence $ map f as




mapM_, 类似的使用sequence_定义


1
2


mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
mapM_ f as = sequence_ $ map f as




=<<是>>=调换参数位置的版本


1
2


(=<<) :: Monad m => (a -> m b) -> m a -> m b
f =<< x = x >>= f




上面提到的函数都是standard prelude中定义的, Haskell在Control.Monad模块中定义了更多函数.
下面是一些列表函数的Monad版本:


foldM


1
2
3


foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
foldM f a [] = return a
foldM f a (x:xs) = f a x >>= \y -> foldM f y xs




filterM


1
2
3
4
5


filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
filterM p [] = return []
filterM p (x:xs) = do b  <- p x
										 ys <- filterM p xs
                      return (if b then (x:ys) else ys)




zipWithM和zipWithM_"><meta name=author content="Christophe"><link rel=canonical href=http://www.sdlinks.net/posts/2019/monad-and-transformers/><meta name=google-site-verification content="CastOff"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://www.sdlinks.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://www.sdlinks.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://www.sdlinks.net/favicon-32x32.png><link rel=apple-touch-icon href=http://www.sdlinks.net/apple-touch-icon.png><link rel=mask-icon href=http://www.sdlinks.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://www.sdlinks.net/posts/2019/monad-and-transformers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://www.sdlinks.net/posts/2019/monad-and-transformers/"><meta property="og:site_name" content="CastOff"><meta property="og:title" content="Monad and Transformers"><meta property="og:description" content="Monad是Haskell中讨论最多的结构, 需要更详细的探讨其相关内容, 即使它对于Haskell而言不是必须的:(.
参考: All about Monads
Monad Support 除了之前介绍过的一些基本函数, Haskell本身定义了一些辅助函数配合Monad一起使用:
sequence
1 2 3 4 -- 任意一个fail会导致整个fail sequence :: Monad m => [m a] -> m [a] sequence = foldr mcons (return []) where mcons p q = p >>= \x -> q >>= \y -> return (x : y) sequence_和sequence类似但其不返回值, 在只关心序列的副作用时其非常有用.
1 2 sequence_ :: Monad m => [m a] -> m () sequence_ = flodr (>>) (return ()) mapM其由sequence和map定义
1 2 mapM :: Monad m => (a -> m b) -> [a] -> m [b] mapM f as = sequence $ map f as mapM_, 类似的使用sequence_定义
1 2 mapM_ :: Monad m => (a -> m b) -> [a] -> m () mapM_ f as = sequence_ $ map f as =<<是>>=调换参数位置的版本
1 2 (=<<) :: Monad m => (a -> m b) -> m a -> m b f =<< x = x >>= f 上面提到的函数都是standard prelude中定义的, Haskell在Control.Monad模块中定义了更多函数.
下面是一些列表函数的Monad版本:
foldM
1 2 3 foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a foldM f a [] = return a foldM f a (x:xs) = f a x >>= \y -> foldM f y xs filterM
1 2 3 4 5 filterM :: Monad m => (a -> m Bool) -> [a] -> m [a] filterM p [] = return [] filterM p (x:xs) = do b <- p x ys <- filterM p xs return (if b then (x:ys) else ys) zipWithM和zipWithM_"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-04-06T20:26:43+00:00"><meta property="article:modified_time" content="2019-04-06T20:26:43+00:00"><meta property="article:tag" content="Haskell"><meta name=twitter:card content="summary"><meta name=twitter:title content="Monad and Transformers"><meta name=twitter:description content="Monad是Haskell中讨论最多的结构, 需要更详细的探讨其相关内容, 即使它对于Haskell而言不是必须的:(.
参考: All about Monads
Monad Support
除了之前介绍过的一些基本函数, Haskell本身定义了一些辅助函数配合Monad一起使用:


sequence


1
2
3
4


-- 任意一个fail会导致整个fail
sequence :: Monad m => [m a] -> m [a]
sequence = foldr mcons (return [])
						where mcons p q = p >>= \x -> q >>= \y -> return (x : y)




sequence_和sequence类似但其不返回值, 在只关心序列的副作用时其非常有用.


1
2


sequence_ :: Monad m => [m a] -> m ()
sequence_ = flodr (>>) (return ())




mapM其由sequence和map定义


1
2


mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f as = sequence $ map f as




mapM_, 类似的使用sequence_定义


1
2


mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
mapM_ f as = sequence_ $ map f as




=<<是>>=调换参数位置的版本


1
2


(=<<) :: Monad m => (a -> m b) -> m a -> m b
f =<< x = x >>= f




上面提到的函数都是standard prelude中定义的, Haskell在Control.Monad模块中定义了更多函数.
下面是一些列表函数的Monad版本:


foldM


1
2
3


foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
foldM f a [] = return a
foldM f a (x:xs) = f a x >>= \y -> foldM f y xs




filterM


1
2
3
4
5


filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
filterM p [] = return []
filterM p (x:xs) = do b  <- p x
										 ys <- filterM p xs
                      return (if b then (x:ys) else ys)




zipWithM和zipWithM_"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://www.sdlinks.net/posts/"},{"@type":"ListItem","position":2,"name":"Monad and Transformers","item":"http://www.sdlinks.net/posts/2019/monad-and-transformers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Monad and Transformers","name":"Monad and Transformers","description":"Monad是Haskell中讨论最多的结构, 需要更详细的探讨其相关内容, 即使它对于Haskell而言不是必须的:(.\n参考: All about Monads\nMonad Support 除了之前介绍过的一些基本函数, Haskell本身定义了一些辅助函数配合Monad一起使用:\nsequence\n1 2 3 4 -- 任意一个fail会导致整个fail sequence :: Monad m =\u0026gt; [m a] -\u0026gt; m [a] sequence = foldr mcons (return []) where mcons p q = p \u0026gt;\u0026gt;= \\x -\u0026gt; q \u0026gt;\u0026gt;= \\y -\u0026gt; return (x : y) sequence_和sequence类似但其不返回值, 在只关心序列的副作用时其非常有用.\n1 2 sequence_ :: Monad m =\u0026gt; [m a] -\u0026gt; m () sequence_ = flodr (\u0026gt;\u0026gt;) (return ()) mapM其由sequence和map定义\n1 2 mapM :: Monad m =\u0026gt; (a -\u0026gt; m b) -\u0026gt; [a] -\u0026gt; m [b] mapM f as = sequence $ map f as mapM_, 类似的使用sequence_定义\n1 2 mapM_ :: Monad m =\u0026gt; (a -\u0026gt; m b) -\u0026gt; [a] -\u0026gt; m () mapM_ f as = sequence_ $ map f as =\u0026lt;\u0026lt;是\u0026gt;\u0026gt;=调换参数位置的版本\n1 2 (=\u0026lt;\u0026lt;) :: Monad m =\u0026gt; (a -\u0026gt; m b) -\u0026gt; m a -\u0026gt; m b f =\u0026lt;\u0026lt; x = x \u0026gt;\u0026gt;= f 上面提到的函数都是standard prelude中定义的, Haskell在Control.Monad模块中定义了更多函数.\n下面是一些列表函数的Monad版本:\nfoldM\n1 2 3 foldM :: (Monad m) =\u0026gt; (a -\u0026gt; b -\u0026gt; m a) -\u0026gt; a -\u0026gt; [b] -\u0026gt; m a foldM f a [] = return a foldM f a (x:xs) = f a x \u0026gt;\u0026gt;= \\y -\u0026gt; foldM f y xs filterM\n1 2 3 4 5 filterM :: Monad m =\u0026gt; (a -\u0026gt; m Bool) -\u0026gt; [a] -\u0026gt; m [a] filterM p [] = return [] filterM p (x:xs) = do b \u0026lt;- p x ys \u0026lt;- filterM p xs return (if b then (x:ys) else ys) zipWithM和zipWithM_\n","keywords":["Haskell"],"articleBody":"Monad是Haskell中讨论最多的结构, 需要更详细的探讨其相关内容, 即使它对于Haskell而言不是必须的:(.\n参考: All about Monads\nMonad Support 除了之前介绍过的一些基本函数, Haskell本身定义了一些辅助函数配合Monad一起使用:\nsequence\n1 2 3 4 -- 任意一个fail会导致整个fail sequence :: Monad m =\u003e [m a] -\u003e m [a] sequence = foldr mcons (return []) where mcons p q = p \u003e\u003e= \\x -\u003e q \u003e\u003e= \\y -\u003e return (x : y) sequence_和sequence类似但其不返回值, 在只关心序列的副作用时其非常有用.\n1 2 sequence_ :: Monad m =\u003e [m a] -\u003e m () sequence_ = flodr (\u003e\u003e) (return ()) mapM其由sequence和map定义\n1 2 mapM :: Monad m =\u003e (a -\u003e m b) -\u003e [a] -\u003e m [b] mapM f as = sequence $ map f as mapM_, 类似的使用sequence_定义\n1 2 mapM_ :: Monad m =\u003e (a -\u003e m b) -\u003e [a] -\u003e m () mapM_ f as = sequence_ $ map f as =\u003c\u003c是\u003e\u003e=调换参数位置的版本\n1 2 (=\u003c\u003c) :: Monad m =\u003e (a -\u003e m b) -\u003e m a -\u003e m b f =\u003c\u003c x = x \u003e\u003e= f 上面提到的函数都是standard prelude中定义的, Haskell在Control.Monad模块中定义了更多函数.\n下面是一些列表函数的Monad版本:\nfoldM\n1 2 3 foldM :: (Monad m) =\u003e (a -\u003e b -\u003e m a) -\u003e a -\u003e [b] -\u003e m a foldM f a [] = return a foldM f a (x:xs) = f a x \u003e\u003e= \\y -\u003e foldM f y xs filterM\n1 2 3 4 5 filterM :: Monad m =\u003e (a -\u003e m Bool) -\u003e [a] -\u003e m [a] filterM p [] = return [] filterM p (x:xs) = do b \u003c- p x ys \u003c- filterM p xs return (if b then (x:ys) else ys) zipWithM和zipWithM_\n1 2 3 4 5 zipWithM :: (Monad m) =\u003e (a -\u003e b -\u003e m c) -\u003e [a] -\u003e [b] -\u003e m [c] zipWithM f xs ys = sequence (zipWith f xs ys) zipWithM_ :: (Monad m) =\u003e (a -\u003e b -\u003e m c) -\u003e [a] -\u003e [b] -\u003e m () zipWithM_ f xs ys = sequence_ (zipWith f xs ys) Monad模块中还包含了一些流程控制函数, when和unless:\n1 2 3 4 5 when :: (Monad m) =\u003e Bool -\u003e m () -\u003e m () when p s = if p then s else return () unless :: (Monad m) =\u003e Bool -\u003e m () -\u003e m () unless p s = when (not p) s _Lifting_将一个non-monadic函数转换为在Monad上操作的等价函数. 最简单的lift函数是liftM:\n1 2 liftM :: (Monad m) =\u003e (a -\u003e b) -\u003e (m a -\u003e m b) liftM f = \\a -\u003e do {a' \u003c- a; return (f a')} Control.Monad模块中定义了liftM, liftM2到liftM5分别将不同参数个数的函数lift成monadic. 另外还定义了$的monadic版本:\n1 2 ap :: (Monad m) =\u003e m (a -\u003e b) -\u003e m a -\u003e m b ap = liftM2 ($) Monads The Identity Monad Identity Monad(Data.Functor.Identity)不包含任何计算:\n1 2 3 4 5 newtype Identity a = Identity {runIdentity :: a} instance Monad Identity where return a = Identity a (Identity x) \u003e\u003e= f = f x Identity Monad是Monad转换的基石, 任意一个Monad transformer作用在Identity Monad上返回一个非转换器版本的Monad.\nThe Maybe Monad Maybe Monad表示有可能不返回值(Nothing)的计算:\n1 2 3 4 5 6 7 8 9 10 11 12 data Maybe a = Nothing | Just a instance Monad Maybe where return = Just fail = Nothing Nothing \u003e\u003e= f = Nothing (Just x) \u003e\u003e= f = f x instance MonadPlus Maybe where mzero = Nothing Nothing `mplus` x = x x `mplus` _ = x The Error Monad Error Monad(或Exception Monad)表示可能出错或抛出异常的计算, 例如Either Monad. Haskell中的MonadError是由错误的类型和相应Monad构造器参数化的:\n1 2 3 4 5 6 7 class Error a where noMsg :: a strMsg :: String -\u003e a class (Monad m) =\u003e MonadError e m | m -\u003e e where throwError :: e -\u003e m a catchError :: m a -\u003e (e -\u003e m a) -\u003e m a catchError一种常见的使用是do {action1; action2; action3} `catchError` handler , 其中action可以调用throwError, 且handler和do-block必须有相同的返回类型. Either e则实例化了MonadError:\n1 2 3 4 instance MonadError (Either e) where throwError = Left (Left e) `catchError` handler = handler e a `catchError` _ = a The List Monad List monad表示可能返回0, 1, 或多个值的计算:\n1 2 3 4 5 6 7 8 9 10 data [] a = [] | a : [a] instance Monad [] where m \u003e\u003e= f = concatMap f m return x = [x] fail s = [] instance MonadPlus [] where mzero = [] mplus = (++) The IO Monad The IO Monad is just an instance of the ST monad, where the state is the real world.\nThe wonderful feature of a one-way monad is that it can support side-effects in its monadic operations but prevent them from destroying the functional properties of the non-monadic portions of the program.*\n需要注意的是, IO Monad并不是IO, 而仅仅是IO类型的Monad实例.GHC经常会为了提升性能而优化代码, 诸如调整运算顺序, 共享变量, 内联函数. IO类型的最主要工作就是禁止其中的大部分工作. 显然调整运算顺序就在IO(以及ST)中被禁止, IO操作被包含在嵌套的lambdas中以保证运算顺序的不变. 之所以需要IO Monad是因为这是一种将嵌套lambdas的噪声剥离的抽象. IO Monad是一种One-way Monad, One-way Monad意味着你无法设计一个函数在IO Monad中完成计算并返回一个没有IO Monad类型的值. IO monad的定义是平台相关的, 且没有任何构造器可以使用, 也没有任何函数能够从IO Monad中获得值.\nThe State Monad State Monad表示带有状态的计算:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 newtype State s a = State {runState :: s -\u003e (a, s)} instance Monad (State s) where return a = State $ \\s -\u003e (a, s) (State x) \u003e\u003e= f = State $ \\s -\u003e let (v, s') = x s in runState (f v) s' -- 提供了State Monad的一些接口 class MonadState m s | m -\u003e s where get :: m s put :: s -\u003e m () instance MonadState (State s) s where get = State $ \\s -\u003e (s, s) -- 通过将值设置为状态来获取状态 put s = State $ \\_ -\u003e ((), s) -- 设置状态且没有值 The Reader Monad Reader Monad表示从共享环境中读取值的计算:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- Monad instance of `(-\u003e) r` newtype Reader e a = Reader {runReader :: (e -\u003e a)} instance Monad (Reader e) where return a = Reader $ \\e -\u003e a (Reader r) \u003e\u003e= f = Reader $ \\e -\u003e runReader (f $ r e) e class MonadReader e m | m -\u003e e where ask :: m e local :: (e -\u003e e) -\u003e m a -\u003e m a instance MonadReader (Reader e) where ask = Reader id local f c = Reader $ \\e -\u003e runReader c (f e) asks :: (MonadReader e m) =\u003e (e -\u003e a) -\u003e m asks sel = ask \u003e\u003e= return . sel The Writer Monad Write Monad表示除了计算值以外还产生数据流的计算:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 newtype Writer w a = Writer { runWriter :: (a,w) } instance (Monoid w) =\u003e Monad (Writer w) where return a = Writer (a,mempty) (Writer (a,w)) \u003e\u003e= f = let (a',w') = runWriter $ f a in Writer (a',w `mappend` w') class (Monoid w, Monad m) =\u003e MonadWriter w m | m -\u003e w where pass :: m (a,w -\u003e w) -\u003e m a listen :: m a -\u003e m (a,w) tell :: w -\u003e m () instance (Monoid w) =\u003e MonadWriter w (Writer w) where pass (Writer ((a,f),w)) = Writer (a,f w) listen (Writer (a,w)) = Writer ((a,w),w) tell s = Writer ((),s) listens :: (MonadWriter w m) =\u003e (w -\u003e b) -\u003e m a -\u003e m (a,b) listens f m = do (a,w) \u003c- listen m; return (a,f w) censor :: (MonadWriter w m) =\u003e (w -\u003e w) -\u003e m a -\u003e m a censor f m = pass $ do a \u003c- m; return (a,f) The Continuation monad Continuation Monad表示可以被打断和恢复的计算(没错, 就是continuation):\n1 2 3 4 5 6 7 8 9 10 11 12 -- r is the final result type of the whole computation newtype Cont r a = Cont { runCont :: ((a -\u003e r) -\u003e r) } instance Monad (Cont r) where return a = Cont $ \\k -\u003e k a (Cont c) \u003e\u003e= f = Cont $ \\k -\u003e c (\\a -\u003e runCont (f a) k) class (Monad m) =\u003e MonadCont m where callCC :: ((a -\u003e m b) -\u003e m a) -\u003e m a instance MonadCont (Cont r) where callCC f = Cont $ \\k -\u003e runCont (f (\\a -\u003e Cont $ \\_ -\u003e k a)) k Combining monads Functors和applicatives对于composition都是封闭的, 但两个monad结合却不一定是另一个monad. 一个monad transformer是一个接受monad作为monad作为参数的类型构造器, 类似与一个wrapper(因此很多都是用newtype定义的).\nCompose Compose类型代表着函数结合:\n1 newtype Compose f g a = Compose {getCompose :: f (g a)} deriving (Eq, Show) 这里的f, g不在是普遍意义上的函数, 而是类型构造器. 我们很容易实现Compose的Functor实例:\n1 2 instance (Functor f, Functor g) =\u003e Functor (Compose f g) where fmap f (Compose fga) = Compose $ (fmap . fmap) f fga 容易看到两个Functor结合之后依然可以是一个Functor. 同样的, 我们也可以定义Applicative实例:\n1 2 3 instance (Applicative f, Applicative g) =\u003e Applicative (Compose f g) where pure = Compose . pure . pure Compose fgf \u003c*\u003e Compose fga = Compose $ (\u003c*\u003e) \u003c$\u003e fgf \u003c*\u003e fga 如果我们要定义Compose的Monad实例, 就需要实现(\u003e\u003e=)或:\n1 2 3 (\u003e\u003e=) :: Compose f g a -\u003e (a -\u003e Compose f g b) -\u003e Compose f g b -- 或者通过join来实现\u003e\u003e= join :: Compose f g (Compose f g a) -\u003e Compose f g a 我们总是可以忽略掉外层的Compose, 此时对于join而言, 我们就得打了f g (f g a) -\u003e f g a, 如果存在一个函数aux :: (Monad f, Monad g) =\u003e f (g a) -\u003e g (f a), 那么我们就可以从f g (f g a)中获得f g a, 因为对于f和g而言都有各自的join, 使得 f (f a) -\u003e f a. 然而并不是对于每个monad都存在这样的aux, 例如IO (Maybe a) -\u003e Maybe (IO a)就不存在这样的aux. 因而\"Monad do not compose\", 此时我们就需要monad transformer.\nIdentityT 我们已经看到对于任意的两个monad的compose, join并不总是可以的. 因此我们需要限制其中一个monad, 希望它对于另外一个任意的monad的compose总是可行的. 我们从IdentityT开始介绍monad transformer:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 newtype Identity a = Identity {runIdentity :: a} deriving (Eq, Show) instance Functor Identity where fmap f (Identity) = Identity $ f a instance Applicative Identity where pure = Identity Identity f \u003c*\u003e Identity a = Identity $ f a instance Monad Identity where Identity a \u003e\u003e= f = f a newtype IdentityT m a = IdentityT {runIdentityT :: m a} deriving (Eq, Show) instance Functor (IdentityT m) where fmap f (IdentityT ma) = IdentityT $ fmap f ma instance Applicative (IdentityT m) where pure a = IdentityT $ pure a IdentityT mab \u003c*\u003e IdentityT ma = IdentityT $ mab \u003c*\u003e fa instance Monad (IdentityT m) where IdentityT ma \u003e\u003e= f = IdentityT $ ma \u003e\u003e= runIdentityT . f 在这里我们限制了其中一个monad为Identity, 此时可以实现Monad实例, 因为我们有runIdentityT来获取额外的信息. 更一般的, 对于两个有Monad实例的类型f, g, 组合它们最终会止步与f(g (f b)), 而transformer的作用就是限制了g, 使得能够得到f (f b).\nMaybeT 1 newtype MaybeT m a = MaybeT {runMaybeT :: m (Maybe a)} Functor实例和Applicative实例都可以直接从之前的Compose拿过来\n1 2 3 4 5 6 instance (Functor m) =\u003e Functor (MaybeT m) where fmap f (Maybe ma) = MaybeT $ (fmap . fmap) f ma instance (Applicative m) =\u003e Applicative (MaybeT m) where pure = MaybeT . pure . pure MaybeT fab \u003c*\u003e MaybeT mma = MaybeT $ (\u003c*\u003e) \u003c$\u003e fab \u003c*\u003e mma 终于到了Monad实例:\n1 2 3 4 5 6 instance (Monad m) =\u003e Monad (MaybeT m) where (MaybeT ma) \u003e\u003e= f = MaybeT $ do v \u003c- ma case v of Nothing -\u003e return Nothing Just y -\u003e runMaybeT (f y) EitherT EitherT和MaybeT的处理是类似的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 newtype EitherT e m a = EitherT {runEitherT :: m (Either e a)} instance Functor m =\u003e Functor (EitherT e m) where fmap f (EitherT ema) = EitherT $ (fmap . fmap) f ema instance Applicative m =\u003e Applicative (EitherT e m) where pure = EitherT . pure . pure EitherT emab \u003c*\u003e EitherT ema = EitherT $ (\u003c*\u003e) \u003c$\u003e emab \u003c*\u003e ema instance Monad m =\u003e Monad (EitherT e m) where EitherT ema \u003e\u003e= f = EitherT $ do v \u003c- ema case v of Right y -\u003e runEitherT $ f y Left x -\u003e return $ Left x ReaderT ReaderT是常规的Haskell应用中用到最多的transformer\n1 newtype ReaderT r m a = ReaderT {runReaderT :: r -\u003e m a} 不过其处理和MaybeT以及EitherT处理依然是类似的, 注意ReaderT的参数是一个函数.\n1 2 3 4 5 6 7 8 9 10 11 instance Functor m =\u003e Functor (ReaderT r m) where fmap f (ReaderT rma) = ReaderT $ (fmap . fmap) f rma instance Applicative m =\u003e Applicative (ReaderT r m) where pure = ReaderT . pure . pure ReaderT fmab \u003c*\u003e ReaderT rma = ReaderT $ (\u003c*\u003e) \u003c$\u003e fmab \u003c*\u003e rma instance Monad m =\u003e Monad (ReaderT r m) where ReaderT rma \u003e\u003e= f = ReaderT $ \\r -\u003e do a \u003c- rma r runReaderT (f a) r StateT StateT和ReaderT是类似的不过StateT还需要额外处理状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 newtype StateT s m a = StateT {runStateT :: s -\u003e m (a, s)} instance Functor m =\u003e Functor (StateT s m) where fmap f (StateT sma) = StateT $ fmap (\\(a, s1) -\u003e (f a, s1)) . sma -- http://stackoverflow.com/questions/18673525/ instance Monad m =\u003e Applicative (StateT s m) where pure x = StateT $ \\s -\u003e return (x, s) StateT smab \u003c*\u003e StateT sma = StateT $ \\s -\u003e do (fab, s1) \u003c- smab s (a, s2) \u003c- sma s1 return (fab a, s2) instance Monad m =\u003e Monad (StateT s m) where StateT sma \u003e\u003e= f = StateT $ \\s -\u003e do (a, s1) \u003c- sma s runStateT (f a) s1 WriterT和ListT 关于WriterT, 由于State总是能够代替Writer(State既能读又能写), 因此我们并不总是需要Writer. 实际上还有一个RWST将Reader, Writer, State结合起来的更大的类型.\n1 newtype RWST r w s m a = RWST {runRWST :: r -\u003e s -\u003e m (a, s, w)} It’s a bit too easy to get into a situation where Writer is either too lazy or too strict for the problem you’re solving, and then it’ll use more memory than you’d like. Writer can accumulate unevaluated thunks, causing memory leaks. It’s also inappropriate for logging long-running or ongoing programs due to the fact that you can’t retrieve any of the logged values until the computation is complete.\nListT也并不是总需要的, 其实现并不是很快. 而且Streaming库中的pipes和conduit总是能够很好的胜任大部分情况.\n对于任何一个transformer, 我们总是能够从中恢复对应的monad类型, 只需要传入一个Identity类型,例如type Maybe a = MaybeT Indentity a\nLifting 1 2 3 fmap :: Functor f =\u003e (a -\u003e b) -\u003e f a -\u003e f b liftA :: Applicative f =\u003e (a -\u003e b) -\u003e f a -\u003e f b liftM :: Monad m =\u003e (a -\u003e b) -\u003e m a -\u003e m b Monad transformer也同样有lift, 其将一个monadic计算放到一个combined monad中.\n1 2 3 4 5 class MonadTrans t where lift :: (Monad m) =\u003e m a -\u003e t m a class (Monad m) =\u003e MonadIO m where liftIO :: IO a -\u003e m a ","wordCount":"2283","inLanguage":"en","datePublished":"2019-04-06T20:26:43Z","dateModified":"2019-04-06T20:26:43Z","author":{"@type":"Person","name":"Christophe"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://www.sdlinks.net/posts/2019/monad-and-transformers/"},"publisher":{"@type":"Organization","name":"CastOff","logo":{"@type":"ImageObject","url":"http://www.sdlinks.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://www.sdlinks.net/ accesskey=h title="CastOff (Alt + H)">CastOff</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://www.sdlinks.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://www.sdlinks.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://www.sdlinks.net/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Monad and Transformers</h1><div class=post-meta><span title='2019-04-06 20:26:43 +0000 UTC'>April 6, 2019</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Christophe</div></header><div class=post-content><p>Monad是Haskell中讨论最多的结构, 需要更详细的探讨其相关内容, 即使它对于Haskell而言不是必须的:(.</p><p>参考: <a href=https://wiki.haskell.org/All_About_Monads>All about Monads</a></p><h2 id=monad-support>Monad Support<a hidden class=anchor aria-hidden=true href=#monad-support>#</a></h2><p>除了之前介绍过的一些基本函数, Haskell本身定义了一些辅助函数配合Monad一起使用:</p><ul><li><p><code>sequence</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=c1>-- 任意一个fail会导致整个fail</span>
</span></span><span class=line><span class=cl><span class=nf>sequence</span> <span class=ow>::</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=p>[</span><span class=n>m</span> <span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>sequence</span> <span class=ow>=</span> <span class=n>foldr</span> <span class=n>mcons</span> <span class=p>(</span><span class=n>return</span> <span class=kt>[]</span><span class=p>)</span>
</span></span><span class=line><span class=cl>						<span class=kr>where</span> <span class=n>mcons</span> <span class=n>p</span> <span class=n>q</span> <span class=ow>=</span> <span class=n>p</span> <span class=o>&gt;&gt;=</span> <span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=n>q</span> <span class=o>&gt;&gt;=</span> <span class=nf>\</span><span class=n>y</span> <span class=ow>-&gt;</span> <span class=n>return</span> <span class=p>(</span><span class=n>x</span> <span class=kt>:</span> <span class=n>y</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>sequence_</code>和<code>sequence</code>类似但其不返回值, 在只关心序列的副作用时其非常有用.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>sequence_</span> <span class=ow>::</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=p>[</span><span class=n>m</span> <span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=nb>()</span>
</span></span><span class=line><span class=cl><span class=nf>sequence_</span> <span class=ow>=</span> <span class=n>flodr</span> <span class=p>(</span><span class=o>&gt;&gt;</span><span class=p>)</span> <span class=p>(</span><span class=n>return</span> <span class=nb>()</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>mapM</code>其由<code>sequence</code>和<code>map</code>定义</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>mapM</span> <span class=ow>::</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>[</span><span class=n>b</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>mapM</span> <span class=n>f</span> <span class=n>as</span> <span class=ow>=</span> <span class=n>sequence</span> <span class=o>$</span> <span class=n>map</span> <span class=n>f</span> <span class=n>as</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>mapM_</code>, 类似的使用<code>sequence_</code>定义</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>mapM_</span> <span class=ow>::</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=nb>()</span>
</span></span><span class=line><span class=cl><span class=nf>mapM_</span> <span class=n>f</span> <span class=n>as</span> <span class=ow>=</span> <span class=n>sequence_</span> <span class=o>$</span> <span class=n>map</span> <span class=n>f</span> <span class=n>as</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>=&lt;&lt;</code>是<code>>>=</code>调换参数位置的版本</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=p>(</span><span class=o>=&lt;&lt;</span><span class=p>)</span> <span class=ow>::</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=nf>f</span> <span class=o>=&lt;&lt;</span> <span class=n>x</span> <span class=ow>=</span> <span class=n>x</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p>上面提到的函数都是standard prelude中定义的, Haskell在Control.Monad模块中定义了更多函数.</p><p>下面是一些列表函数的Monad版本:</p><ul><li><p><code>foldM</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>foldM</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>b</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=nf>foldM</span> <span class=n>f</span> <span class=n>a</span> <span class=kt>[]</span> <span class=ow>=</span> <span class=n>return</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=nf>foldM</span> <span class=n>f</span> <span class=n>a</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=n>f</span> <span class=n>a</span> <span class=n>x</span> <span class=o>&gt;&gt;=</span> <span class=nf>\</span><span class=n>y</span> <span class=ow>-&gt;</span> <span class=n>foldM</span> <span class=n>f</span> <span class=n>y</span> <span class=n>xs</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>filterM</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>filterM</span> <span class=ow>::</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=kt>Bool</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>filterM</span> <span class=n>p</span> <span class=kt>[]</span> <span class=ow>=</span> <span class=n>return</span> <span class=kt>[]</span>
</span></span><span class=line><span class=cl><span class=nf>filterM</span> <span class=n>p</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=kr>do</span> <span class=n>b</span>  <span class=ow>&lt;-</span> <span class=n>p</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>										 <span class=n>ys</span> <span class=ow>&lt;-</span> <span class=n>filterM</span> <span class=n>p</span> <span class=n>xs</span>
</span></span><span class=line><span class=cl>                      <span class=n>return</span> <span class=p>(</span><span class=kr>if</span> <span class=n>b</span> <span class=kr>then</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>ys</span><span class=p>)</span> <span class=kr>else</span> <span class=n>ys</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>zipWithM</code>和<code>zipWithM_</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>zipWithM</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>c</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>b</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>[</span><span class=n>c</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>zipWithM</span> <span class=n>f</span> <span class=n>xs</span> <span class=n>ys</span> <span class=ow>=</span> <span class=n>sequence</span> <span class=p>(</span><span class=n>zipWith</span> <span class=n>f</span> <span class=n>xs</span> <span class=n>ys</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>zipWithM_</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>c</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>b</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=nb>()</span>
</span></span><span class=line><span class=cl><span class=nf>zipWithM_</span> <span class=n>f</span> <span class=n>xs</span> <span class=n>ys</span> <span class=ow>=</span> <span class=n>sequence_</span> <span class=p>(</span><span class=n>zipWith</span> <span class=n>f</span> <span class=n>xs</span> <span class=n>ys</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p>Monad模块中还包含了一些流程控制函数, <code>when</code>和<code>unless</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>when</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Bool</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=nb>()</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=nb>()</span>
</span></span><span class=line><span class=cl><span class=nf>when</span> <span class=n>p</span> <span class=n>s</span> <span class=ow>=</span> <span class=kr>if</span> <span class=n>p</span> <span class=kr>then</span> <span class=n>s</span> <span class=kr>else</span> <span class=n>return</span> <span class=nb>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>unless</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Bool</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=nb>()</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=nb>()</span>
</span></span><span class=line><span class=cl><span class=nf>unless</span> <span class=n>p</span> <span class=n>s</span> <span class=ow>=</span> <span class=n>when</span> <span class=p>(</span><span class=n>not</span> <span class=n>p</span><span class=p>)</span> <span class=n>s</span>
</span></span></code></pre></td></tr></table></div></div><p>_Lifting_将一个non-monadic函数转换为在Monad上操作的等价函数. 最简单的lift函数是<code>liftM</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>liftM</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>liftM</span> <span class=n>f</span> <span class=ow>=</span> <span class=nf>\</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=kr>do</span> <span class=p>{</span><span class=n>a&#39;</span> <span class=ow>&lt;-</span> <span class=n>a</span><span class=p>;</span> <span class=n>return</span> <span class=p>(</span><span class=n>f</span> <span class=n>a&#39;</span><span class=p>)}</span>
</span></span></code></pre></td></tr></table></div></div><p>Control.Monad模块中定义了<code>liftM</code>, <code>liftM2</code>到<code>liftM5</code>分别将不同参数个数的函数lift成monadic. 另外还定义了<code>$</code>的monadic版本:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>ap</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=n>m</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=nf>ap</span> <span class=ow>=</span> <span class=n>liftM2</span> <span class=p>(</span><span class=o>$</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=monads>Monads<a hidden class=anchor aria-hidden=true href=#monads>#</a></h2><h3 id=the-identity-monad>The Identity Monad<a hidden class=anchor aria-hidden=true href=#the-identity-monad>#</a></h3><p>Identity Monad(Data.Functor.Identity)不包含任何计算:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>Identity</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=p>{</span><span class=n>runIdentity</span> <span class=ow>::</span> <span class=n>a</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=kt>Identity</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>return</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=kt>Identity</span> <span class=n>x</span><span class=p>)</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>f</span> <span class=n>x</span>
</span></span></code></pre></td></tr></table></div></div><p>Identity Monad是Monad转换的基石, 任意一个Monad transformer作用在Identity Monad上返回一个非转换器版本的Monad.</p><h3 id=the-maybe-monad>The Maybe Monad<a hidden class=anchor aria-hidden=true href=#the-maybe-monad>#</a></h3><p>Maybe Monad表示有可能不返回值(<code>Nothing</code>)的计算:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>data</span> <span class=kt>Maybe</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Nothing</span> <span class=o>|</span> <span class=kt>Just</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=kt>Maybe</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>return</span> <span class=ow>=</span> <span class=kt>Just</span>
</span></span><span class=line><span class=cl>  <span class=n>fail</span> <span class=ow>=</span> <span class=kt>Nothing</span>
</span></span><span class=line><span class=cl>  <span class=kt>Nothing</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>Nothing</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=kt>Just</span> <span class=n>x</span><span class=p>)</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>f</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>MonadPlus</span> <span class=kt>Maybe</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>mzero</span> <span class=ow>=</span> <span class=kt>Nothing</span>
</span></span><span class=line><span class=cl>  <span class=kt>Nothing</span> <span class=p>`</span><span class=n>mplus</span><span class=p>`</span> <span class=n>x</span> <span class=ow>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span> <span class=p>`</span><span class=n>mplus</span><span class=p>`</span> <span class=kr>_</span> <span class=ow>=</span> <span class=n>x</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=the-error-monad>The Error Monad<a hidden class=anchor aria-hidden=true href=#the-error-monad>#</a></h3><p>Error Monad(或Exception Monad)表示可能出错或抛出异常的计算, 例如Either Monad. Haskell中的<code>MonadError</code>是由错误的类型和相应Monad构造器参数化的:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>class</span> <span class=kt>Error</span> <span class=n>a</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>noMsg</span> <span class=ow>::</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=n>strMsg</span> <span class=ow>::</span> <span class=kt>String</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>MonadError</span> <span class=n>e</span> <span class=n>m</span> <span class=o>|</span> <span class=n>m</span> <span class=ow>-&gt;</span> <span class=n>e</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>throwError</span> <span class=ow>::</span> <span class=n>e</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=n>catchError</span> <span class=ow>::</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>e</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span>
</span></span></code></pre></td></tr></table></div></div><p><code>catchError</code>一种常见的使用是<code>do {action1; action2; action3} `catchError` handler </code>, 其中action可以调用<code>throwError</code>, 且<code>handler</code>和do-block必须有相同的返回类型. <code>Either e</code>则实例化了<code>MonadError</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>MonadError</span> <span class=p>(</span><span class=kt>Either</span> <span class=n>e</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>throwError</span> <span class=ow>=</span> <span class=kt>Left</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=kt>Left</span> <span class=n>e</span><span class=p>)</span> <span class=p>`</span><span class=n>catchError</span><span class=p>`</span> <span class=n>handler</span> <span class=ow>=</span> <span class=n>handler</span> <span class=n>e</span>
</span></span><span class=line><span class=cl>  <span class=n>a</span> <span class=p>`</span><span class=n>catchError</span><span class=p>`</span> <span class=kr>_</span> <span class=ow>=</span> <span class=n>a</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=the-list-monad>The List Monad<a hidden class=anchor aria-hidden=true href=#the-list-monad>#</a></h3><p>List monad表示可能返回0, 1, 或多个值的计算:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>data</span> <span class=kt>[]</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>[]</span> <span class=o>|</span> <span class=n>a</span> <span class=kt>:</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=kt>[]</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>m</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>concatMap</span> <span class=n>f</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>  <span class=n>return</span> <span class=n>x</span> <span class=ow>=</span> <span class=p>[</span><span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=n>fail</span> <span class=n>s</span> <span class=ow>=</span> <span class=kt>[]</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> <span class=kr>instance</span> <span class=kt>MonadPlus</span> <span class=kt>[]</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>   <span class=n>mzero</span> <span class=ow>=</span> <span class=kt>[]</span>
</span></span><span class=line><span class=cl>   <span class=n>mplus</span> <span class=ow>=</span> <span class=p>(</span><span class=o>++</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=the-io-monad>The IO Monad<a hidden class=anchor aria-hidden=true href=#the-io-monad>#</a></h3><blockquote><p>The IO Monad is just an instance of the ST monad, where
the state is the real world.</p><p>The wonderful feature of a one-way monad is that it can support side-effects in its monadic operations but prevent them from destroying the functional properties of the non-monadic portions of the program.*</p></blockquote><p>需要注意的是, IO Monad并不是IO, 而仅仅是IO类型的Monad实例.GHC经常会为了提升性能而优化代码, 诸如调整运算顺序, 共享变量, 内联函数. IO类型的最主要工作就是禁止其中的大部分工作. 显然调整运算顺序就在IO(以及ST)中被禁止, IO操作被包含在嵌套的lambdas中以保证运算顺序的不变. 之所以需要IO Monad是因为这是一种将嵌套lambdas的噪声剥离的抽象. IO Monad是一种One-way Monad, One-way Monad意味着你无法设计一个函数在IO Monad中完成计算并返回一个没有IO Monad类型的值. IO monad的定义是平台相关的, 且没有任何构造器可以使用, 也没有任何函数能够从IO Monad中获得值.</p><h3 id=the-state-monad>The State Monad<a hidden class=anchor aria-hidden=true href=#the-state-monad>#</a></h3><p>State Monad表示带有状态的计算:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>State</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>State</span> <span class=p>{</span><span class=n>runState</span> <span class=ow>::</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>s</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=p>(</span><span class=kt>State</span> <span class=n>s</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>return</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>State</span> <span class=o>$</span> <span class=nf>\</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=kt>State</span> <span class=n>x</span><span class=p>)</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>State</span> <span class=o>$</span> <span class=nf>\</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=kr>let</span> <span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>s&#39;</span><span class=p>)</span> <span class=ow>=</span> <span class=n>x</span> <span class=n>s</span> <span class=kr>in</span> <span class=n>runState</span> <span class=p>(</span><span class=n>f</span> <span class=n>v</span><span class=p>)</span> <span class=n>s&#39;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=c1>-- 提供了State Monad的一些接口</span>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=kt>MonadState</span> <span class=n>m</span> <span class=n>s</span> <span class=o>|</span> <span class=n>m</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>get</span> <span class=ow>::</span> <span class=n>m</span> <span class=n>s</span>
</span></span><span class=line><span class=cl>  <span class=n>put</span> <span class=ow>::</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=nb>()</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>MonadState</span> <span class=p>(</span><span class=kt>State</span> <span class=n>s</span><span class=p>)</span> <span class=n>s</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>get</span> <span class=ow>=</span> <span class=kt>State</span> <span class=o>$</span> <span class=nf>\</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>s</span><span class=p>)</span>  <span class=c1>-- 通过将值设置为状态来获取状态</span>
</span></span><span class=line><span class=cl>  <span class=n>put</span> <span class=n>s</span> <span class=ow>=</span> <span class=kt>State</span> <span class=o>$</span> <span class=nf>\</span><span class=kr>_</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=nb>()</span><span class=p>,</span> <span class=n>s</span><span class=p>)</span>  <span class=c1>-- 设置状态且没有值</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=the-reader-monad>The Reader Monad<a hidden class=anchor aria-hidden=true href=#the-reader-monad>#</a></h3><p>Reader Monad表示从共享环境中读取值的计算:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=c1>-- Monad instance of `(-&gt;) r`</span>
</span></span><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>Reader</span> <span class=n>e</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Reader</span> <span class=p>{</span><span class=n>runReader</span> <span class=ow>::</span> <span class=p>(</span><span class=n>e</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=p>(</span><span class=kt>Reader</span> <span class=n>e</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>return</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Reader</span> <span class=o>$</span> <span class=nf>\</span><span class=n>e</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=kt>Reader</span> <span class=n>r</span><span class=p>)</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>Reader</span> <span class=o>$</span> <span class=nf>\</span><span class=n>e</span> <span class=ow>-&gt;</span> <span class=n>runReader</span> <span class=p>(</span><span class=n>f</span> <span class=o>$</span> <span class=n>r</span> <span class=n>e</span><span class=p>)</span> <span class=n>e</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=kt>MonadReader</span> <span class=n>e</span> <span class=n>m</span> <span class=o>|</span> <span class=n>m</span> <span class=ow>-&gt;</span> <span class=n>e</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>ask</span> <span class=ow>::</span> <span class=n>m</span> <span class=n>e</span>
</span></span><span class=line><span class=cl>  <span class=n>local</span> <span class=ow>::</span> <span class=p>(</span><span class=n>e</span> <span class=ow>-&gt;</span> <span class=n>e</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>MonadReader</span> <span class=p>(</span><span class=kt>Reader</span> <span class=n>e</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>ask</span> <span class=ow>=</span> <span class=kt>Reader</span> <span class=n>id</span>
</span></span><span class=line><span class=cl>  <span class=n>local</span> <span class=n>f</span> <span class=n>c</span> <span class=ow>=</span> <span class=kt>Reader</span> <span class=o>$</span> <span class=nf>\</span><span class=n>e</span> <span class=ow>-&gt;</span> <span class=n>runReader</span> <span class=n>c</span> <span class=p>(</span><span class=n>f</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=nf>asks</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>MonadReader</span> <span class=n>e</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>e</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span>
</span></span><span class=line><span class=cl><span class=nf>asks</span> <span class=n>sel</span> <span class=ow>=</span> <span class=n>ask</span> <span class=o>&gt;&gt;=</span> <span class=n>return</span> <span class=o>.</span> <span class=n>sel</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=the-writer-monad>The Writer Monad<a hidden class=anchor aria-hidden=true href=#the-writer-monad>#</a></h3><p>Write Monad表示除了计算值以外还产生数据流的计算:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>Writer</span> <span class=n>w</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Writer</span> <span class=p>{</span> <span class=n>runWriter</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>w</span><span class=p>)</span> <span class=p>}</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=p>(</span><span class=kt>Monoid</span> <span class=n>w</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Monad</span> <span class=p>(</span><span class=kt>Writer</span> <span class=n>w</span><span class=p>)</span> <span class=kr>where</span> 
</span></span><span class=line><span class=cl>    <span class=n>return</span> <span class=n>a</span>             <span class=ow>=</span> <span class=kt>Writer</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>mempty</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=kt>Writer</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>w</span><span class=p>))</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=kr>let</span> <span class=p>(</span><span class=n>a&#39;</span><span class=p>,</span><span class=n>w&#39;</span><span class=p>)</span> <span class=ow>=</span> <span class=n>runWriter</span> <span class=o>$</span> <span class=n>f</span> <span class=n>a</span> <span class=kr>in</span> <span class=kt>Writer</span> <span class=p>(</span><span class=n>a&#39;</span><span class=p>,</span><span class=n>w</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>w&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=p>(</span><span class=kt>Monoid</span> <span class=n>w</span><span class=p>,</span> <span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>MonadWriter</span> <span class=n>w</span> <span class=n>m</span> <span class=o>|</span> <span class=n>m</span> <span class=ow>-&gt;</span> <span class=n>w</span> <span class=kr>where</span> 
</span></span><span class=line><span class=cl>    <span class=n>pass</span>   <span class=ow>::</span> <span class=n>m</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>w</span> <span class=ow>-&gt;</span> <span class=n>w</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span> 
</span></span><span class=line><span class=cl>    <span class=n>listen</span> <span class=ow>::</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>w</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=n>tell</span>   <span class=ow>::</span> <span class=n>w</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=nb>()</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=p>(</span><span class=kt>Monoid</span> <span class=n>w</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>MonadWriter</span> <span class=n>w</span> <span class=p>(</span><span class=kt>Writer</span> <span class=n>w</span><span class=p>)</span> <span class=kr>where</span> 
</span></span><span class=line><span class=cl>    <span class=n>pass</span>   <span class=p>(</span><span class=kt>Writer</span> <span class=p>((</span><span class=n>a</span><span class=p>,</span><span class=n>f</span><span class=p>),</span><span class=n>w</span><span class=p>))</span> <span class=ow>=</span> <span class=kt>Writer</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>f</span> <span class=n>w</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=n>listen</span> <span class=p>(</span><span class=kt>Writer</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>w</span><span class=p>))</span>     <span class=ow>=</span> <span class=kt>Writer</span> <span class=p>((</span><span class=n>a</span><span class=p>,</span><span class=n>w</span><span class=p>),</span><span class=n>w</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=n>tell</span>   <span class=n>s</span>                  <span class=ow>=</span> <span class=kt>Writer</span> <span class=p>(</span><span class=nb>()</span><span class=p>,</span><span class=n>s</span><span class=p>)</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=nf>listens</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>MonadWriter</span> <span class=n>w</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>w</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>listens</span> <span class=n>f</span> <span class=n>m</span> <span class=ow>=</span> <span class=kr>do</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>w</span><span class=p>)</span> <span class=ow>&lt;-</span> <span class=n>listen</span> <span class=n>m</span><span class=p>;</span> <span class=n>return</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>f</span> <span class=n>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=nf>censor</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>MonadWriter</span> <span class=n>w</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>w</span> <span class=ow>-&gt;</span> <span class=n>w</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span> 
</span></span><span class=line><span class=cl><span class=nf>censor</span> <span class=n>f</span> <span class=n>m</span> <span class=ow>=</span> <span class=n>pass</span> <span class=o>$</span> <span class=kr>do</span> <span class=n>a</span> <span class=ow>&lt;-</span> <span class=n>m</span><span class=p>;</span> <span class=n>return</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>f</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=the-continuation-monad>The Continuation monad<a hidden class=anchor aria-hidden=true href=#the-continuation-monad>#</a></h3><p>Continuation Monad表示可以被打断和恢复的计算(没错, 就是continuation):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=c1>-- r is the final result type of the whole computation</span>
</span></span><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>Cont</span> <span class=n>r</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Cont</span> <span class=p>{</span> <span class=n>runCont</span> <span class=ow>::</span> <span class=p>((</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>r</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>r</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=p>(</span><span class=kt>Cont</span> <span class=n>r</span><span class=p>)</span> <span class=kr>where</span> 
</span></span><span class=line><span class=cl>    <span class=n>return</span> <span class=n>a</span>       <span class=ow>=</span> <span class=kt>Cont</span> <span class=o>$</span> <span class=nf>\</span><span class=n>k</span> <span class=ow>-&gt;</span> <span class=n>k</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=kt>Cont</span> <span class=n>c</span><span class=p>)</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>Cont</span> <span class=o>$</span> <span class=nf>\</span><span class=n>k</span> <span class=ow>-&gt;</span> <span class=n>c</span> <span class=p>(</span><span class=nf>\</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>runCont</span> <span class=p>(</span><span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>MonadCont</span> <span class=n>m</span> <span class=kr>where</span> 
</span></span><span class=line><span class=cl>    <span class=n>callCC</span> <span class=ow>::</span> <span class=p>((</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>MonadCont</span> <span class=p>(</span><span class=kt>Cont</span> <span class=n>r</span><span class=p>)</span> <span class=kr>where</span> 
</span></span><span class=line><span class=cl>    <span class=n>callCC</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>Cont</span> <span class=o>$</span> <span class=nf>\</span><span class=n>k</span> <span class=ow>-&gt;</span> <span class=n>runCont</span> <span class=p>(</span><span class=n>f</span> <span class=p>(</span><span class=nf>\</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Cont</span> <span class=o>$</span> <span class=nf>\</span><span class=kr>_</span> <span class=ow>-&gt;</span> <span class=n>k</span> <span class=n>a</span><span class=p>))</span> <span class=n>k</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=combining-monads>Combining monads<a hidden class=anchor aria-hidden=true href=#combining-monads>#</a></h2><p>Functors和applicatives对于composition都是封闭的, 但两个monad结合却不一定是另一个monad. 一个monad transformer是一个接受monad作为monad作为参数的类型构造器, 类似与一个wrapper(因此很多都是用newtype定义的).</p><h3 id=compose>Compose<a hidden class=anchor aria-hidden=true href=#compose>#</a></h3><p>Compose类型代表着函数结合:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Compose</span> <span class=p>{</span><span class=n>getCompose</span> <span class=ow>::</span> <span class=n>f</span> <span class=p>(</span><span class=n>g</span> <span class=n>a</span><span class=p>)}</span> <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Eq</span><span class=p>,</span> <span class=kt>Show</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这里的f, g不在是普遍意义上的函数, 而是类型构造器. 我们很容易实现Compose的Functor实例:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>instance</span> <span class=p>(</span><span class=kt>Functor</span> <span class=n>f</span><span class=p>,</span> <span class=kt>Functor</span> <span class=n>g</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Functor</span> <span class=p>(</span><span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Compose</span> <span class=n>fga</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Compose</span> <span class=o>$</span> <span class=p>(</span><span class=n>fmap</span> <span class=o>.</span> <span class=n>fmap</span><span class=p>)</span> <span class=n>f</span> <span class=n>fga</span>
</span></span></code></pre></td></tr></table></div></div><p>容易看到两个Functor结合之后依然可以是一个Functor. 同样的, 我们也可以定义Applicative实例:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>instance</span> <span class=p>(</span><span class=kt>Applicative</span> <span class=n>f</span><span class=p>,</span> <span class=kt>Applicative</span> <span class=n>g</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Applicative</span> <span class=p>(</span><span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>	<span class=n>pure</span> <span class=ow>=</span> <span class=kt>Compose</span> <span class=o>.</span> <span class=n>pure</span> <span class=o>.</span> <span class=n>pure</span>
</span></span><span class=line><span class=cl>	<span class=kt>Compose</span> <span class=n>fgf</span> <span class=o>&lt;*&gt;</span> <span class=kt>Compose</span> <span class=n>fga</span> <span class=ow>=</span> <span class=kt>Compose</span> <span class=o>$</span> <span class=p>(</span><span class=o>&lt;*&gt;</span><span class=p>)</span> <span class=o>&lt;$&gt;</span> <span class=n>fgf</span> <span class=o>&lt;*&gt;</span> <span class=n>fga</span>
</span></span></code></pre></td></tr></table></div></div><p>如果我们要定义Compose的Monad实例, 就需要实现<code>(>>=)</code>或:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=p>(</span><span class=o>&gt;&gt;=</span><span class=p>)</span> <span class=ow>::</span> <span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=c1>-- 或者通过join来实现&gt;&gt;=</span>
</span></span><span class=line><span class=cl><span class=nf>join</span> <span class=ow>::</span> <span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span> <span class=p>(</span><span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span> <span class=n>a</span> 
</span></span></code></pre></td></tr></table></div></div><p>我们总是可以忽略掉外层的Compose, 此时对于join而言, 我们就得打了<code>f g (f g a) -> f g a</code>, 如果存在一个函数<code>aux :: (Monad f, Monad g) => f (g a) -> g (f a)</code>, 那么我们就可以从<code>f g (f g a)</code>中获得<code>f g a</code>, 因为对于f和g而言都有各自的<code>join</code>, 使得 <code>f (f a) -> f a</code>. 然而并不是对于每个monad都存在这样的<code>aux</code>, 例如<code>IO (Maybe a) -> Maybe (IO a)</code>就不存在这样的<code>aux</code>. 因而"Monad do not compose", 此时我们就需要monad transformer.</p><h3 id=identityt>IdentityT<a hidden class=anchor aria-hidden=true href=#identityt>#</a></h3><p>我们已经看到对于任意的两个monad的compose, <code>join</code>并不总是可以的. 因此我们需要限制其中一个monad, 希望它对于另外一个任意的monad的compose总是可行的. 我们从IdentityT开始介绍monad transformer:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>Identity</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=p>{</span><span class=n>runIdentity</span> <span class=ow>::</span> <span class=n>a</span><span class=p>}</span> <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Eq</span><span class=p>,</span> <span class=kt>Show</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Functor</span> <span class=kt>Identity</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Identity</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=o>$</span> <span class=n>f</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Applicative</span> <span class=kt>Identity</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>pure</span> <span class=ow>=</span> <span class=kt>Identity</span>
</span></span><span class=line><span class=cl>  <span class=kt>Identity</span> <span class=n>f</span> <span class=o>&lt;*&gt;</span> <span class=kt>Identity</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=o>$</span> <span class=n>f</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=kt>Identity</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=kt>Identity</span> <span class=n>a</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>f</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>IdentityT</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>IdentityT</span> <span class=p>{</span><span class=n>runIdentityT</span> <span class=ow>::</span> <span class=n>m</span> <span class=n>a</span><span class=p>}</span> <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Eq</span><span class=p>,</span> <span class=kt>Show</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Functor</span> <span class=p>(</span><span class=kt>IdentityT</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>IdentityT</span> <span class=n>ma</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>IdentityT</span> <span class=o>$</span> <span class=n>fmap</span> <span class=n>f</span> <span class=n>ma</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Applicative</span> <span class=p>(</span><span class=kt>IdentityT</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>	<span class=n>pure</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>IdentityT</span> <span class=o>$</span> <span class=n>pure</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>	<span class=kt>IdentityT</span> <span class=n>mab</span> <span class=o>&lt;*&gt;</span> <span class=kt>IdentityT</span> <span class=n>ma</span> <span class=ow>=</span> <span class=kt>IdentityT</span> <span class=o>$</span> <span class=n>mab</span> <span class=o>&lt;*&gt;</span> <span class=n>fa</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=p>(</span><span class=kt>IdentityT</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>	<span class=kt>IdentityT</span> <span class=n>ma</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>IdentityT</span> <span class=o>$</span> <span class=n>ma</span> <span class=o>&gt;&gt;=</span> <span class=n>runIdentityT</span> <span class=o>.</span> <span class=n>f</span>
</span></span></code></pre></td></tr></table></div></div><p>在这里我们限制了其中一个monad为Identity, 此时可以实现Monad实例, 因为我们有<code>runIdentityT</code>来获取额外的信息. 更一般的, 对于两个有Monad实例的类型f, g, 组合它们最终会止步与<code>f(g (f b))</code>, 而transformer的作用就是限制了g, 使得能够得到<code>f (f b)</code>.</p><h3 id=maybet>MaybeT<a hidden class=anchor aria-hidden=true href=#maybet>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>MaybeT</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>MaybeT</span> <span class=p>{</span><span class=n>runMaybeT</span> <span class=ow>::</span> <span class=n>m</span> <span class=p>(</span><span class=kt>Maybe</span> <span class=n>a</span><span class=p>)}</span>
</span></span></code></pre></td></tr></table></div></div><p>Functor实例和Applicative实例都可以直接从之前的Compose拿过来</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>instance</span> <span class=p>(</span><span class=kt>Functor</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Functor</span> <span class=p>(</span><span class=kt>MaybeT</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Maybe</span> <span class=n>ma</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>MaybeT</span> <span class=o>$</span> <span class=p>(</span><span class=n>fmap</span> <span class=o>.</span> <span class=n>fmap</span><span class=p>)</span> <span class=n>f</span> <span class=n>ma</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=p>(</span><span class=kt>Applicative</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Applicative</span> <span class=p>(</span><span class=kt>MaybeT</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>	<span class=n>pure</span> <span class=ow>=</span> <span class=kt>MaybeT</span> <span class=o>.</span> <span class=n>pure</span> <span class=o>.</span> <span class=n>pure</span>
</span></span><span class=line><span class=cl>	<span class=kt>MaybeT</span> <span class=n>fab</span> <span class=o>&lt;*&gt;</span> <span class=kt>MaybeT</span> <span class=n>mma</span> <span class=ow>=</span> <span class=kt>MaybeT</span> <span class=o>$</span> <span class=p>(</span><span class=o>&lt;*&gt;</span><span class=p>)</span> <span class=o>&lt;$&gt;</span> <span class=n>fab</span> <span class=o>&lt;*&gt;</span> <span class=n>mma</span>
</span></span></code></pre></td></tr></table></div></div><p>终于到了Monad实例:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>instance</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Monad</span> <span class=p>(</span><span class=kt>MaybeT</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>	<span class=p>(</span><span class=kt>MaybeT</span> <span class=n>ma</span><span class=p>)</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>MaybeT</span> <span class=o>$</span> <span class=kr>do</span>
</span></span><span class=line><span class=cl>		<span class=n>v</span> <span class=ow>&lt;-</span> <span class=n>ma</span>
</span></span><span class=line><span class=cl>		<span class=kr>case</span> <span class=n>v</span> <span class=kr>of</span>
</span></span><span class=line><span class=cl>			<span class=kt>Nothing</span> <span class=ow>-&gt;</span> <span class=n>return</span> <span class=kt>Nothing</span>
</span></span><span class=line><span class=cl>			<span class=kt>Just</span> <span class=n>y</span> <span class=ow>-&gt;</span> <span class=n>runMaybeT</span> <span class=p>(</span><span class=n>f</span> <span class=n>y</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=eithert>EitherT<a hidden class=anchor aria-hidden=true href=#eithert>#</a></h3><p>EitherT和MaybeT的处理是类似的.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>EitherT</span> <span class=n>e</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>EitherT</span> <span class=p>{</span><span class=n>runEitherT</span> <span class=ow>::</span> <span class=n>m</span> <span class=p>(</span><span class=kt>Either</span> <span class=n>e</span> <span class=n>a</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Functor</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=kt>Functor</span> <span class=p>(</span><span class=kt>EitherT</span> <span class=n>e</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>EitherT</span> <span class=n>ema</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>EitherT</span> <span class=o>$</span> <span class=p>(</span><span class=n>fmap</span> <span class=o>.</span> <span class=n>fmap</span><span class=p>)</span> <span class=n>f</span> <span class=n>ema</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Applicative</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=kt>Applicative</span> <span class=p>(</span><span class=kt>EitherT</span> <span class=n>e</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>pure</span> <span class=ow>=</span> <span class=kt>EitherT</span> <span class=o>.</span> <span class=n>pure</span> <span class=o>.</span> <span class=n>pure</span>
</span></span><span class=line><span class=cl>  <span class=kt>EitherT</span> <span class=n>emab</span> <span class=o>&lt;*&gt;</span> <span class=kt>EitherT</span> <span class=n>ema</span> <span class=ow>=</span> <span class=kt>EitherT</span> <span class=o>$</span> <span class=p>(</span><span class=o>&lt;*&gt;</span><span class=p>)</span> <span class=o>&lt;$&gt;</span> <span class=n>emab</span> <span class=o>&lt;*&gt;</span> <span class=n>ema</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=kt>Monad</span> <span class=p>(</span><span class=kt>EitherT</span> <span class=n>e</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=kt>EitherT</span> <span class=n>ema</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>EitherT</span> <span class=o>$</span> <span class=kr>do</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span> <span class=ow>&lt;-</span> <span class=n>ema</span>
</span></span><span class=line><span class=cl>    <span class=kr>case</span> <span class=n>v</span> <span class=kr>of</span>
</span></span><span class=line><span class=cl>      <span class=kt>Right</span> <span class=n>y</span> <span class=ow>-&gt;</span> <span class=n>runEitherT</span> <span class=o>$</span> <span class=n>f</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>      <span class=kt>Left</span> <span class=n>x</span> <span class=ow>-&gt;</span> <span class=n>return</span> <span class=o>$</span> <span class=kt>Left</span> <span class=n>x</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=readert>ReaderT<a hidden class=anchor aria-hidden=true href=#readert>#</a></h3><p>ReaderT是常规的Haskell应用中用到最多的transformer</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>ReaderT</span> <span class=n>r</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>ReaderT</span> <span class=p>{</span><span class=n>runReaderT</span> <span class=ow>::</span> <span class=n>r</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>不过其处理和MaybeT以及EitherT处理依然是类似的, 注意ReaderT的参数是一个函数.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Functor</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=kt>Functor</span> <span class=p>(</span><span class=kt>ReaderT</span> <span class=n>r</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>ReaderT</span> <span class=n>rma</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>ReaderT</span> <span class=o>$</span> <span class=p>(</span><span class=n>fmap</span> <span class=o>.</span> <span class=n>fmap</span><span class=p>)</span> <span class=n>f</span> <span class=n>rma</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Applicative</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=kt>Applicative</span> <span class=p>(</span><span class=kt>ReaderT</span> <span class=n>r</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>pure</span> <span class=ow>=</span> <span class=kt>ReaderT</span> <span class=o>.</span> <span class=n>pure</span> <span class=o>.</span> <span class=n>pure</span>
</span></span><span class=line><span class=cl>  <span class=kt>ReaderT</span> <span class=n>fmab</span> <span class=o>&lt;*&gt;</span> <span class=kt>ReaderT</span> <span class=n>rma</span> <span class=ow>=</span> <span class=kt>ReaderT</span> <span class=o>$</span> <span class=p>(</span><span class=o>&lt;*&gt;</span><span class=p>)</span> <span class=o>&lt;$&gt;</span> <span class=n>fmab</span> <span class=o>&lt;*&gt;</span> <span class=n>rma</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=kt>Monad</span> <span class=p>(</span><span class=kt>ReaderT</span> <span class=n>r</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=kt>ReaderT</span> <span class=n>rma</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>ReaderT</span> <span class=o>$</span> <span class=nf>\</span><span class=n>r</span> <span class=ow>-&gt;</span> <span class=kr>do</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=ow>&lt;-</span> <span class=n>rma</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>    <span class=n>runReaderT</span> <span class=p>(</span><span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=n>r</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=statet>StateT<a hidden class=anchor aria-hidden=true href=#statet>#</a></h3><p>StateT和ReaderT是类似的不过StateT还需要额外处理状态</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>StateT</span> <span class=n>s</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>StateT</span> <span class=p>{</span><span class=n>runStateT</span> <span class=ow>::</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>s</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Functor</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=kt>Functor</span> <span class=p>(</span><span class=kt>StateT</span> <span class=n>s</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>StateT</span> <span class=n>sma</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>StateT</span> <span class=o>$</span> <span class=n>fmap</span> <span class=p>(</span><span class=nf>\</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>s1</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>f</span> <span class=n>a</span><span class=p>,</span> <span class=n>s1</span><span class=p>))</span> <span class=o>.</span> <span class=n>sma</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>-- http://stackoverflow.com/questions/18673525/</span>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=kt>Applicative</span> <span class=p>(</span><span class=kt>StateT</span> <span class=n>s</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>pure</span> <span class=n>x</span> <span class=ow>=</span> <span class=kt>StateT</span> <span class=o>$</span> <span class=nf>\</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>return</span> <span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=kt>StateT</span> <span class=n>smab</span> <span class=o>&lt;*&gt;</span> <span class=kt>StateT</span> <span class=n>sma</span> <span class=ow>=</span> <span class=kt>StateT</span> <span class=o>$</span> <span class=nf>\</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=kr>do</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>fab</span><span class=p>,</span> <span class=n>s1</span><span class=p>)</span> <span class=ow>&lt;-</span> <span class=n>smab</span> <span class=n>s</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>s2</span><span class=p>)</span> <span class=ow>&lt;-</span> <span class=n>sma</span> <span class=n>s1</span>
</span></span><span class=line><span class=cl>    <span class=n>return</span> <span class=p>(</span><span class=n>fab</span> <span class=n>a</span><span class=p>,</span> <span class=n>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=kt>Monad</span> <span class=p>(</span><span class=kt>StateT</span> <span class=n>s</span> <span class=n>m</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=kt>StateT</span> <span class=n>sma</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>StateT</span> <span class=o>$</span> <span class=nf>\</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=kr>do</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>s1</span><span class=p>)</span> <span class=ow>&lt;-</span> <span class=n>sma</span> <span class=n>s</span>
</span></span><span class=line><span class=cl>    <span class=n>runStateT</span> <span class=p>(</span><span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=n>s1</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=writert和listt>WriterT和ListT<a hidden class=anchor aria-hidden=true href=#writert和listt>#</a></h3><p>关于WriterT, 由于State总是能够代替Writer(State既能读又能写), 因此我们并不总是需要Writer. 实际上还有一个RWST将Reader, Writer, State结合起来的更大的类型.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>newtype</span> <span class=kt>RWST</span> <span class=n>r</span> <span class=n>w</span> <span class=n>s</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>RWST</span> <span class=p>{</span><span class=n>runRWST</span> <span class=ow>::</span> <span class=n>r</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>w</span><span class=p>)}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>It’s a bit too easy to get into a situation where Writer is either too
lazy or too strict for the problem you’re solving, and then it’ll use
more memory than you’d like. Writer can accumulate unevaluated thunks, causing memory leaks. It’s also inappropriate for logging long-running or ongoing programs due to the fact that you can’t retrieve any of the logged values until the computation is complete.</p></blockquote><p>ListT也并不是总需要的, 其实现并不是很快. 而且Streaming库中的<code>pipes</code>和<code>conduit</code>总是能够很好的胜任大部分情况.</p><p>对于任何一个transformer, 我们总是能够从中恢复对应的monad类型, 只需要传入一个<code>Identity</code>类型,例如<code>type Maybe a = MaybeT Indentity a</code></p><h3 id=lifting>Lifting<a hidden class=anchor aria-hidden=true href=#lifting>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>fmap</span> <span class=ow>::</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=nf>liftA</span> <span class=ow>::</span> <span class=kt>Applicative</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=nf>liftM</span> <span class=ow>::</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span>
</span></span></code></pre></td></tr></table></div></div><p>Monad transformer也同样有lift, 其将一个monadic计算放到一个combined monad中.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>class</span> <span class=kt>MonadTrans</span> <span class=n>t</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>	<span class=n>lift</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>m</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=p>(</span><span class=kt>Monad</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>MonadIO</span> <span class=n>m</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>	<span class=n>liftIO</span> <span class=ow>::</span> <span class=kt>IO</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span>
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://www.sdlinks.net/tags/haskell/>Haskell</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Monad and Transformers on x" href="https://x.com/intent/tweet/?text=Monad%20and%20Transformers&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2019%2fmonad-and-transformers%2f&amp;hashtags=Haskell"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Monad and Transformers on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2019%2fmonad-and-transformers%2f&amp;title=Monad%20and%20Transformers&amp;summary=Monad%20and%20Transformers&amp;source=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2019%2fmonad-and-transformers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Monad and Transformers on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2019%2fmonad-and-transformers%2f&title=Monad%20and%20Transformers"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Monad and Transformers on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2019%2fmonad-and-transformers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Monad and Transformers on whatsapp" href="https://api.whatsapp.com/send?text=Monad%20and%20Transformers%20-%20http%3a%2f%2fwww.sdlinks.net%2fposts%2f2019%2fmonad-and-transformers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Monad and Transformers on telegram" href="https://telegram.me/share/url?text=Monad%20and%20Transformers&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2019%2fmonad-and-transformers%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Monad and Transformers on ycombinator" href="https://news.ycombinator.com/submitlink?t=Monad%20and%20Transformers&u=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2019%2fmonad-and-transformers%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=Christophe1997/blog data-repo-id="MDEwOlJlcG9zaXRvcnkyMjU4MTQyMTM=" data-category=Announcements data-category-id=DIC_kwDODXWmxc4CmuF3 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=http://www.sdlinks.net/>CastOff</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>