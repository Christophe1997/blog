<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Functional Data Structure 1 | Neo VRAINS</title><meta name=keywords content="OCaml,Functional"><meta name=description content="Introduction
To implement data structure in a functional way, there are two basic problems. First, from the point of view of designing
and implementing efficient data structures, functional programming&rsquo;s stricture against destructive updates(i.e. assignments)
is a staggering handicap, tantamount to confiscating a master chef&rsquo;s knives.
Imperative data structures often rely on
assignments in crucial ways, and so different solutions must be found for functional programs. The second difficulty is
that functional data strcutures are expected to be more flexible than their imperative counterparts. In particular, when
we update an imperative data structure we typically accept that the old version of the data strcuture will no longer
be available, but when we update a functional data structure, we expect that both the old and the new version of the data
structure will be available for further processing, this is called persistent, while the other is called ephemeral.
And we are not surprised if the persistent version is more complicated and even less efficient that the ephemeral one."><meta name=author content="Christophe"><link rel=canonical href=https://www.sdlinks.net/posts/2018/functional-data-structure-1/><meta name=google-site-verification content="Neo VRAINS"><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://www.sdlinks.net/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.sdlinks.net/images/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.sdlinks.net/images/favicon-32x32.png><link rel=apple-touch-icon href=https://www.sdlinks.net/images/apple-touch-icon.png><link rel=mask-icon href=https://www.sdlinks.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.sdlinks.net/posts/2018/functional-data-structure-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=/css/katex.min.css><script defer src=/js/katex.min.js></script><script defer src=/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RH029G1TZ5"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RH029G1TZ5")}</script><meta property="og:url" content="https://www.sdlinks.net/posts/2018/functional-data-structure-1/"><meta property="og:site_name" content="Neo VRAINS"><meta property="og:title" content="Functional Data Structure 1"><meta property="og:description" content="Introduction To implement data structure in a functional way, there are two basic problems. First, from the point of view of designing and implementing efficient data structures, functional programming’s stricture against destructive updates(i.e. assignments) is a staggering handicap, tantamount to confiscating a master chef’s knives.
Imperative data structures often rely on assignments in crucial ways, and so different solutions must be found for functional programs. The second difficulty is that functional data strcutures are expected to be more flexible than their imperative counterparts. In particular, when we update an imperative data structure we typically accept that the old version of the data strcuture will no longer be available, but when we update a functional data structure, we expect that both the old and the new version of the data structure will be available for further processing, this is called persistent, while the other is called ephemeral. And we are not surprised if the persistent version is more complicated and even less efficient that the ephemeral one."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-07-19T17:00:11+00:00"><meta property="article:modified_time" content="2018-07-19T17:00:11+00:00"><meta property="article:tag" content="OCaml"><meta property="article:tag" content="Functional"><meta name=twitter:card content="summary"><meta name=twitter:title content="Functional Data Structure 1"><meta name=twitter:description content="Introduction
To implement data structure in a functional way, there are two basic problems. First, from the point of view of designing
and implementing efficient data structures, functional programming&rsquo;s stricture against destructive updates(i.e. assignments)
is a staggering handicap, tantamount to confiscating a master chef&rsquo;s knives.
Imperative data structures often rely on
assignments in crucial ways, and so different solutions must be found for functional programs. The second difficulty is
that functional data strcutures are expected to be more flexible than their imperative counterparts. In particular, when
we update an imperative data structure we typically accept that the old version of the data strcuture will no longer
be available, but when we update a functional data structure, we expect that both the old and the new version of the data
structure will be available for further processing, this is called persistent, while the other is called ephemeral.
And we are not surprised if the persistent version is more complicated and even less efficient that the ephemeral one."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.sdlinks.net/posts/"},{"@type":"ListItem","position":2,"name":"Functional Data Structure 1","item":"https://www.sdlinks.net/posts/2018/functional-data-structure-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Functional Data Structure 1","name":"Functional Data Structure 1","description":"Introduction To implement data structure in a functional way, there are two basic problems. First, from the point of view of designing and implementing efficient data structures, functional programming\u0026rsquo;s stricture against destructive updates(i.e. assignments) is a staggering handicap, tantamount to confiscating a master chef\u0026rsquo;s knives.\nImperative data structures often rely on assignments in crucial ways, and so different solutions must be found for functional programs. The second difficulty is that functional data strcutures are expected to be more flexible than their imperative counterparts. In particular, when we update an imperative data structure we typically accept that the old version of the data strcuture will no longer be available, but when we update a functional data structure, we expect that both the old and the new version of the data structure will be available for further processing, this is called persistent, while the other is called ephemeral. And we are not surprised if the persistent version is more complicated and even less efficient that the ephemeral one.\n","keywords":["OCaml","Functional"],"articleBody":"Introduction To implement data structure in a functional way, there are two basic problems. First, from the point of view of designing and implementing efficient data structures, functional programming’s stricture against destructive updates(i.e. assignments) is a staggering handicap, tantamount to confiscating a master chef’s knives.\nImperative data structures often rely on assignments in crucial ways, and so different solutions must be found for functional programs. The second difficulty is that functional data strcutures are expected to be more flexible than their imperative counterparts. In particular, when we update an imperative data structure we typically accept that the old version of the data strcuture will no longer be available, but when we update a functional data structure, we expect that both the old and the new version of the data structure will be available for further processing, this is called persistent, while the other is called ephemeral. And we are not surprised if the persistent version is more complicated and even less efficient that the ephemeral one.\nThe term data structure has at least four distinct, but related, meanings:\nAn abstract data type, that is, a type and a collection of functions on that type, we can refer to this as an abstraction. A concrete realization of an abstract data type, we can refer to this as an implementation, but note that an implentation need not be actualized as code – a concrete design is sufficient. An instance of a data type, such as a particular list or tree. We can refer to such an instance generically as an object or a version. However, particular data types often have their own nomenclature, for example, we simply refer to stack or queue objects as stacks or queues. A unique identity that is invariant under updates. For example, in a stack-based interpreter, we often speak informally about “the stack” as if there were only one stack, rather than different versions at different times. We can refer to this identity as a persistent identity. Persistence A distinctive property of functional data structures is that they are always persistent, updating a functional data structure does not destory the existing version, but rather creates a new version that coexists with the old one. Persistence is achieved by coping the affected nodes of a data structure and making all changes in the copy of rather than in the original. Because nodes are never modified directly, all nodes that are unaffected by an update can be shared between the old and new version of the data structure without worrying that a change in one version will inadvertently be visible to the other.\nLists Linked lists are common in imperative programming and ubiquitous in functional programming. And we can define its abstraction as follow:\n1 2 3 4 5 6 7 8 9 10 11 (** userList.mli *) type 'a t val empty : 'a t val isEmpty : 'a t -\u003e bool exception Empty (* the exception does not matter *) val cons : 'a -\u003e 'a t -\u003e 'a t val head : 'a t -\u003e 'a val tail : 'a t -\u003e 'a t It can be implemented trivially using either the built-in type of lists or a custom datatype:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 (** userList.ml *) type 'a t = | Nil | Cons of 'a * ('a t) let empty = Nil exception Empty let isEmpty = function | Nil -\u003e true | _ -\u003e false let cons(hd, tl) = Cons (hd, tl) let head = function | Nil -\u003e raise Empty | Cons (hd, tl) -\u003e hd let tail = function | Nil -\u003e raise Empty | Cons (hd, tl) -\u003e tl Another common function on the lists is append(@ in ocaml), we denote it as ++, and it’s easy to implement it in a O(n) way, while we can implement in a O(1) way in an imperative setting:\n1 2 3 let rec (++) = function | Nil, ys -\u003e ys | Cons (hd, tl), ys -\u003e tl ++ Cons (hd, ys) In functional setting, we have to copy the entire list to keep the persistence so that we are free to continue using the old lists as well as the new list. Although this is undeniably a lot of copying, notice that the second list ys shares the nodes wit the new list. Another function that illustrates these twin concepts of copying and sharing is update, which changes the value of a node at a given index in the list:\n1 2 3 4 let rec update xs idx x = match (xs, idx) with | Nil, _ -\u003e raise Subscript | Cons (hd, tl), 0 -\u003e Cons (x, tl) | Cons (hd, tl), (_ as n) -\u003e Cons (hd, update tl (n - 1) x) Notice that this version of update is not tail call, so we can transform it via CPS:\n1 2 3 4 5 6 7 let rec update xs idx x = let rec updateK xs idx x k = match xs, idx with | Nil, _ -\u003e raise Subscript | Cons (hd, tl), 0 -\u003e k (Cons (x, tl)) | Cons (hd, tl), (_ as n) -\u003e updateK tl (n - 1) x (fun var1 -\u003e Cons (x, var1)) in updateK xs idx x (fun var1 -\u003e var1) so that the tail optimization can be applied.\nBinary search trees Binary search trees provide a good example of the kind of sharing the node with more than one pointer field. And a binary search tree can implement sets or finite maps, whose minimal interfaces as:\n1 2 3 4 5 6 7 8 module type Set = sig type t type elem val empty : t val insert : elem -\u003e t -\u003e t val member : elem -\u003e t -\u003e bool end module type finiteMap = sig\rtype 'a t\rtype key\rexception NotFound\rval empty : 'a t\rval bind : key -\u003e 'a -\u003e 'a t -\u003e 'a t\rval lookup : key -\u003e 'a t -\u003e 'a (* raise NotFound if key is not found *)\rend where the elem is some fixed type of totally-ordered elements. A more realistic implementation would probably include many additional functions, such as deleting an element or enumerating all elements. An unblanced set via binary search tree can be implemented as:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 open Core module UnbalancedSet(Elem : Comparable) : (Set with type elem = Elem.t) = struct type elem = Elem.t type t = | Leaf | Node of t * elem * t let empty = Leaf exception AlreadyInSet let rec insert x tree = let aux = function | Leaf -\u003e Node (Leaf, x, Leaf) | Node (left, v, right) -\u003e if Elem.compare x v \u003c 0 then Node (insert x left, v, right) else if Elem.compare x v \u003e 0 then Node (left, v, insert x right) else raise AlreadyInSet in try aux tree with AlreadyInSet -\u003e tree let rec member x tree = let rec aux candidate = function | Leaf -\u003e match candidate with | None -\u003e false | Some v -\u003e Elem.compare x v = 0 | Node (left, v, right) -\u003e if Elem.compare x v \u003c 0 then memberHelp candidate left else member (Some v) right in aux None tree end where the Comparable is:\nmodule type Comparable = sig\rtype t\rval compare : t -\u003e t -\u003e int\rend Notice that in the member function, we defined a auxiliary function that take a candidate that less than or equal to the search value such that it take no more than d + 1 comparisons, where d is the depth of the tree, while in a traditional way, we need 2d comparisons in the worst case. And in the insert function, we introduce a AlreadyInSet exception so that it return the tree itself while inserting an existing value to the tree to avoid the extra copying in the situation.\nTo sum up, we keep the persistence via sharing and copying.\nSome Familiar Data Structures in A Functional Setting Although many imperative data structures are difficult or impossible to adapt to a functional setting, some can be adapted quite easily.\nLeftist heaps Sometimes we need efficient access only to the minimum element, a data structure supporting this kind of access is called a priority queue or a heap:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module type Heap = sig type t type elem exception Empty val empty : t val isEmpty : t -\u003e bool val insert : elem -\u003e t -\u003e t val merge : t -\u003e t -\u003e t val findMin : t -\u003e elem val deleteMin : t -\u003e t end Heap can be implemented as heap-ordered trees, in which the element at each node is no large than the elements at its children. Under this ordering, the minimum element in a tree is always at the root. Leftist heaps are heap-ordered binary trees that satisfy the leftist property: the rank of any left child is at least as large as the rank of its right sibling. The rank of node is defined to be the length of its right spine(the rightmost path from the node in question to an empty node). A simple consequence of the leftist property is that the right spine of any node is always the shortest path to an empty node.\nWe define the leftist heap as functor:\n1 2 3 4 5 6 7 8 9 10 11 12 module LeftistHeap (Elem : Comparable) : (Heap with type elem = Elem.t) = struct type elem = Elem.t type t = | Leaf | Node of int * elem * t * t (* rank * value * left * right *) let empty = Leaf let isEmpty = function | Leaf -\u003e true | _ -\u003e false end The key insight behind leftist heaps is that two heaps can be merged by merging their right spines as you would merge two sorted lists, and then swapping the children of nodes along this path as necessary to restore the leftist proerty, this can beimplemented as follow:\n1 2 3 4 5 6 let rec merge h1 h2 = match h1, h2 with | (_ as h), Leaf | Leaf, (_ as h) -\u003e h | Node (_, x1, left1, right1), Node (_, x2, left2, right2) -\u003e if Elem.compare x1 x2 \u003c= 0 then makeTree x1 left1 (merge right1 h2) else makeTree x2 left2 (merge h1 right2) where the makeTree function make a new tree from two tree and a key:\n1 2 3 4 5 6 7 8 let rank = function | Leaf -\u003e 0 | Node (r, _, _, _) -\u003e r let makeTree x h1 h2 = if rank left \u003e= rank right then Node (rank b + 1, x, h1, h2) else Node (rank a + 1, x, h2, h1) Because the length of each right spine is at most logarithmic, merge runs in O(logN) time. And remaining functions are trivial via merge. To sum up, we have:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 (** leftistHeap.ml *) open Core module type Heap = sig type t type elem exception Empty val empty : t val isEmpty : t -\u003e bool val insert : elem -\u003e t -\u003e t val merge : t -\u003e t -\u003e t val findMin : t -\u003e elem val deleteMin : t -\u003e t end module Make (Elem : Comparable) : (Heap with type elem = Elem.t) = struct type elem = Elem.t type t = | Leaf | Node of int * elem * t * t (* rank * value * left * right *) let empty = Leaf let isEmpty = function | Leaf -\u003e true | _ -\u003e false let rank = function | Leaf -\u003e 0 | Node (r, _, _, _) -\u003e r let makeTree x h1 h2 = if rank h1 \u003e= rank h2 then Node (rank h2 + 1, x, h1, h2) else Node (rank h1 + 1, x, h2, h1) let rec merge h1 h2 = match h1, h2 with | (_ as h), Leaf | Leaf, (_ as h) -\u003e h | Node (_, x1, left1, right1), Node (_, x2, left2, right2) -\u003e if Elem.compare x1 x2 \u003c= 0 then makeTree x1 left1 (merge right1 h2) else makeTree x2 left2 (merge h1 right2) let insert x h = merge (Node (1, x, Leaf, Leaf)) h exception Empty let findMin = function | Node (_, x, _, _) -\u003e x | _ -\u003e raise Empty let deleteMin = function | Node (_, x, left, right) -\u003e merge left right | _ -\u003e raise Empty end Binomial heaps Another common implementation of heaps is binomial queues, which we call binomial heaps to avoid confusion with FIFO queues. Binomial heaps are composed of more primitive objects known as binomial trees. Binomial trees are inductively defined as follows:\nA binomial tree of rank 0 is a singleton node A binomial tree of rank k + 1 is formed by linking two binomial trees of rank k, making one tree the leftmost child of the other. So, it is easy to see that a binomial tree of rank r contains exactly $ 2^r $ nodes. Another equivalent definition of binomial trees is : a binomial tree of rank r in a node with r children $ t_1, \\cdots, t_r $, where each $ t_i $ is a binomial tree of rank $ r - i $, so we can represent a node in binomial tree as an element and a list of children as:\n1 type tree = Node of int * elem * (tree list) Each list of children is maintained in decreasing order of rank, and elements are sorted in heap order. Now a binomial heap is a collection of heap-orderd binomial trees in which no two trees have the same rank, this collection is represented as a list trees in increasing order of rank.\n1 type heap = tree list Because each binomial tree contains $ 2^r $ elements and no two trees have the same rank, the trees in a binomial heap of size n correspond exactly to ones in the binary representation of n. For example, the binary representation of 21 is 10101 so a binomial heap of size 21 would contain one tree of rank 0, one of rank 2 and one of rank 4. Note that, just as the binary representation of n contains at most log(n+1) ones, a binomial heap of size n contains at most log(n+1) trees.\nTo insert a new element into a heap, we first create a new binomial tree with rank 0, we then step through the existing trees in increasing order of rank until we find a missing rank, linking trees of equal rank as we go:\n1 2 3 4 5 6 7 8 9 10 11 let rank = function | Node (r, _, _) -\u003e r let rec insertTree t = function | [] -\u003e [t] | hd :: tl as h -\u003e if rank t \u003c rank hd then t :: h else insertTree (link t hd) tl let insert x h = insertTree (Node (0, x, [])) h The worst case is insertion into a heap of size $ n = 2^k - 1 $, requiring a total of k links and $ O(k)=O(log n) $. To merge two heaps, we step through both lists of trees in increasing order of rank, linking trees of equal rank as we go:\n1 2 3 4 5 6 7 8 let rec merge ts1 ts2 = match ts1, ts2 with | [], (_ as ts) | (_ as ts), [] -\u003e ts | hd1 :: tl1, hd2 :: tl2 -\u003e if rank hd1 \u003c rank hd2 then hd1 :: (merge tl1 ts2) else if rank hd2 \u003c rank hd1 then hd2 :: (merge tl2 ts1) else insertTree (link hd1 hd2) (merge tl1 tl2) And the deleteMin and findMin can implement simply by calling an auxiliary function removeMinTree, which find the tree with minimum root and remove it from the list, return both the tree and remaining list, thus we have complete implementation as follow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 (** binomialHeap.ml *) open Core module type Heap = sig type t type elem exception Empty val empty : t val isEmpty : t -\u003e bool val insert : elem -\u003e t -\u003e t val merge : t -\u003e t -\u003e t val findMin : t -\u003e elem val deleteMin : t -\u003e t end module Make (Elem : Comparable) : (Heap with type elem = Elem.t) = struct type elem = Elem.t type tree = Node of int * elem * tree list type t = tree list exception Empty let empty = [] let isEmpty = function | [] -\u003e true | _ -\u003e false let link t1 t2 = match t1, t2 with | Node (r, v1, ts1), Node (_, v2, ts2) -\u003e if Elem.compare v1 v2 \u003c= 0 then Node (r + 1, v1, t2 :: ts1) else Node (r + 1, v2, t1 :: ts2) let rank = function | Node (r, _, _) -\u003e r let root = function | Node (_, v, _) -\u003e v let rec insertTree t = function | [] -\u003e [t] | hd :: tl as ts -\u003e if rank t \u003c rank hd then t :: ts else insertTree (link t hd) tl let insert x ts = insertTree (Node (0, x, [])) ts let rec merge ts1 ts2 = match ts1, ts2 with | [], (_ as ts) | (_ as ts), [] -\u003e ts | hd1 :: tl1, hd2 :: tl2 -\u003e if rank hd1 \u003c rank hd2 then hd1 :: (merge tl1 ts2) else if rank hd2 \u003c rank hd1 then hd2 :: (merge tl2 ts1) else insertTree (link hd1 hd2) (merge tl1 tl2) let rec removeMinTree = function | [] -\u003e raise Empty | [t] -\u003e t, [] | hd :: tl -\u003e match (removeMinTree tl) with | t, ts -\u003e if Elem.compare (root hd) (root t) \u003c= 0 then hd, tl else t, hd :: ts let findMin ts = match (removeMinTree ts) with | t, _ -\u003e root t let deleteMin ts = match (removeMinTree ts) with | Node (_, _, ts1), ts2 -\u003e merge (List.rev ts1) ts2 end And each major operation require O(log n) time in the worst case.\nRed black tree As we know, a simply binary search tree perform very poorly on ordered data, for which any individual operation might take up to O(n) times. The solution to this problem is to keep each tree approximately balanced, which is knwon as balanced binary search tree, and red-black trees are one of the most popular families of balanced binary search tree. A red-black tree is a binary search tree in which every node is colored either red or black. every red-black tree satisfy the following invariants:\nall empty nodes are black no red node has a red child every path from root to an empty node contains the same number of black nodes. Take together, these invariants guarantee that the longest possible path in a red-black tree, one with alternating black and red nodes, is no more than twice as long as the shortest possible path, one with black nodes only. We can simple implement a red-black tree as:\n1 2 type color = Red | Black type t = Empty | Node of (color * t * elem * t) (* for some convenience *) The member function is the same as the function in binary search tree, because it does not care the color of node:\n1 2 3 4 5 6 7 8 let rec member x = function | Empty -\u003e false | Node (_, left, v, right) -\u003e if Elem.compare x v \u003c 0 then member x left else if Elem.compare x v \u003e 0 then member x right else true The insert function need to mantain the two balanced invariants:\n1 2 3 4 5 6 7 8 9 10 11 12 let insert x tree = let rec aux = function | Empty -\u003e Node (Red, Empty, x, Empty) | Node (color, left, v, right) -\u003e if Elem.compare x v \u003c 0 then balance color (aux left) v right else if Elem.compare x v \u003e 0 then balance color left v (aux right) else tree in match (aux tree) with | Node (_, left, v, right) -\u003e Node (Black, left, v, right) | Empty -\u003e Empty (* have no sense except avoid warning *) First, when we create a new node with Empty, we initially color it red. Second we force the final root to be black, regardless of the color. Finally, we replace the calls to the Node constructor in the with the balance function, which acts just as the Node constructor except that it massages its arguments as necessary to enforce the balance invariants.\nColoring the new node red maintains invariant 3, but violate invariant 2 whenever the parent of the new node is red. We allow a single red-red violation at a time, and percolate this violation up the search path toward the root during rebalancing. The balance function detects and repairs each red-red violation when it processes the black parent of the red node with a red child. This black-red-red path can occur in any of four configurations, depending on whether each red node is a left or right child. However, the solution is the same in every case: rewrite the black-red-red path as a red node with two black children:\n1 2 3 4 5 6 7 let balance color left v right = match color, left, v, right with | Black, (Node (Red, Node (Red, a, x, b), y, c)), z, d (* left-left case *) | Black, (Node (Red, a, x, Node (Red, b, y, c))), z, d (* left-right case *) | Black, a, x, (Node (Red, Node (Red, b, y, c), z, d)) (* right-left case *) | Black, a, x, (Node (Red, b, y, Node (Red, c, z, d))) -\u003e (* right-right case *) Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d)) | _ as tuple -\u003e Node tuple And you can see it’s much elegant than any version written in imperative setting. After balancing a given subtree, the red root of that subtree might now be the child of another red node. Thus we continue balancing all the way to the top of the tree. At the very top of the tree, we might end up with a red node with a red child, but with no black parent, we handle this case by always recoloring the root to be black. Now we sum it all:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 (** redBlackSet.ml *) open Core module type Set = sig type t type elem val empty : t val insert : elem -\u003e t -\u003e t val member : elem -\u003e t -\u003e bool end module Make (Elem : Comparable) : (Set with type elem = Elem.t) = struct type elem = Elem.t type color = Red | Black type t = Empty | Node of (color * t * elem * t) let empty = Empty let rec member x = function | Empty -\u003e false | Node (_, left, v, right) -\u003e if Elem.compare x v \u003c 0 then member x left else if Elem.compare x v \u003e 0 then member x right else true let balance color left v right = match color, left, v, right with | Black, (Node (Red, Node (Red, a, x, b), y, c)), z, d (* left-left case *) | Black, (Node (Red, a, x, Node (Red, b, y, c))), z, d (* left-right case *) | Black, a, x, (Node (Red, Node (Red, b, y, c), z, d)) (* right-left case *) | Black, a, x, (Node (Red, b, y, Node (Red, c, z, d))) -\u003e (* right-right case *) Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d)) | _ as tuple -\u003e Node tuple let insert x tree = let rec aux = function | Empty -\u003e Node (Red, Empty, x, Empty) | Node (color, left, v, right) -\u003e if Elem.compare x v \u003c 0 then balance color (aux left) v right else if Elem.compare x v \u003e 0 then balance color left v (aux right) else tree in match (aux tree) with | Node (_, left, v, right) -\u003e Node (Black, left, v, right) | Empty -\u003e Empty (* have no sense except avoid warning *) end Even without optimization, this implementation of balanced binary search trees is one of the fastest around. With appropriate optimizations, such as eliminating comparison (we have done this before) and eliminating redundant testing(while recursing on the left child their is no need for red-red violations involving the right child)\n","wordCount":"4401","inLanguage":"en","datePublished":"2018-07-19T17:00:11Z","dateModified":"2018-07-19T17:00:11Z","author":{"@type":"Person","name":"Christophe"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sdlinks.net/posts/2018/functional-data-structure-1/"},"publisher":{"@type":"Organization","name":"Neo VRAINS","logo":{"@type":"ImageObject","url":"https://www.sdlinks.net/images/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://www.sdlinks.net/ accesskey=h title="Neo VRAINS (Alt + H)">Neo VRAINS</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.sdlinks.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.sdlinks.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.sdlinks.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://www.sdlinks.net/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Functional Data Structure 1</h1><div class=post-meta><span title='2018-07-19 17:00:11 +0000 UTC'>July 19, 2018</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>To implement data structure in a functional way, there are two basic problems. First, from the point of view of designing
and implementing efficient data structures, functional programming&rsquo;s stricture against destructive updates(i.e. assignments)
is a staggering handicap, tantamount to confiscating a master chef&rsquo;s knives.</p><p>Imperative data structures often rely on
assignments in crucial ways, and so different solutions must be found for functional programs. The second difficulty is
that functional data strcutures are expected to be more flexible than their imperative counterparts. In particular, when
we update an imperative data structure we typically accept that the old version of the data strcuture will no longer
be available, but when we update a functional data structure, we expect that both the old and the new version of the data
structure will be available for further processing, this is called <em>persistent</em>, while the other is called <em>ephemeral</em>.
And we are not surprised if the persistent version is more complicated and even less efficient that the ephemeral one.</p><p>The term <em>data structure</em> has at least four distinct, but related, meanings:</p><ol><li>An <em>abstract data type</em>, that is, a type and a collection of functions on that type, we can refer to this as an <em>abstraction</em>.</li><li>A <em>concrete realization of an abstract data type</em>, we can refer to this as an <em>implementation</em>, but note that an
implentation need not be actualized as code &ndash; a concrete design is sufficient.</li><li>An <em>instance of a data type, such as a particular list or tree</em>. We can refer to such an instance generically as an
<em>object</em> or a <em>version</em>. However, particular data types often have their own nomenclature, for example, we simply refer
to stack or queue objects as stacks or queues.</li><li>A <em>unique identity that is invariant under updates</em>. For example, in a stack-based interpreter, we often speak informally
about &ldquo;the stack&rdquo; as if there were only one stack, rather than different versions at different times. We can refer to this
identity as a <em>persistent identity</em>.</li></ol><h2 id=persistence>Persistence<a hidden class=anchor aria-hidden=true href=#persistence>#</a></h2><p>A distinctive property of functional data structures is that they are always persistent, updating a functional data
structure does not destory the existing version, but rather creates a new version that coexists with the old one. Persistence
is achieved by coping the affected nodes of a data structure and making all changes in the copy of rather than in the
original. Because nodes are never modified directly, all nodes that are unaffected by an update can be shared between
the old and new version of the data structure without worrying that a change in one version will inadvertently be visible
to the other.</p><h3 id=lists>Lists<a hidden class=anchor aria-hidden=true href=#lists>#</a></h3><p>Linked lists are common in imperative programming and ubiquitous in functional programming. And we can define its abstraction
as follow:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=c>(** userList.mli *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>isEmpty</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>exception</span> <span class=nc>Empty</span> <span class=c>(* the exception does not matter *)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>cons</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>head</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>tail</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span></code></pre></td></tr></table></div></div><p>It can be implemented trivially using either the built-in type of lists or a custom datatype:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=c>(** userList.ml *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Nil</span> 
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Cons</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>*</span> <span class=o>(</span><span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span><span class=o>)</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=nc>Nil</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>isEmpty</span> <span class=o>=</span> <span class=k>function</span> 
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Nil</span> <span class=o>-&gt;</span> <span class=bp>true</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>cons</span><span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>tl</span><span class=o>)</span> <span class=o>=</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>tl</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>head</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Nil</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>tl</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>hd</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>tail</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Nil</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>tl</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>tl</span>
</span></span></code></pre></td></tr></table></div></div><p>Another common function on the lists is append(<code>@</code> in ocaml), we denote it as <code>++</code>, and it&rsquo;s easy to implement it in a
O(n) way, while we can implement in a O(1) way in an imperative setting:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=o>(++)</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Nil</span><span class=o>,</span> <span class=n>ys</span> <span class=o>-&gt;</span> <span class=n>ys</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>tl</span><span class=o>),</span> <span class=n>ys</span> <span class=o>-&gt;</span> <span class=n>tl</span> <span class=o>++</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>ys</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>In functional setting, we have to copy the entire list to keep the persistence so that we are free to continue using the
old lists as well as the new list. Although this is undeniably a lot of copying, notice that the second list ys shares
the nodes wit the new list. Another function that illustrates these twin concepts of copying and sharing is update, which
changes the value of a node at a given index in the list:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>update</span> <span class=n>xs</span> <span class=n>idx</span> <span class=n>x</span> <span class=o>=</span> <span class=k>match</span> <span class=o>(</span><span class=n>xs</span><span class=o>,</span> <span class=n>idx</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=nc>Nil</span><span class=o>,</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Subscript</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>tl</span><span class=o>),</span> <span class=n>0</span> <span class=o>-&gt;</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>tl</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>tl</span><span class=o>),</span> <span class=o>(_</span> <span class=k>as</span> <span class=n>n</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>update</span> <span class=n>tl</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=n>x</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Notice that this version of update is not tail call, so we can transform it via CPS:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>update</span> <span class=n>xs</span> <span class=n>idx</span> <span class=n>x</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>updateK</span> <span class=n>xs</span> <span class=n>idx</span> <span class=n>x</span> <span class=n>k</span> <span class=o>=</span> <span class=k>match</span> <span class=n>xs</span><span class=o>,</span> <span class=n>idx</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Nil</span><span class=o>,</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Subscript</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>tl</span><span class=o>),</span> <span class=n>0</span> <span class=o>-&gt;</span> <span class=n>k</span> <span class=o>(</span><span class=nc>Cons</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>tl</span><span class=o>))</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>tl</span><span class=o>),</span> <span class=o>(_</span> <span class=k>as</span> <span class=n>n</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>updateK</span> <span class=n>tl</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=n>x</span> <span class=o>(</span><span class=k>fun</span> <span class=n>var1</span> <span class=o>-&gt;</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>var1</span><span class=o>))</span>
</span></span><span class=line><span class=cl>  <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>updateK</span> <span class=n>xs</span> <span class=n>idx</span> <span class=n>x</span> <span class=o>(</span><span class=k>fun</span> <span class=n>var1</span> <span class=o>-&gt;</span> <span class=n>var1</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>so that the tail optimization can be applied.</p><h3 id=binary-search-trees>Binary search trees<a hidden class=anchor aria-hidden=true href=#binary-search-trees>#</a></h3><p>Binary search trees provide a good example of the kind of sharing the node with more than one pointer field. And a binary
search tree can implement sets or finite maps, whose minimal interfaces as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>Set</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span> 
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=n>t</span> 
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>insert</span> <span class=o>:</span> <span class=n>elem</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>member</span> <span class=o>:</span> <span class=n>elem</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><pre tabindex=0><code>module type finiteMap = sig
  type &#39;a t
  type key
  
  exception NotFound
  
  val empty : &#39;a t
  val bind : key -&gt; &#39;a -&gt; &#39;a t -&gt; &#39;a t
  val lookup : key -&gt; &#39;a t -&gt; &#39;a (* raise NotFound if key is not found *)
end
</code></pre><p>where the elem is some fixed type of totally-ordered elements. A more realistic implementation would probably include
many additional functions, such as deleting an element or enumerating all elements. An unblanced set via binary search
tree can be implemented as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>open</span> <span class=nc>Core</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>UnbalancedSet</span><span class=o>(</span><span class=nc>Elem</span> <span class=o>:</span> <span class=nc>Comparable</span><span class=o>)</span> <span class=o>:</span> <span class=o>(</span><span class=nc>Set</span> <span class=k>with</span> <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span><span class=o>)</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>struct</span>
</span></span><span class=line><span class=cl>    <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>    <span class=k>type</span> <span class=n>t</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Leaf</span> 
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=n>t</span> <span class=o>*</span> <span class=n>elem</span> <span class=o>*</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>exception</span> <span class=nc>AlreadyInSet</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=k>rec</span> <span class=n>insert</span> <span class=n>x</span> <span class=n>tree</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>      <span class=k>let</span> <span class=n>aux</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>        <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Leaf</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=nc>Leaf</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>0</span> 
</span></span><span class=line><span class=cl>          <span class=k>then</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>insert</span> <span class=n>x</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span> <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&gt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>          <span class=k>then</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>insert</span> <span class=n>x</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span> <span class=k>raise</span> <span class=nc>AlreadyInSet</span> 
</span></span><span class=line><span class=cl>      <span class=k>in</span>
</span></span><span class=line><span class=cl>      <span class=k>try</span> 
</span></span><span class=line><span class=cl>        <span class=n>aux</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>      <span class=k>with</span> <span class=nc>AlreadyInSet</span> <span class=o>-&gt;</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=k>rec</span> <span class=n>member</span> <span class=n>x</span> <span class=n>tree</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>      <span class=k>let</span> <span class=k>rec</span> <span class=n>aux</span> <span class=n>candidate</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>        <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>          <span class=k>match</span> <span class=n>candidate</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>          <span class=o>|</span> <span class=nc>None</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>          <span class=o>|</span> <span class=nc>Some</span> <span class=n>v</span> <span class=o>-&gt;</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>        <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>          <span class=k>then</span> <span class=n>memberHelp</span> <span class=n>candidate</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span> <span class=n>member</span> <span class=o>(</span><span class=nc>Some</span> <span class=n>v</span><span class=o>)</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>      <span class=k>in</span>
</span></span><span class=line><span class=cl>      <span class=n>aux</span> <span class=nc>None</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>where the Comparable is:</p><pre tabindex=0><code>module type Comparable = sig
type t
val compare : t -&gt; t -&gt; int
end
</code></pre><p>Notice that in the <code>member</code> function, we defined a auxiliary function that take a candidate that less than or equal to
the search value such that it take no more than <code>d + 1</code> comparisons, where <code>d</code> is the depth of the tree, while in a traditional
way, we need <code>2d</code> comparisons in the worst case. And in the <code>insert</code> function, we introduce a <code>AlreadyInSet</code> exception
so that it return the tree itself while inserting an existing value to the tree to avoid the extra copying in the situation.</p><p>To sum up, we keep the persistence via sharing and copying.</p><h2 id=some-familiar-data-structures-in-a-functional-setting>Some Familiar Data Structures in A Functional Setting<a hidden class=anchor aria-hidden=true href=#some-familiar-data-structures-in-a-functional-setting>#</a></h2><p>Although many imperative data structures are difficult or impossible to adapt to a functional setting, some can be adapted
quite easily.</p><h3 id=leftist-heaps>Leftist heaps<a hidden class=anchor aria-hidden=true href=#leftist-heaps>#</a></h3><p>Sometimes we need efficient access only to the minimum element, a data structure supporting this kind of access is called
a <em>priority queue</em> or a <em>heap</em>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>Heap</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>isEmpty</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>insert</span> <span class=o>:</span> <span class=n>elem</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>merge</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>findMin</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>deleteMin</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>Heap can be implemented as <em>heap-ordered</em> trees, in which the element at each node is no large than the elements at its
children. Under this ordering, the minimum element in a tree is always at the root. Leftist heaps are heap-ordered binary
trees that satisfy the leftist property: the rank of any left child is at least as large as the rank of its right sibling.
The rank of node is defined to be the length of its <em>right spine</em>(the rightmost path from the node in question to an empty
node). A simple consequence of the leftist property is that the right spine of any node is always the shortest path to
an empty node.</p><p>We define the leftist heap as functor:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>module</span> <span class=nc>LeftistHeap</span> <span class=o>(</span><span class=nc>Elem</span> <span class=o>:</span> <span class=nc>Comparable</span><span class=o>)</span> <span class=o>:</span> <span class=o>(</span><span class=nc>Heap</span> <span class=k>with</span> <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span><span class=o>)</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>struct</span>
</span></span><span class=line><span class=cl>    <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>    <span class=k>type</span> <span class=n>t</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>elem</span> <span class=o>*</span> <span class=n>t</span> <span class=o>*</span> <span class=n>t</span>  <span class=c>(* rank * value * left * right *)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>isEmpty</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=bp>true</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>The key insight behind leftist heaps is that two heaps can be merged by merging their right spines as you would merge
two sorted lists, and then swapping the children of nodes along this path as necessary to restore the leftist proerty,
this can beimplemented as follow:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>merge</span> <span class=n>h1</span> <span class=n>h2</span> <span class=o>=</span> <span class=k>match</span> <span class=n>h1</span><span class=o>,</span> <span class=n>h2</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=o>(_</span> <span class=k>as</span> <span class=n>h</span><span class=o>),</span> <span class=nc>Leaf</span> <span class=o>|</span> <span class=nc>Leaf</span><span class=o>,</span> <span class=o>(_</span> <span class=k>as</span> <span class=n>h</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>h</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>x1</span><span class=o>,</span> <span class=n>left1</span><span class=o>,</span> <span class=n>right1</span><span class=o>),</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>x2</span><span class=o>,</span> <span class=n>left2</span><span class=o>,</span> <span class=n>right2</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x1</span> <span class=n>x2</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>        <span class=k>then</span> <span class=n>makeTree</span> <span class=n>x1</span> <span class=n>left1</span> <span class=o>(</span><span class=n>merge</span> <span class=n>right1</span> <span class=n>h2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=n>makeTree</span> <span class=n>x2</span> <span class=n>left2</span> <span class=o>(</span><span class=n>merge</span> <span class=n>h1</span> <span class=n>right2</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>where the makeTree function make a new tree from two tree and a key:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>rank</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>r</span><span class=o>,</span> <span class=o>_,</span> <span class=o>_,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>makeTree</span> <span class=n>x</span> <span class=n>h1</span> <span class=n>h2</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>rank</span> <span class=n>left</span> <span class=o>&gt;=</span> <span class=n>rank</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>  <span class=k>then</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>rank</span> <span class=n>b</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>h1</span><span class=o>,</span> <span class=n>h2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>rank</span> <span class=n>a</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>h2</span><span class=o>,</span> <span class=n>h1</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Because the length of each right spine is at most logarithmic, merge runs in O(logN) time. And remaining functions are
trivial via <code>merge</code>. To sum up, we have:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=c>(** leftistHeap.ml *)</span>
</span></span><span class=line><span class=cl><span class=k>open</span> <span class=nc>Core</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>Heap</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>isEmpty</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>insert</span> <span class=o>:</span> <span class=n>elem</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>merge</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>findMin</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>deleteMin</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>Make</span> <span class=o>(</span><span class=nc>Elem</span> <span class=o>:</span> <span class=nc>Comparable</span><span class=o>)</span> <span class=o>:</span> <span class=o>(</span><span class=nc>Heap</span> <span class=k>with</span> <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span><span class=o>)</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>struct</span>
</span></span><span class=line><span class=cl>    <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>    <span class=k>type</span> <span class=n>t</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>elem</span> <span class=o>*</span> <span class=n>t</span> <span class=o>*</span> <span class=n>t</span>  <span class=c>(* rank * value * left * right *)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>isEmpty</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=bp>true</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>rank</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>r</span><span class=o>,</span> <span class=o>_,</span> <span class=o>_,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>makeTree</span> <span class=n>x</span> <span class=n>h1</span> <span class=n>h2</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>rank</span> <span class=n>h1</span> <span class=o>&gt;=</span> <span class=n>rank</span> <span class=n>h2</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>rank</span> <span class=n>h2</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>h1</span><span class=o>,</span> <span class=n>h2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>rank</span> <span class=n>h1</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>h2</span><span class=o>,</span> <span class=n>h1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=k>rec</span> <span class=n>merge</span> <span class=n>h1</span> <span class=n>h2</span> <span class=o>=</span> <span class=k>match</span> <span class=n>h1</span><span class=o>,</span> <span class=n>h2</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=o>(_</span> <span class=k>as</span> <span class=n>h</span><span class=o>),</span> <span class=nc>Leaf</span> <span class=o>|</span> <span class=nc>Leaf</span><span class=o>,</span> <span class=o>(_</span> <span class=k>as</span> <span class=n>h</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>h</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>x1</span><span class=o>,</span> <span class=n>left1</span><span class=o>,</span> <span class=n>right1</span><span class=o>),</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>x2</span><span class=o>,</span> <span class=n>left2</span><span class=o>,</span> <span class=n>right2</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x1</span> <span class=n>x2</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>        <span class=k>then</span> <span class=n>makeTree</span> <span class=n>x1</span> <span class=n>left1</span> <span class=o>(</span><span class=n>merge</span> <span class=n>right1</span> <span class=n>h2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=n>makeTree</span> <span class=n>x2</span> <span class=n>left2</span> <span class=o>(</span><span class=n>merge</span> <span class=n>h1</span> <span class=n>right2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>insert</span> <span class=n>x</span> <span class=n>h</span> <span class=o>=</span> <span class=n>merge</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=nc>Leaf</span><span class=o>,</span> <span class=nc>Leaf</span><span class=o>))</span> <span class=n>h</span> 
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>findMin</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>x</span><span class=o>,</span> <span class=o>_,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>deleteMin</span> <span class=o>=</span> <span class=k>function</span> 
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>x</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>merge</span> <span class=n>left</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=binomial-heaps>Binomial heaps<a hidden class=anchor aria-hidden=true href=#binomial-heaps>#</a></h3><p>Another common implementation of heaps is binomial queues, which we call <em>binomial heaps</em> to avoid confusion with FIFO
queues. Binomial heaps are composed of more primitive objects known as binomial trees. Binomial trees are inductively
defined as follows:</p><ol><li>A binomial tree of rank 0 is a singleton node</li><li>A binomial tree of rank k + 1 is formed by linking two binomial trees of rank k, making one tree the leftmost child
of the other.</li></ol><p>So, it is easy to see that a binomial tree of rank r contains exactly $ 2^r $ nodes. Another equivalent definition of
binomial trees is : a binomial tree of rank r in a node with r children $ t_1, \cdots, t_r $, where each $ t_i $ is a
binomial tree of rank $ r - i $, so we can represent a node in binomial tree as an element and a list of children as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>tree</span> <span class=o>=</span> <span class=nc>Node</span> <span class=k>of</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>elem</span> <span class=o>*</span> <span class=o>(</span><span class=n>tree</span> <span class=kt>list</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Each list of children is maintained in decreasing order of rank, and elements are sorted in heap order. Now a binomial
heap is a collection of heap-orderd binomial trees in which no two trees have the same rank, this collection is represented
as a list trees in increasing order of rank.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>heap</span> <span class=o>=</span> <span class=n>tree</span> <span class=kt>list</span>
</span></span></code></pre></td></tr></table></div></div><p>Because each binomial tree contains $ 2^r $ elements and no two trees have the same rank, the trees in a binomial heap
of size n correspond exactly to ones in the binary representation of n. For example, the binary representation of 21
is 10101 so a binomial heap of size 21 would contain one tree of rank 0, one of rank 2 and one of rank 4. Note that, just
as the binary representation of n contains at most log(n+1) ones, a binomial heap of size n contains at most log(n+1) trees.</p><p>To insert a new element into a heap, we first create a new binomial tree with rank 0, we then step through the existing
trees in increasing order of rank until we find a missing rank, linking trees of equal rank as we go:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>rank</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>r</span><span class=o>,</span> <span class=o>_,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>insertTree</span> <span class=n>t</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=o>[</span><span class=n>t</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>hd</span> <span class=o>::</span> <span class=n>tl</span> <span class=k>as</span> <span class=n>h</span> <span class=o>-&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>rank</span> <span class=n>t</span> <span class=o>&lt;</span> <span class=n>rank</span> <span class=n>hd</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>t</span> <span class=o>::</span> <span class=n>h</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>insertTree</span> <span class=o>(</span><span class=n>link</span> <span class=n>t</span> <span class=n>hd</span><span class=o>)</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>insert</span> <span class=n>x</span> <span class=n>h</span> <span class=o>=</span> <span class=n>insertTree</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=bp>[]</span><span class=o>))</span> <span class=n>h</span>
</span></span></code></pre></td></tr></table></div></div><p>The worst case is insertion into a heap of size $ n = 2^k - 1 $, requiring a total of k links and $ O(k)=O(log n) $. To
merge two heaps, we step through both lists of trees in increasing order of rank, linking trees of equal rank as we go:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>merge</span> <span class=n>ts1</span> <span class=n>ts2</span> <span class=o>=</span> <span class=k>match</span> <span class=n>ts1</span><span class=o>,</span> <span class=n>ts2</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span><span class=o>,</span> <span class=o>(_</span> <span class=k>as</span> <span class=n>ts</span><span class=o>)</span> <span class=o>|</span> <span class=o>(_</span> <span class=k>as</span> <span class=n>ts</span><span class=o>),</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=n>ts</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>hd1</span> <span class=o>::</span> <span class=n>tl1</span><span class=o>,</span> <span class=n>hd2</span> <span class=o>::</span> <span class=n>tl2</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>rank</span> <span class=n>hd1</span> <span class=o>&lt;</span> <span class=n>rank</span> <span class=n>hd2</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>hd1</span> <span class=o>::</span> <span class=o>(</span><span class=n>merge</span> <span class=n>tl1</span> <span class=n>ts2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=n>rank</span> <span class=n>hd2</span> <span class=o>&lt;</span> <span class=n>rank</span> <span class=n>hd1</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>hd2</span> <span class=o>::</span> <span class=o>(</span><span class=n>merge</span> <span class=n>tl2</span> <span class=n>ts1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>insertTree</span> <span class=o>(</span><span class=n>link</span> <span class=n>hd1</span> <span class=n>hd2</span><span class=o>)</span> <span class=o>(</span><span class=n>merge</span> <span class=n>tl1</span> <span class=n>tl2</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>And the deleteMin and findMin can implement simply by calling an auxiliary function removeMinTree, which find the
tree with minimum root and remove it from the list, return both the tree and remaining list, thus we have complete
implementation as follow:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=c>(** binomialHeap.ml *)</span>
</span></span><span class=line><span class=cl><span class=k>open</span> <span class=nc>Core</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>Heap</span> <span class=o>=</span> <span class=k>sig</span> 
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>isEmpty</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>insert</span> <span class=o>:</span> <span class=n>elem</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>merge</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>findMin</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>deleteMin</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>Make</span> <span class=o>(</span><span class=nc>Elem</span> <span class=o>:</span> <span class=nc>Comparable</span><span class=o>)</span> <span class=o>:</span> <span class=o>(</span><span class=nc>Heap</span> <span class=k>with</span> <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span><span class=o>)</span> <span class=o>=</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>tree</span> <span class=o>=</span> <span class=nc>Node</span> <span class=k>of</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>elem</span> <span class=o>*</span> <span class=n>tree</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=n>tree</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>  <span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=bp>[]</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>isEmpty</span> <span class=o>=</span> <span class=k>function</span> 
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=bp>true</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>link</span> <span class=n>t1</span> <span class=n>t2</span> <span class=o>=</span> <span class=k>match</span> <span class=n>t1</span><span class=o>,</span> <span class=n>t2</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>r</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>ts1</span><span class=o>),</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>v2</span><span class=o>,</span> <span class=n>ts2</span><span class=o>)</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>v1</span> <span class=n>v2</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>r</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>t2</span> <span class=o>::</span> <span class=n>ts1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>r</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>v2</span><span class=o>,</span> <span class=n>t1</span> <span class=o>::</span> <span class=n>ts2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>rank</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>r</span><span class=o>,</span> <span class=o>_,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>root</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>v</span><span class=o>,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>v</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>insertTree</span> <span class=n>t</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=o>[</span><span class=n>t</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>hd</span> <span class=o>::</span> <span class=n>tl</span> <span class=k>as</span> <span class=n>ts</span> <span class=o>-&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>rank</span> <span class=n>t</span> <span class=o>&lt;</span> <span class=n>rank</span> <span class=n>hd</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=n>t</span> <span class=o>::</span> <span class=n>ts</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=n>insertTree</span> <span class=o>(</span><span class=n>link</span> <span class=n>t</span> <span class=n>hd</span><span class=o>)</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>insert</span> <span class=n>x</span> <span class=n>ts</span> <span class=o>=</span> <span class=n>insertTree</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=bp>[]</span><span class=o>))</span> <span class=n>ts</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>merge</span> <span class=n>ts1</span> <span class=n>ts2</span> <span class=o>=</span> <span class=k>match</span> <span class=n>ts1</span><span class=o>,</span> <span class=n>ts2</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span><span class=o>,</span> <span class=o>(_</span> <span class=k>as</span> <span class=n>ts</span><span class=o>)</span> <span class=o>|</span> <span class=o>(_</span> <span class=k>as</span> <span class=n>ts</span><span class=o>),</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=n>ts</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>hd1</span> <span class=o>::</span> <span class=n>tl1</span><span class=o>,</span> <span class=n>hd2</span> <span class=o>::</span> <span class=n>tl2</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>rank</span> <span class=n>hd1</span> <span class=o>&lt;</span> <span class=n>rank</span> <span class=n>hd2</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=n>hd1</span> <span class=o>::</span> <span class=o>(</span><span class=n>merge</span> <span class=n>tl1</span> <span class=n>ts2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=k>if</span> <span class=n>rank</span> <span class=n>hd2</span> <span class=o>&lt;</span> <span class=n>rank</span> <span class=n>hd1</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=n>hd2</span> <span class=o>::</span> <span class=o>(</span><span class=n>merge</span> <span class=n>tl2</span> <span class=n>ts1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=n>insertTree</span> <span class=o>(</span><span class=n>link</span> <span class=n>hd1</span> <span class=n>hd2</span><span class=o>)</span> <span class=o>(</span><span class=n>merge</span> <span class=n>tl1</span> <span class=n>tl2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>removeMinTree</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=o>[</span><span class=n>t</span><span class=o>]</span> <span class=o>-&gt;</span> <span class=n>t</span><span class=o>,</span> <span class=bp>[]</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>hd</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=k>match</span> <span class=o>(</span><span class=n>removeMinTree</span> <span class=n>tl</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=n>t</span><span class=o>,</span> <span class=n>ts</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=o>(</span><span class=n>root</span> <span class=n>hd</span><span class=o>)</span> <span class=o>(</span><span class=n>root</span> <span class=n>t</span><span class=o>)</span> <span class=o>&lt;=</span> <span class=n>0</span> 
</span></span><span class=line><span class=cl>        <span class=k>then</span> <span class=n>hd</span><span class=o>,</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=n>t</span><span class=o>,</span> <span class=n>hd</span> <span class=o>::</span> <span class=n>ts</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>findMin</span> <span class=n>ts</span> <span class=o>=</span> <span class=k>match</span> <span class=o>(</span><span class=n>removeMinTree</span> <span class=n>ts</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>t</span><span class=o>,</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>root</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>deleteMin</span> <span class=n>ts</span> <span class=o>=</span> <span class=k>match</span> <span class=o>(</span><span class=n>removeMinTree</span> <span class=n>ts</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=o>_,</span> <span class=n>ts1</span><span class=o>),</span> <span class=n>ts2</span> <span class=o>-&gt;</span> <span class=n>merge</span> <span class=o>(</span><span class=nn>List</span><span class=p>.</span><span class=n>rev</span> <span class=n>ts1</span><span class=o>)</span> <span class=n>ts2</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>And each major operation require O(log n) time in the worst case.</p><h3 id=red-black-tree>Red black tree<a hidden class=anchor aria-hidden=true href=#red-black-tree>#</a></h3><p>As we know, a simply binary search tree perform very poorly on ordered data, for which any individual operation might
take up to O(n) times. The solution to this problem is to keep each tree approximately balanced, which is knwon as
balanced binary search tree, and red-black trees are one of the most popular families of balanced binary search tree. A
red-black tree is a binary search tree in which every node is colored either red or black. every red-black tree satisfy
the following invariants:</p><ol><li>all empty nodes are black</li><li>no red node has a red child</li><li>every path from root to an empty node contains the same number of black nodes.
Take together, these invariants guarantee that the longest possible path in a red-black tree, one with alternating black
and red nodes, is no more than twice as long as the shortest possible path, one with black nodes only.</li></ol><p>We can simple implement a red-black tree as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>color</span> <span class=o>=</span> <span class=nc>Red</span> <span class=o>|</span> <span class=nc>Black</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=nc>Empty</span> <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=o>(</span><span class=n>color</span> <span class=o>*</span> <span class=n>t</span> <span class=o>*</span> <span class=n>elem</span> <span class=o>*</span> <span class=n>t</span><span class=o>)</span>  <span class=c>(* for some convenience *)</span>
</span></span></code></pre></td></tr></table></div></div><p>The member function is the same as the function in binary search tree, because it does not care the color of node:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>member</span> <span class=n>x</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Empty</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>0</span> 
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>member</span> <span class=n>x</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&gt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>member</span> <span class=n>x</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=bp>true</span>
</span></span></code></pre></td></tr></table></div></div><p>The insert function need to mantain the two balanced invariants:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>insert</span> <span class=n>x</span> <span class=n>tree</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>aux</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Empty</span> <span class=o>-&gt;</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=nc>Empty</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=nc>Empty</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>color</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=n>balance</span> <span class=n>color</span> <span class=o>(</span><span class=n>aux</span> <span class=n>left</span><span class=o>)</span> <span class=n>v</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&gt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=n>balance</span> <span class=n>color</span> <span class=n>left</span> <span class=n>v</span> <span class=o>(</span><span class=n>aux</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>  <span class=k>in</span> <span class=k>match</span> <span class=o>(</span><span class=n>aux</span> <span class=n>tree</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Black</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Empty</span> <span class=o>-&gt;</span> <span class=nc>Empty</span>  <span class=c>(* have no sense except avoid warning *)</span>
</span></span></code></pre></td></tr></table></div></div><p>First, when we create a new node with <code>Empty</code>, we initially color it red. Second we force the final root to be black,
regardless of the color. Finally, we replace the calls to the <code>Node</code> constructor in the with the balance function, which
acts just as the <code>Node</code> constructor except that it massages its arguments as necessary to enforce the balance invariants.</p><p>Coloring the new node red maintains invariant 3, but violate invariant 2 whenever the parent of the new node is red. We
allow a single red-red violation at a time, and percolate this violation up the search path toward the root during rebalancing.
The balance function detects and repairs each red-red violation when it processes the black parent of the red node with
a red child. This black-red-red path can occur in any of four configurations, depending on whether each red node is a
left or right child. However, the solution is the same in every case: rewrite the black-red-red path as a red node with
two black children:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>balance</span> <span class=n>color</span> <span class=n>left</span> <span class=n>v</span> <span class=n>right</span> <span class=o>=</span> <span class=k>match</span> <span class=n>color</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Black</span><span class=o>,</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>b</span><span class=o>),</span> <span class=n>y</span><span class=o>,</span> <span class=n>c</span><span class=o>)),</span> <span class=n>z</span><span class=o>,</span> <span class=n>d</span>       <span class=c>(* left-left case   *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Black</span><span class=o>,</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>b</span><span class=o>,</span> <span class=n>y</span><span class=o>,</span> <span class=n>c</span><span class=o>))),</span> <span class=n>z</span><span class=o>,</span> <span class=n>d</span>       <span class=c>(* left-right case  *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Black</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>b</span><span class=o>,</span> <span class=n>y</span><span class=o>,</span> <span class=n>c</span><span class=o>),</span> <span class=n>z</span><span class=o>,</span> <span class=n>d</span><span class=o>))</span>       <span class=c>(* right-left case  *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Black</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>b</span><span class=o>,</span> <span class=n>y</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>c</span><span class=o>,</span> <span class=n>z</span><span class=o>,</span> <span class=n>d</span><span class=o>)))</span> <span class=o>-&gt;</span>    <span class=c>(* right-right case *)</span>
</span></span><span class=line><span class=cl>    <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Black</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>b</span><span class=o>),</span> <span class=n>y</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Black</span><span class=o>,</span> <span class=n>c</span><span class=o>,</span> <span class=n>z</span><span class=o>,</span> <span class=n>d</span><span class=o>))</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=k>as</span> <span class=n>tuple</span> <span class=o>-&gt;</span> <span class=nc>Node</span> <span class=n>tuple</span>
</span></span></code></pre></td></tr></table></div></div><p>And you can see it&rsquo;s much elegant than any version written in imperative setting. After balancing a given subtree, the
red root of that subtree might now be the child of another red node. Thus we continue balancing all the way to the top
of the tree. At the very top of the tree, we might end up with a red node with a red child, but with no black parent, we
handle this case by always recoloring the root to be black. Now we sum it all:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=c>(** redBlackSet.ml *)</span>
</span></span><span class=line><span class=cl><span class=k>open</span> <span class=nc>Core</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>Set</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>insert</span> <span class=o>:</span> <span class=n>elem</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>member</span> <span class=o>:</span> <span class=n>elem</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>Make</span> <span class=o>(</span><span class=nc>Elem</span> <span class=o>:</span> <span class=nc>Comparable</span><span class=o>)</span> <span class=o>:</span> <span class=o>(</span><span class=nc>Set</span> <span class=k>with</span> <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span><span class=o>)</span> <span class=o>=</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>color</span> <span class=o>=</span> <span class=nc>Red</span> <span class=o>|</span> <span class=nc>Black</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=nc>Empty</span> <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=o>(</span><span class=n>color</span> <span class=o>*</span> <span class=n>t</span> <span class=o>*</span> <span class=n>elem</span> <span class=o>*</span> <span class=n>t</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>member</span> <span class=n>x</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Empty</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>0</span> 
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=n>member</span> <span class=n>x</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&gt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=n>member</span> <span class=n>x</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=bp>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>balance</span> <span class=n>color</span> <span class=n>left</span> <span class=n>v</span> <span class=n>right</span> <span class=o>=</span> <span class=k>match</span> <span class=n>color</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Black</span><span class=o>,</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>b</span><span class=o>),</span> <span class=n>y</span><span class=o>,</span> <span class=n>c</span><span class=o>)),</span> <span class=n>z</span><span class=o>,</span> <span class=n>d</span>       <span class=c>(* left-left case   *)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Black</span><span class=o>,</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>b</span><span class=o>,</span> <span class=n>y</span><span class=o>,</span> <span class=n>c</span><span class=o>))),</span> <span class=n>z</span><span class=o>,</span> <span class=n>d</span>       <span class=c>(* left-right case  *)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Black</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>b</span><span class=o>,</span> <span class=n>y</span><span class=o>,</span> <span class=n>c</span><span class=o>),</span> <span class=n>z</span><span class=o>,</span> <span class=n>d</span><span class=o>))</span>       <span class=c>(* right-left case  *)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Black</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>b</span><span class=o>,</span> <span class=n>y</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=n>c</span><span class=o>,</span> <span class=n>z</span><span class=o>,</span> <span class=n>d</span><span class=o>)))</span> <span class=o>-&gt;</span>    <span class=c>(* right-right case *)</span>
</span></span><span class=line><span class=cl>      <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Black</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>b</span><span class=o>),</span> <span class=n>y</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Black</span><span class=o>,</span> <span class=n>c</span><span class=o>,</span> <span class=n>z</span><span class=o>,</span> <span class=n>d</span><span class=o>))</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=o>_</span> <span class=k>as</span> <span class=n>tuple</span> <span class=o>-&gt;</span> <span class=nc>Node</span> <span class=n>tuple</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>insert</span> <span class=n>x</span> <span class=n>tree</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=k>rec</span> <span class=n>aux</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Empty</span> <span class=o>-&gt;</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Red</span><span class=o>,</span> <span class=nc>Empty</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=nc>Empty</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>color</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>        <span class=k>then</span> <span class=n>balance</span> <span class=n>color</span> <span class=o>(</span><span class=n>aux</span> <span class=n>left</span><span class=o>)</span> <span class=n>v</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>x</span> <span class=n>v</span> <span class=o>&gt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>        <span class=k>then</span> <span class=n>balance</span> <span class=n>color</span> <span class=n>left</span> <span class=n>v</span> <span class=o>(</span><span class=n>aux</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>    <span class=k>in</span> <span class=k>match</span> <span class=o>(</span><span class=n>aux</span> <span class=n>tree</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Black</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Empty</span> <span class=o>-&gt;</span> <span class=nc>Empty</span>  <span class=c>(* have no sense except avoid warning *)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>Even without optimization, this implementation of balanced binary search trees is one of the fastest around. With appropriate
optimizations, such as eliminating comparison (we have done this before) and eliminating redundant testing(while recursing
on the left child their is no need for red-red violations involving the right child)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.sdlinks.net/tags/ocaml/>OCaml</a></li><li><a href=https://www.sdlinks.net/tags/functional/>Functional</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 1 on x" href="https://x.com/intent/tweet/?text=Functional%20Data%20Structure%201&amp;url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-1%2f&amp;hashtags=OCaml%2cFunctional"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 1 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-1%2f&amp;title=Functional%20Data%20Structure%201&amp;summary=Functional%20Data%20Structure%201&amp;source=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 1 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-1%2f&title=Functional%20Data%20Structure%201"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 1 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 1 on whatsapp" href="https://api.whatsapp.com/send?text=Functional%20Data%20Structure%201%20-%20https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 1 on telegram" href="https://telegram.me/share/url?text=Functional%20Data%20Structure%201&amp;url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 1 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Functional%20Data%20Structure%201&u=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=Christophe1997/blog data-repo-id="MDEwOlJlcG9zaXRvcnkyMjU4MTQyMTM=" data-category=Announcements data-category-id=DIC_kwDODXWmxc4CmuF3 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2026 <a href=https://www.sdlinks.net/>Neo VRAINS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>