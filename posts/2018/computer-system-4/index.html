<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer System 4 | CastOff</title>
<meta name=keywords content="System"><meta name=description content="Linking
Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded
(copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into
machine code; at load time, when the program is loaded into memory and executed by the loader; and even at run time, by
application programs. On modern systems, linking is performed automatically by programs called linkers."><meta name=author content="Christophe"><link rel=canonical href=http://www.sdlinks.net/posts/2018/computer-system-4/><meta name=google-site-verification content="CastOff"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://www.sdlinks.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://www.sdlinks.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://www.sdlinks.net/favicon-32x32.png><link rel=apple-touch-icon href=http://www.sdlinks.net/apple-touch-icon.png><link rel=mask-icon href=http://www.sdlinks.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://www.sdlinks.net/posts/2018/computer-system-4/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/katex.min.css><script defer src=/js/katex.min.js></script><script defer src=/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="http://www.sdlinks.net/posts/2018/computer-system-4/"><meta property="og:site_name" content="CastOff"><meta property="og:title" content="Computer System 4"><meta property="og:description" content="Linking Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into machine code; at load time, when the program is loaded into memory and executed by the loader; and even at run time, by application programs. On modern systems, linking is performed automatically by programs called linkers."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-10T19:14:22+00:00"><meta property="article:modified_time" content="2018-06-10T19:14:22+00:00"><meta property="article:tag" content="System"><meta name=twitter:card content="summary"><meta name=twitter:title content="Computer System 4"><meta name=twitter:description content="Linking
Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded
(copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into
machine code; at load time, when the program is loaded into memory and executed by the loader; and even at run time, by
application programs. On modern systems, linking is performed automatically by programs called linkers."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://www.sdlinks.net/posts/"},{"@type":"ListItem","position":2,"name":"Computer System 4","item":"http://www.sdlinks.net/posts/2018/computer-system-4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Computer System 4","name":"Computer System 4","description":"Linking Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into machine code; at load time, when the program is loaded into memory and executed by the loader; and even at run time, by application programs. On modern systems, linking is performed automatically by programs called linkers.\n","keywords":["System"],"articleBody":"Linking Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into machine code; at load time, when the program is loaded into memory and executed by the loader; and even at run time, by application programs. On modern systems, linking is performed automatically by programs called linkers.\nStatic linking Static linker such as the Unix ld program take as input a collection of relocatable object files and command-line arguments and generate as output a fully linked executable object file that can be loaded and run. To build the executable, the linker must perform two main tasks:\nSymbol resolution. Object files define and reference symbols. The purpose of symbol resolution is to associate each symbol reference with exactly one symbol definition. Relocation. Compilers and assemblers generate code and data sections that start at address 0. The linker relocates these sections by associating a memory location with each symbol definition, and then modifying all of the references to those symbols so that they point to this memory location. Object file Object files are merely collections of blocks of bytes, it comes in three forms:\nRelocatable object file. Contains binary code and data in a form that can be combined with other relocatable object files at compile time to create an executable object file. Executable object file. Contains binary code and datain a form that can be copied directly into momory and executed. Shared object file. A special type of relocatable object file that can be loaded into memory and linked dynamically, at either load time or run time. Modern x86-64 Linux and Unix system use Executable and Linkable Formate(ELF) to format object file, A typical ELF relocatable object file contains the following sections:\n.text: The machine code of the compiled program. .rodata: Read-only data such as the format strings in printf statements, and jump tables for switch statements. .data: Initialized global C variables. .bss: Uninitialized global C variables. This section occupies no actual space in the object file; it is merely a place holder. .symtab: A symbol table with information about functions and global variables that are defined and referenced in the program. .rel.text: A list of locations in the .text section that will need to be modified when the linker combines this object file with others. .rel.data: Relocation information for any global variables that are referenced or defined by the module. .debug: A debugging symbol table with entries for local variables and typedefs defined in the program, global variables defined and referenced in the program, and the original C source file. .line: A mapping between line numbers in the original C source program and machine code instructions in the .text section. .strtab: A string table for the symbol tables in the .symtab and .debug sections, and for the section names in the section headers. The .debug and .line sections only present if the compiler driver is invoked with the -g option.\nSymbol Each relocatable object module m, has a symbol table that contains information about the symbols that are defined and referenced by m. In the context of a linker, there are three different kinds of symbols:\nGlobal symbols that are defined by module m and that can be referenced by other modules. Global linker symbols correspond to nonstatic C functions and global variables that are defined without the C static attribute. externals that are the Global symbols referenced by module m but defined by some other module. Local symbols that are defined and referenced exclusively by module m. Some local linker symbols correspond to C functions and global variables that are defined with the static attribute. These symbols are visible anywhere within module m, but cannot be referenced by other modules. Interestingly, local procedure variables that are defined with the C static attribute are not managed on the stack. Instead, the compiler allocates space in .data or .bss for each definition and creates a local linker symbol in the symbol table with a unique name.\nSymbol tables are built by assemblers, using symbols exported by the compiler into the assembly-language .s file, it contains an array of entries, each entry has the format below:\n1 2 3 4 5 6 7 8 9 typedef struct { int name; /* String table offset */ char type:4, /* Function or data (4 bits) */ binding:4; /* Local or global (4 bits) */ char reserved; /* Unused */ short section; /* Section header index */ long value; /* Section offset, or absolute address */ long size; /* Object size in bytes */ } Elf64_Symbol; The linker resolves symbol references by associating each reference with exactly one symbol definition from the symbol tables of its input relocatable object files. It’s much easy to reference local symbols than global symbols.The compiler allows only one definition of each local symbol per module. Overloaded functions in C++ and Java work because the compiler encodes each unique method and parameter list combination into a unique name for the linker, which is known as mangling.\nAt compile time, the compiler exports each global symbol to the assembler as either strong or weak, and the assembler encodes this information implicitly in the symbol table of the relocatable object file. Functions and initialized global variables get strong symbols. Uninitialized global variables get weak symbols. Given this notion of string and weak symbols, Unix linkers use the following rules for dealing with multiply defined:\nMultiple strong symbols are not allowed. Given a strong symbol and multiple weak symbols, choose the strong symbol. Given multiple weak symbols, choose any of the weak symbols. Exceptional Control Flow Exceptions can be divided into four classes: interrupts, traps, faults and aborts.\nInterrupts occur asynchronously as a result of signals from I/O devices that are external to the processor. Exception handlers for hardware interrupts are often called interrupt handlers. After the current instruction finishes executing, the processor notices that the interrupt pin has gone high, reads the exception number from the system bus, and then calls the appropriate interrupt handler. When the handler return, it returns control to next instruction. The remaining classes of exceptions(traps, falusts and aborts) occur synchronously as a result of executing the current instruction. We refer to this instruction as the faluting instruction.\nTraps are intentional exceptions that occur as a result of executing an instruction. The most import use of traps is to provide a procedure-like interface between user programs and the kernel known as system call. From a programmer’s perspective, a system call is identical to a regular function call. However, regular functions run in user mode, which restricts the types of instructions they can execute, and they acess the same stack as the calling function, while a system call runs in kernel mode, which allows it to execute instructions, and accesses a stack defined in the kernel.\nFaults result from error conditions that a handler might be able to correct. When a fault occurs, the processor transfers control to the fault handler. If the handler is able to correct the error condition, it returns control to the faulting instruction, thereby reexecuting it. Otherwise, the handler returns to an abort routine in the kernel that terminates the application program that caused the fault.\nAborts result from unrecoverable faltal errors, typically hardware errors.\nx86-64 system has up to 256 different exception types. Numbers in the range from 0 to 31 corresnpond to execeptions that are defined by Intel, while numbers in the range from 32 to 255 correspond to interrupts and traps that are defined by the operating system.\nProcesses Exceptions are the basic building blocks that allow the operating system to provide the notion of a process, one of the most profound and successful ideas in computer science. The classic definition of a process is an instance of a program in execution. A process provides two key abstractions: An independent logical control flow and A private address space.\nUnix provides a number of system calls for manipulating processes from C programs. Each process has a unique positive (nonzero) process ID (PID). The getpid function returns the PID of the calling process. The getppid function returns the PID of its parent. The fork function creates a new running child process. The fork function is called once but returns twice: once in the calling process (the parent), and once in the newly created child process. In the parent, fork returns the PID of the child. In the child, fork returns a value of 0. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include #include #include #include int main () { pid_t pid; int x = 1; pid = fork(); if (pid == 0) { printf(\"child : x=%d\\n\", ++x); exit(0); } printf(\"parent: x=%d\\n\", --x); exit(0); } And it’s result in Unix system is\nparent: x=0 child: x=2 Here you can see the fork function call once, return twice. And the parent and the child are sperate processes that run concurrently, we can never make assumptions about the order of the two process. Those two process also share duplicate but separate address spaces, they both have x equals to 1, but they do different things to x sperately. Also they share files, that means the child process inherits all of parent’s open files.\nCommon memory-related bugs in C Dereference bad pointers: If we attempt to dereference a pointer into the unmapped virtual address or the read-only areas and write, the operating system will terminate the program with a segmentation exception. But if the address is legal, then it will never report a problem, which usually cause baffling consequences.\nRead uninitialized memory: While bss memory locations(such as unintialized global C variables) are always initialized to zero by the loader, this is not true for heap memory. You should always zero it explicitly or use calloc.\nAllow stack buffer overflows: A program has a buffer overflow bug if it writes to a target buffer on the stack without examining the size of the input string.\nAssume that pointers and the objects they point to are the same size, It is always incorrect.\nMake off-by-one errors: index out of range.\nReference a pointer instead of the object it points to.\nMisunderstande pointer arithmetic.\nReference nonexistent variables: always means return a pointer point to the local variable.\nReference data in free heap blocks: reference the data after it frees.\nIntroduce memory leaks: memory leaks are particularly serious for programs such as daemons and servers, which by definition never terminate.\nSystem-level I/O A Unix file is a sequence of m bytes: $$ B_0, B_1, \\cdots, B_k, \\cdots, B_{m-1} $$ All I/O devices, such as networks, disks, and terminals, are modeled as files, and all input and output is performed by reading and writing the appropriate files.This elegant mapping of devices to files allows the Unix kernel to export a simple, lowlevel application interface, known as Unix I/O, that enables all input and output to be performed in a uniform and consistent way:\nOpening files. Changing the current file position. Reading and writing files. Closing files. Every Unix file has a type to show their role in system:\nregular file contains any data, applications always need to distinguish between text file and binary file. directory contains a set of links. Each link maps a filename to a file. “.” links the directory itself, and “..” links the parent directory. socket is used for cross-network communication. and so on(named pipe, symbolic link). Every process have a current working directory in its context to refer the work location. ","wordCount":"1952","inLanguage":"en","datePublished":"2018-06-10T19:14:22Z","dateModified":"2018-06-10T19:14:22Z","author":{"@type":"Person","name":"Christophe"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://www.sdlinks.net/posts/2018/computer-system-4/"},"publisher":{"@type":"Organization","name":"CastOff","logo":{"@type":"ImageObject","url":"http://www.sdlinks.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://www.sdlinks.net/ accesskey=h title="CastOff (Alt + H)">CastOff</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://www.sdlinks.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://www.sdlinks.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://www.sdlinks.net/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Computer System 4</h1><div class=post-meta><span title='2018-06-10 19:14:22 +0000 UTC'>June 10, 2018</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Christophe</div></header><div class=post-content><h2 id=linking>Linking<a hidden class=anchor aria-hidden=true href=#linking>#</a></h2><p>Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded
(copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into
machine code; at load time, when the program is loaded into memory and executed by the <em>loader</em>; and even at run time, by
application programs. On modern systems, linking is performed automatically by programs called <em>linkers</em>.</p><h3 id=static-linking>Static linking<a hidden class=anchor aria-hidden=true href=#static-linking>#</a></h3><p><em>Static linker</em> such as the Unix ld program take as input a collection of relocatable object files and command-line arguments
and generate as output a fully linked executable object file that can be loaded and run. To build the executable, the
linker must perform two main tasks:</p><ol><li><em>Symbol resolution</em>. Object files define and reference symbols. The purpose of symbol resolution is to associate each
symbol reference with exactly one symbol definition.</li><li><em>Relocation</em>. Compilers and assemblers generate code and data sections that start at address 0. The linker <em>relocates</em>
these sections by associating a memory location with each symbol definition, and then modifying all of the references
to those symbols so that they point to this memory location.</li></ol><h3 id=object-file>Object file<a hidden class=anchor aria-hidden=true href=#object-file>#</a></h3><p>Object files are merely collections of blocks of bytes, it comes in three forms:</p><ul><li><em>Relocatable object file</em>. Contains binary code and data in a form that can be combined with other relocatable object
files at compile time to create an executable object file.</li><li><em>Executable object file</em>. Contains binary code and datain a form that can be copied directly into momory and executed.</li><li><em>Shared object file</em>. A special type of relocatable object file that can be loaded into memory and linked dynamically,
at either load time or run time.</li></ul><p>Modern x86-64 Linux and Unix system use <em>Executable and Linkable Formate</em>(ELF) to format object file, A typical ELF
relocatable object file contains the following sections:</p><ul><li>.text: The machine code of the compiled program.</li><li>.rodata: Read-only data such as the format strings in printf statements, and jump tables for switch statements.</li><li>.data: Initialized global C variables.</li><li>.bss: Uninitialized global C variables. This section occupies no actual space in the object file; it is merely a place
holder.</li><li>.symtab: A symbol table with information about functions and global variables that are defined and referenced in the
program.</li><li>.rel.text: A list of locations in the .text section that will need to be modified when the linker combines this object
file with others.</li><li>.rel.data: Relocation information for any global variables that are referenced or defined by the module.</li><li>.debug: A debugging symbol table with entries for local variables and typedefs defined in the program, global variables
defined and referenced in the program, and the original C source file.</li><li>.line: A mapping between line numbers in the original C source program and machine code instructions in the .text section.</li><li>.strtab: A string table for the symbol tables in the .symtab and .debug sections, and for the section names in the
section headers.</li></ul><p>The .debug and .line sections only present if the compiler driver is invoked with the -g option.</p><h3 id=symbol>Symbol<a hidden class=anchor aria-hidden=true href=#symbol>#</a></h3><p>Each relocatable object module m, has a symbol table that contains information about the symbols that are defined and
referenced by m. In the context of a linker, there are three different kinds of symbols:</p><ul><li><em>Global symbols</em> that are defined by module m and that can be referenced by other modules. Global linker symbols
correspond to <em>nonstatic</em> C functions and global variables that are defined without the C <code>static</code> attribute.</li><li><em>externals</em> that are the Global symbols referenced by module m but defined by some other module.</li><li><em>Local symbols</em> that are defined and referenced exclusively by module m. Some local linker symbols correspond to C
functions and global variables that are defined with the <code>static</code> attribute. These symbols are visible anywhere within
module m, but cannot be referenced by other modules.</li></ul><p>Interestingly, local procedure variables that are defined with the C static attribute are not managed on the stack.
Instead, the compiler allocates space in .data or .bss for each definition and creates a local linker symbol in the
symbol table with a unique name.</p><p>Symbol tables are built by assemblers, using symbols exported by the compiler into the assembly-language .s file, it
contains an array of entries, each entry has the format below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>name</span><span class=p>;</span>           <span class=cm>/* String table offset */</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=nl>type</span><span class=p>:</span><span class=mi>4</span><span class=p>,</span>        <span class=cm>/* Function or data (4 bits) */</span>
</span></span><span class=line><span class=cl>     <span class=nl>binding</span><span class=p>:</span><span class=mi>4</span><span class=p>;</span>     <span class=cm>/* Local or global (4 bits) */</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>reserved</span><span class=p>;</span>      <span class=cm>/* Unused */</span>
</span></span><span class=line><span class=cl><span class=kt>short</span> <span class=n>section</span><span class=p>;</span>      <span class=cm>/* Section header index */</span>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=n>value</span><span class=p>;</span>          <span class=cm>/* Section offset, or absolute address */</span>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=n>size</span><span class=p>;</span>           <span class=cm>/* Object size in bytes */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Symbol</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>The linker resolves symbol references by associating each reference with exactly one symbol definition from the symbol
tables of its input relocatable object files. It&rsquo;s much easy to reference local symbols than global symbols.The compiler
allows only one definition of each local symbol per module. Overloaded functions in C++ and Java work because the compiler
encodes each unique method and parameter list combination into a unique name for the linker, which is known as mangling.</p><p>At compile time, the compiler exports each global symbol to the assembler as either <em>strong</em> or <em>weak</em>, and the assembler
encodes this information implicitly in the symbol table of the relocatable object file. Functions and initialized global
variables get strong symbols. Uninitialized global variables get weak symbols. Given this notion of string and weak symbols,
Unix linkers use the following rules for dealing with multiply defined:</p><ol><li>Multiple strong symbols are not allowed.</li><li>Given a strong symbol and multiple weak symbols, choose the strong symbol.</li><li>Given multiple weak symbols, choose any of the weak symbols.</li></ol><h2 id=exceptional-control-flow>Exceptional Control Flow<a hidden class=anchor aria-hidden=true href=#exceptional-control-flow>#</a></h2><p>Exceptions can be divided into four classes: <em>interrupts</em>, <em>traps</em>, <em>faults</em> and <em>aborts</em>.</p><p><em>Interrupts</em> occur asynchronously as a result of signals from I/O devices that are external to the processor. Exception
handlers for hardware interrupts are often called <em>interrupt handlers</em>. After the current instruction finishes executing,
the processor notices that the interrupt pin has gone high, reads the exception number from the system bus, and then calls
the appropriate interrupt handler. When the handler return, it returns control to next instruction. The remaining classes
of exceptions(traps, falusts and aborts) occur synchronously as a result of executing the current instruction. We refer
to this instruction as the <em>faluting instruction</em>.</p><p><em>Traps</em> are intentional exceptions that occur as a result of executing an instruction. The most import use of traps is
to provide a procedure-like interface between user programs and the kernel known as <em>system call</em>. From a programmer&rsquo;s
perspective, a system call is identical to a regular function call. However, regular functions run in user mode, which
restricts the types of instructions they can execute, and they acess the same stack as the calling function, while a
system call runs in kernel mode, which allows it to execute instructions, and accesses a stack defined in the kernel.</p><p><em>Faults</em> result from error conditions that a handler might be able to correct. When a fault occurs, the processor
transfers control to the fault handler. If the handler is able to correct the error condition, it returns control to the
faulting instruction, thereby reexecuting it. Otherwise, the handler returns to an abort routine in the kernel that
terminates the application program that caused the fault.</p><p><em>Aborts</em> result from unrecoverable faltal errors, typically hardware errors.</p><p>x86-64 system has up to 256 different exception types. Numbers in the range from 0 to 31 corresnpond to execeptions that
are defined by Intel, while numbers in the range from 32 to 255 correspond to interrupts and traps that are defined by
the operating system.</p><h3 id=processes>Processes<a hidden class=anchor aria-hidden=true href=#processes>#</a></h3><p>Exceptions are the basic building blocks that allow the operating system to provide the notion of a <em>process</em>, one of
the most profound and successful ideas in computer science. The classic definition of a process is an <em>instance of a
program in execution</em>. A process provides two key abstractions: An independent logical control flow and A private address
space.</p><p>Unix provides a number of system calls for manipulating processes from C programs. Each process has a unique positive
(nonzero) process ID (PID). The getpid function returns the PID of the calling process. The getppid function returns the
PID of its parent. The <em>fork</em> function creates a new running child process. The fork function is called once but returns
twice: once in the calling process (the parent), and once in the newly created child process. In the parent, fork returns
the PID of the child. In the child, fork returns a value of 0. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child : x=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>++</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent: x=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>--</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>And it&rsquo;s result in Unix system is</p><pre tabindex=0><code>parent: x=0
child: x=2
</code></pre><p>Here you can see the fork function call once, return twice. And the parent and the child are sperate processes that run
concurrently, we can never make assumptions about the order of the two process. Those two process also share duplicate but
separate address spaces, they both have x equals to 1, but they do different things to x sperately. Also they share files,
that means the child process inherits all of parent&rsquo;s open files.</p><h3 id=common-memory-related-bugs-in-c>Common memory-related bugs in C<a hidden class=anchor aria-hidden=true href=#common-memory-related-bugs-in-c>#</a></h3><ol><li><p>Dereference bad pointers: If we attempt to dereference a pointer into the unmapped virtual address or the read-only
areas and write, the operating system will terminate the program with a segmentation exception. But if the address is
legal, then it will never report a problem, which usually cause baffling consequences.</p></li><li><p>Read uninitialized memory: While bss memory locations(such as unintialized global C variables) are always initialized
to zero by the loader, this is not true for heap memory. You should always zero it explicitly or use calloc.</p></li><li><p>Allow stack buffer overflows: A program has a buffer overflow bug if it writes to a target buffer on the stack without
examining the size of the input string.</p></li><li><p>Assume that pointers and the objects they point to are the same size, It is always incorrect.</p></li><li><p>Make off-by-one errors: index out of range.</p></li><li><p>Reference a pointer instead of the object it points to.</p></li><li><p>Misunderstande pointer arithmetic.</p></li><li><p>Reference nonexistent variables: always means return a pointer point to the local variable.</p></li><li><p>Reference data in free heap blocks: reference the data after it frees.</p></li><li><p>Introduce memory leaks: memory leaks are particularly serious for programs such as daemons and servers, which by
definition never terminate.</p></li></ol><h2 id=system-level-io>System-level I/O<a hidden class=anchor aria-hidden=true href=#system-level-io>#</a></h2><p>A Unix file is a sequence of m bytes:
$$ B_0, B_1, \cdots, B_k, \cdots, B_{m-1} $$
All I/O devices, such as networks, disks, and terminals, are modeled as files, and all input and output is performed by
reading and writing the appropriate files.This elegant mapping of devices to files allows the Unix kernel to export a
simple, lowlevel application interface, known as Unix I/O, that enables all input and output to be performed in a uniform
and consistent way:</p><ol><li>Opening files.</li><li>Changing the current file position.</li><li>Reading and writing files.</li><li>Closing files.</li></ol><p>Every Unix file has a type to show their role in system:</p><ol><li><em>regular file</em> contains any data, applications always need to distinguish between text file and binary file.</li><li><em>directory</em> contains a set of links. Each link maps a filename to a file. &ldquo;.&rdquo; links the directory itself, and &ldquo;..&rdquo;
links the parent directory.</li><li><em>socket</em> is used for cross-network communication.
and so on(named pipe, symbolic link). Every process have a <em>current working directory</em> in its context to refer the work
location.</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=http://www.sdlinks.net/tags/system/>System</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 4 on x" href="https://x.com/intent/tweet/?text=Computer%20System%204&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-4%2f&amp;hashtags=System"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 4 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-4%2f&amp;title=Computer%20System%204&amp;summary=Computer%20System%204&amp;source=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 4 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-4%2f&title=Computer%20System%204"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 4 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 4 on whatsapp" href="https://api.whatsapp.com/send?text=Computer%20System%204%20-%20http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 4 on telegram" href="https://telegram.me/share/url?text=Computer%20System%204&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-4%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 4 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Computer%20System%204&u=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-4%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=Christophe1997/blog data-repo-id="MDEwOlJlcG9zaXRvcnkyMjU4MTQyMTM=" data-category=Announcements data-category-id=DIC_kwDODXWmxc4CmuF3 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=http://www.sdlinks.net/>CastOff</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>