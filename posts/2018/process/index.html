<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>进程 | CastOff</title>
<meta name=keywords content="System"><meta name=description content="The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be
included in any interface of an operating system:

create
destroy
wait
miscellaneous control, most OS provide some kind of method to suspend a process and resume it.
status, there are usually interfaces to get some status information about a process.

The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address
space of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to
do before running the process. Some memory must be allocated for the program&rsquo;s run-time stack, and the OS may also
allocate smoe memory for the program&rsquo;s heap. Also, the os will do some other intialization tasks, particularly as related
to I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error."><meta name=author content="Christophe"><link rel=canonical href=http://www.sdlinks.net/posts/2018/process/><meta name=google-site-verification content="CastOff"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://www.sdlinks.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://www.sdlinks.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://www.sdlinks.net/favicon-32x32.png><link rel=apple-touch-icon href=http://www.sdlinks.net/apple-touch-icon.png><link rel=mask-icon href=http://www.sdlinks.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://www.sdlinks.net/posts/2018/process/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://www.sdlinks.net/posts/2018/process/"><meta property="og:site_name" content="CastOff"><meta property="og:title" content="进程"><meta property="og:description" content="The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be included in any interface of an operating system:
create destroy wait miscellaneous control, most OS provide some kind of method to suspend a process and resume it. status, there are usually interfaces to get some status information about a process. The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address space of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack, and the OS may also allocate smoe memory for the program’s heap. Also, the os will do some other intialization tasks, particularly as related to I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-03T13:10:58+00:00"><meta property="article:modified_time" content="2018-08-03T13:10:58+00:00"><meta property="article:tag" content="System"><meta name=twitter:card content="summary"><meta name=twitter:title content="进程"><meta name=twitter:description content="The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be
included in any interface of an operating system:

create
destroy
wait
miscellaneous control, most OS provide some kind of method to suspend a process and resume it.
status, there are usually interfaces to get some status information about a process.

The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address
space of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to
do before running the process. Some memory must be allocated for the program&rsquo;s run-time stack, and the OS may also
allocate smoe memory for the program&rsquo;s heap. Also, the os will do some other intialization tasks, particularly as related
to I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://www.sdlinks.net/posts/"},{"@type":"ListItem","position":2,"name":"进程","item":"http://www.sdlinks.net/posts/2018/process/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"进程","name":"进程","description":"The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be included in any interface of an operating system:\ncreate destroy wait miscellaneous control, most OS provide some kind of method to suspend a process and resume it. status, there are usually interfaces to get some status information about a process. The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address space of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to do before running the process. Some memory must be allocated for the program\u0026rsquo;s run-time stack, and the OS may also allocate smoe memory for the program\u0026rsquo;s heap. Also, the os will do some other intialization tasks, particularly as related to I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error.\n","keywords":["System"],"articleBody":"The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be included in any interface of an operating system:\ncreate destroy wait miscellaneous control, most OS provide some kind of method to suspend a process and resume it. status, there are usually interfaces to get some status information about a process. The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address space of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack, and the OS may also allocate smoe memory for the program’s heap. Also, the os will do some other intialization tasks, particularly as related to I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error.\nAt any time a process may be running, ready or blocked. Being moved from ready to running means the process has been scheduled and descheduled in contrast. Once a process has become blocked, the OS will keep it as such until some event occurs; at that point, the process moves to the ready state again.\nThe OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. For example, the tracked information about each process in xv6 kernel is shown below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // the registers xv6 will save and restore to stop and subsequently restart a process struct context { int eip; int esp; int ebx; int ecx; int edx; int esi; int edi; int ebp; }; // the different states a process can be in enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; // the information xv6 tracks about each process including its register context and state struct proc { char *mem; // Start of process memory uint sz; // Size of process memory char *kstack; // Bottom of kernel stack for this process enum proc_state state; // Process state int pid; // Process ID struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory struct context context; // Switch here to run process struct trapframe *tf; // Trap frame for the current interrupt }; Process API Unix presents one of the most intriguing ways to create a new process with a pair of system calls: fork() and exec(). wait() can be used by a process wishing to wait for a process it has created to complete.\nThe fork() creates a process as an(almost) exact copy of the calling process, that means that to the OS, it now looks like there are two copies of the program(the caller) running, and both are about to return from the fork() system call. The newly-created process doesn’t run the main() again, instead it just comes into life as if it had called fork() itself. To distinguish parent and child, the fork() return non-negative PID in parent process, and return 0 in child process, and if it return a negative number, that means it failed. Now there are now two active processes in the system after calling fork, and it’s non-determinism to know which runs first.\nSometimes, it’s useful for a parent to wait a child process to finish what it has been doing, this is accomplished with the wait() system call. the process calls wait() to delay its execution, most until the child has run and exited. When wait() return into parent, returns the PID of child.\nBy giving a name of an executable to exec()(i.e. execvp), it loads code from that executable and overwrites its current code segment with it. The heap and stack and other parts of the memory space of the program are re-initialized. Then the OS simply runs that program, passing in any arguments as the argv of that process. Thus it does not create a new process, rather, it transforms the currently running program into a different running program. A successful call to exec never returns.\nThe spearation of fork() and exec() is essential in building a Unix shell, because it lets the shell run code after the call to fork() but before the call to exec(). For example, shell can redirect the output from stdout to a new file. The way the shell accomplishes this task is quite simple: when the child is created, before calling exec(), the shell closes standard output and open the file, thus any output from the soon-to-be-running program are sent to the file instead of the screen. This works because Unix system start looking for free file descriptors at zero, in this case, STDOUT_FILENO will be the first available one and thus get assigned when open() is called. Subsequent writes by the child process to the standard output file descriptor(i.e. printf) will then be routed transparently to the newly-opened file.\nLimited Direct Execution In order to virtualize the CPU, the operating system needs to somehow share the physical CPU among many jobs running seemingly at the same time. The basic idea is simple: run one process for a little while, then run another one, and so forth.\nTo make a program run as fast as one might expect, not surprisingly OS developers came up with a technique, which we call limited direct execution. The direct execution means run the program directly on the CPU, but only “direct execution” is not enough, the OS need to prevent what we don’t want it to do, thus we need “limited”.\nThere are two phases in the limited direct execution protocol. In the first(at boot time), the kernel initializes the trap table, and the CPU remembers its location for subsequent use. The kernel does so via a privileged instruction. In the second(when running a process), the kernel sets up a few things before using a return-from-trap instruction to start the execution of the process; this switches the CPU to user mode and begins running the process. When the process wishes to issue a system call, it traps back into the OS, which handles it and once again returns control via a return-from-trap to the process. The process then completes its work, and returns from main(); this usually will return into some stub code which will properly exit the program. At this point, the OS cleans up and we are done.\nIf a process is running on the CPU, this means the OS is not running. So there is a problem that how can OS regain control of the CPU so that it can switch between processes. One old way is waiting system call but the OS can not do much at all if the process refuses to make system call. Another way is to add a timer interrupt, a timer device can be programmed to raise an interrupt every so many milliseconds; when the interrupt is raised, the currently running process is halted, and a pre-configured interrupt handler in the OS runs. At this point, the OS has regained control of the CPU.\nScheduling Policies There are many scheduling algorithms, such as FIFO(first in first out), STCF(shortest time-to-completion first). Choosing which algorithm dependent on which metrics are used. One most well-known approaches to scheduling, known as the Multi-level feedback queue. The MLFQ has a number of distinct queues, each assigned a different priority level. At any given time, a job that is ready to run is on a single queue. And a job with higher priority is chosen to run first. If two jobs have the same priority, we can use round-robin scheduling. The key to MLFQ scheduling therefore lies in how scheduler sets priorities. Rather than giving a fixed priority to each job, MLFQ varies the priority of a job based on its observed behavior. If, for example, a job repeatedly relinquishes the CPU while waiting for input from the keyboard, MLFQ will keep its priority high, as this is how an interactive process might behave.\nMLFQ first assumes the arrived job as a short job, thus giving the job high priority. If it actually is a short job, then it runs quickly and complete, if not, MLFQ slowly move down its priority. And a simple MLFQ rules may be:\nIf Priority(A) \u003e Priority(B), A runs. If Priority(A) = Priority(B), A\u0026B run in round-robin. when a job enters the system, it is placed at the highest priority. Once a job uses up its time allotment at a given level, its priority is reduced. after some time period S, move all the jobs in the system to the topmost queue. Another scheduling policy is lottery scheduling as a proporitional-share scheduling, the basic idea is simple: every so often, hold a lottery to determine which process should get to run next; process that should run more often should be given more chances to win the lottery(to be continued).\n","wordCount":"1550","inLanguage":"en","datePublished":"2018-08-03T13:10:58Z","dateModified":"2018-08-03T13:10:58Z","author":{"@type":"Person","name":"Christophe"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://www.sdlinks.net/posts/2018/process/"},"publisher":{"@type":"Organization","name":"CastOff","logo":{"@type":"ImageObject","url":"http://www.sdlinks.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://www.sdlinks.net/ accesskey=h title="CastOff (Alt + H)">CastOff</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://www.sdlinks.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://www.sdlinks.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://www.sdlinks.net/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">进程</h1><div class=post-meta><span title='2018-08-03 13:10:58 +0000 UTC'>August 3, 2018</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Christophe</div></header><div class=post-content><p>The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be
included in any interface of an operating system:</p><ol><li>create</li><li>destroy</li><li>wait</li><li>miscellaneous control, most OS provide some kind of method to suspend a process and resume it.</li><li>status, there are usually interfaces to get some status information about a process.</li></ol><p>The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address
space of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to
do before running the process. Some memory must be allocated for the program&rsquo;s <em>run-time stack</em>, and the OS may also
allocate smoe memory for the program&rsquo;s heap. Also, the os will do some other intialization tasks, particularly as related
to I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error.</p><p>At any time a process may be <em>running</em>, <em>ready</em> or <em>blocked</em>. Being moved from ready to running means the process has been
<em>scheduled</em> and <em>descheduled</em> in contrast. Once a process has become blocked, the OS will keep it as such until some event
occurs; at that point, the process moves to the ready state again.</p><p>The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information.
For example, the tracked information about each process in xv6 kernel is shown below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// the registers xv6 will save and restore to stop and subsequently restart a process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>eip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>esp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ebx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ecx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>edx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>esi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>edi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ebp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// the different states a process can be in
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=n>proc_state</span> <span class=p>{</span> <span class=n>UNUSED</span><span class=p>,</span> <span class=n>EMBRYO</span><span class=p>,</span> <span class=n>SLEEPING</span><span class=p>,</span> <span class=n>RUNNABLE</span><span class=p>,</span> <span class=n>RUNNING</span><span class=p>,</span> <span class=n>ZOMBIE</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// the information xv6 tracks about each process including its register context and state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>proc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>mem</span><span class=p>;</span>                   <span class=c1>// Start of process memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>uint</span> <span class=n>sz</span><span class=p>;</span>                     <span class=c1>// Size of process memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=o>*</span><span class=n>kstack</span><span class=p>;</span>                <span class=c1>// Bottom of kernel stack for this process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>enum</span> <span class=n>proc_state</span> <span class=n>state</span><span class=p>;</span>       <span class=c1>// Process state
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>pid</span><span class=p>;</span>                     <span class=c1>// Process ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>parent</span><span class=p>;</span>         <span class=c1>// Parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>chan</span><span class=p>;</span>                  <span class=c1>// If non-zero, sleeping on chan
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>killed</span><span class=p>;</span>                  <span class=c1>// If non-zero, have been killed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>ofile</span><span class=p>[</span><span class=n>NOFILE</span><span class=p>];</span>  <span class=c1>// Open files
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>cwd</span><span class=p>;</span>           <span class=c1>// Current directory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>context</span> <span class=n>context</span><span class=p>;</span>      <span class=c1>// Switch here to run process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>trapframe</span> <span class=o>*</span><span class=n>tf</span><span class=p>;</span>        <span class=c1>// Trap frame for the current interrupt
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=process-api>Process API<a hidden class=anchor aria-hidden=true href=#process-api>#</a></h2><p>Unix presents one of the most intriguing ways to create a new process with a pair of system calls: <code>fork()</code> and <code>exec()</code>.
<code>wait()</code> can be used by a process wishing to wait for a process it has created to complete.</p><p>The <code>fork()</code> creates a process as an(almost) <em>exact copy of the calling process</em>, that means that to the OS, it now looks
like there are two copies of the program(the caller) running, and both are about to return from the <code>fork()</code> system call.
The newly-created process doesn&rsquo;t run the <code>main()</code> again, instead it just comes into life as if it had called <code>fork()</code>
itself. To distinguish parent and child, the <code>fork()</code> return non-negative PID in parent process, and return 0 in child
process, and if it return a negative number, that means it failed. Now there are now two active processes in the system
after calling fork, and it&rsquo;s non-determinism to know which runs first.</p><p>Sometimes, it&rsquo;s useful for a parent to wait a child process to finish what it has been doing, this is accomplished with
the <code>wait()</code> system call. the process calls <code>wait()</code> to delay its execution, most until the child has run and exited. When
<code>wait()</code> return into parent, returns the PID of child.</p><p>By giving a name of an executable to <code>exec()</code>(i.e. <code>execvp</code>), it loads code from that executable and overwrites its current
code segment with it. The heap and stack and other parts of the memory space of the program are re-initialized. Then the
OS simply runs that program, passing in any arguments as the <code>argv</code> of that process. Thus it does not create a new process,
rather, it transforms the currently running program into a different running program. A successful call to <code>exec</code> never
returns.</p><p>The spearation of <code>fork()</code> and <code>exec()</code> is essential in building a Unix shell, because it lets the shell run code after
the call to <code>fork()</code> but before the call to <code>exec()</code>. For example, shell can redirect the output from stdout to a new file.
The way the shell accomplishes this task is quite simple: when the child is created, before calling <code>exec()</code>, the shell
closes standard output and open the file, thus any output from the soon-to-be-running program are sent to the file instead
of the screen. This works because Unix system start looking for free file descriptors at zero, in this case, <code>STDOUT_FILENO</code>
will be the first available one and thus get assigned when open() is called. Subsequent writes by the child process to
the standard output file descriptor(i.e. printf) will then be routed transparently to the newly-opened file.</p><h2 id=limited-direct-execution>Limited Direct Execution<a hidden class=anchor aria-hidden=true href=#limited-direct-execution>#</a></h2><p>In order to virtualize the CPU, the operating system needs to somehow share the physical CPU among many jobs running
seemingly at the same time. The basic idea is simple: run one process for a little while, then run another one, and so
forth.</p><p>To make a program run as fast as one might expect, not surprisingly OS developers came up with a technique, which we
call <em>limited direct execution</em>. The direct execution means run the program directly on the CPU, but only &ldquo;direct execution&rdquo;
is not enough, the OS need to prevent what we don&rsquo;t want it to do, thus we need &ldquo;limited&rdquo;.</p><p>There are two phases in the limited direct execution protocol. In the first(at boot time), the kernel initializes the
trap table, and the CPU remembers its location for subsequent use. The kernel does so via a privileged instruction. In
the second(when running a process), the kernel sets up a few things before using a return-from-trap instruction to start
the execution of the process; this switches the CPU to user mode and begins running the process. When the process wishes
to issue a system call, it traps back into the OS, which handles it and once again returns control via a return-from-trap
to the process. The process then completes its work, and returns from <code>main()</code>; this usually will return into some stub
code which will properly exit the program. At this point, the OS cleans up and we are done.</p><p>If a process is running on the CPU, this means the OS is not running. So there is a problem that how can OS regain control
of the CPU so that it can switch between processes. One old way is waiting system call but the OS can not do much at all if
the process refuses to make system call. Another way is to add a <em>timer interrupt</em>, a timer device can be programmed to
raise an interrupt every so many milliseconds; when the interrupt is raised, the currently running process is halted, and
a pre-configured interrupt handler in the OS runs. At this point, the OS has regained control of the CPU.</p><h2 id=scheduling-policies>Scheduling Policies<a hidden class=anchor aria-hidden=true href=#scheduling-policies>#</a></h2><p>There are many scheduling algorithms, such as FIFO(first in first out), STCF(shortest time-to-completion first). Choosing
which algorithm dependent on which metrics are used. One most well-known approaches to scheduling, known as the <em>Multi-level
feedback queue</em>. The MLFQ has a number of distinct queues, each assigned a different priority level. At any given time,
a job that is ready to run is on a single queue. And a job with higher priority is chosen to run first. If two jobs have
the same priority, we can use round-robin scheduling. The key to MLFQ scheduling therefore lies in how scheduler sets
priorities. Rather than giving a fixed priority to each job, MLFQ varies the priority of a job based on its observed
behavior. If, for example, a job repeatedly relinquishes the CPU while waiting for input from the keyboard, MLFQ will
keep its priority high, as this is how an interactive process might behave.</p><p>MLFQ first assumes the arrived job as a short job, thus giving the job high priority. If it actually is a short job, then
it runs quickly and complete, if not, MLFQ slowly move down its priority. And a simple MLFQ rules may be:</p><ol><li>If Priority(A) > Priority(B), A runs.</li><li>If Priority(A) = Priority(B), A&amp;B run in round-robin.</li><li>when a job enters the system, it is placed at the highest priority.</li><li>Once a job uses up its time allotment at a given level, its priority is reduced.</li><li>after some time period S, move all the jobs in the system to the topmost queue.</li></ol><p>Another scheduling policy is <em>lottery scheduling</em> as a proporitional-share scheduling, the basic idea is simple: every so
often, hold a lottery to determine which process should get to run next; process that should run more often should be
given more chances to win the lottery(to be continued).</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://www.sdlinks.net/tags/system/>System</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on x" href="https://x.com/intent/tweet/?text=%e8%bf%9b%e7%a8%8b&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fprocess%2f&amp;hashtags=System"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fprocess%2f&amp;title=%e8%bf%9b%e7%a8%8b&amp;summary=%e8%bf%9b%e7%a8%8b&amp;source=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fprocess%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fprocess%2f&title=%e8%bf%9b%e7%a8%8b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fprocess%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on whatsapp" href="https://api.whatsapp.com/send?text=%e8%bf%9b%e7%a8%8b%20-%20http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fprocess%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on telegram" href="https://telegram.me/share/url?text=%e8%bf%9b%e7%a8%8b&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fprocess%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e8%bf%9b%e7%a8%8b&u=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fprocess%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=Christophe1997/blog data-repo-id="MDEwOlJlcG9zaXRvcnkyMjU4MTQyMTM=" data-category=Announcements data-category-id=DIC_kwDODXWmxc4CmuF3 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=http://www.sdlinks.net/>CastOff</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>