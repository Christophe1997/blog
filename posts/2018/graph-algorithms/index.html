<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>图算法 | Neo VRAINS</title>
<meta name=keywords content="Java,Algorithm"><meta name=description content="采用哪种数据结构来表示图, 主要考虑以下两个方面:

必须为可能在应用中碰到的各种类型的图预留出足够的空间, 以及
Graph的实例方法一定要高效.

常见的表示方法有以下几种:

邻接矩阵, 对于有N个顶点的图而言, 邻接矩阵需要$ N^2 $的空间.
边的数组, 通过定义边来定义图, 这种方法在寻找相邻的点时需要遍历整个数组.
邻接表数组, 使用一个顶点为索引的列表数组, 其中每个元素都是和该顶点相邻的顶点列表. 这种结构能够满足上述的两个条件.

常见实现的性能比较(V表示结点数, E表示边数):

  
      
          数据结构
          所需空间
          添加边
          检查顶点是否相邻
          遍历所有相邻顶点
      
  
  
      
          边的列表
          E
          1
          E
          E
      
      
          邻接矩阵
          $ V^2 $
          1
          1
          V
      
      
          邻接表
          E+V
          1
          degree(V)
          degree(V)
      
  

非稠密图的标准表示是邻接表, 这种表示具有以下特性:

使用的空间和V+E成正比,
添加一条边所需要的时间为常数, 以及
遍历顶点v的所有相邻顶点所需要的时间和v的度数成正比.

无向图
无向图只定义了顶点以及顶点之间的关系.
深度优先搜索


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


public class DepthFirstSearch {
    private boolean[] marked;
    private int count;

    public DepthFirstSearch(Graph G, int s) {
        marked = new boolean[G.V()];
        dfs(G, s);
    }

    private void dfs(Graph G, int v) {
        marked[v] = true;
        count++;
        for (int w : G.adj(v)) {
            if (!marked[w]) { dfs(G, w); }
        }
    }

    public boolean marked(int w) { return marked[w]; }

    public int count() { return count; }
}


深度优先搜索能够所有与起点相连的顶点, 且所需时间和所有连通顶点的度数之和成正比."><meta name=author content="Christophe"><link rel=canonical href=https://www.sdlinks.net/posts/2018/graph-algorithms/><meta name=google-site-verification content="Neo VRAINS"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://www.sdlinks.net/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.sdlinks.net/images/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.sdlinks.net/images/favicon-32x32.png><link rel=apple-touch-icon href=https://www.sdlinks.net/images/apple-touch-icon.png><link rel=mask-icon href=https://www.sdlinks.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.sdlinks.net/posts/2018/graph-algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/katex.min.css><script defer src=/js/katex.min.js></script><script defer src=/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RH029G1TZ5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RH029G1TZ5")}</script><meta property="og:url" content="https://www.sdlinks.net/posts/2018/graph-algorithms/"><meta property="og:site_name" content="Neo VRAINS"><meta property="og:title" content="图算法"><meta property="og:description" content="采用哪种数据结构来表示图, 主要考虑以下两个方面:
必须为可能在应用中碰到的各种类型的图预留出足够的空间, 以及 Graph的实例方法一定要高效. 常见的表示方法有以下几种:
邻接矩阵, 对于有N个顶点的图而言, 邻接矩阵需要$ N^2 $的空间. 边的数组, 通过定义边来定义图, 这种方法在寻找相邻的点时需要遍历整个数组. 邻接表数组, 使用一个顶点为索引的列表数组, 其中每个元素都是和该顶点相邻的顶点列表. 这种结构能够满足上述的两个条件. 常见实现的性能比较(V表示结点数, E表示边数):
数据结构 所需空间 添加边 检查顶点是否相邻 遍历所有相邻顶点 边的列表 E 1 E E 邻接矩阵 $ V^2 $ 1 1 V 邻接表 E+V 1 degree(V) degree(V) 非稠密图的标准表示是邻接表, 这种表示具有以下特性:
使用的空间和V+E成正比, 添加一条边所需要的时间为常数, 以及 遍历顶点v的所有相邻顶点所需要的时间和v的度数成正比. 无向图 无向图只定义了顶点以及顶点之间的关系.
深度优先搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class DepthFirstSearch { private boolean[] marked; private int count; public DepthFirstSearch(Graph G, int s) { marked = new boolean[G.V()]; dfs(G, s); } private void dfs(Graph G, int v) { marked[v] = true; count++; for (int w : G.adj(v)) { if (!marked[w]) { dfs(G, w); } } } public boolean marked(int w) { return marked[w]; } public int count() { return count; } } 深度优先搜索能够所有与起点相连的顶点, 且所需时间和所有连通顶点的度数之和成正比."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-04-20T19:21:30+00:00"><meta property="article:modified_time" content="2018-04-20T19:21:30+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Algorithm"><meta name=twitter:card content="summary"><meta name=twitter:title content="图算法"><meta name=twitter:description content="采用哪种数据结构来表示图, 主要考虑以下两个方面:

必须为可能在应用中碰到的各种类型的图预留出足够的空间, 以及
Graph的实例方法一定要高效.

常见的表示方法有以下几种:

邻接矩阵, 对于有N个顶点的图而言, 邻接矩阵需要$ N^2 $的空间.
边的数组, 通过定义边来定义图, 这种方法在寻找相邻的点时需要遍历整个数组.
邻接表数组, 使用一个顶点为索引的列表数组, 其中每个元素都是和该顶点相邻的顶点列表. 这种结构能够满足上述的两个条件.

常见实现的性能比较(V表示结点数, E表示边数):

  
      
          数据结构
          所需空间
          添加边
          检查顶点是否相邻
          遍历所有相邻顶点
      
  
  
      
          边的列表
          E
          1
          E
          E
      
      
          邻接矩阵
          $ V^2 $
          1
          1
          V
      
      
          邻接表
          E+V
          1
          degree(V)
          degree(V)
      
  

非稠密图的标准表示是邻接表, 这种表示具有以下特性:

使用的空间和V+E成正比,
添加一条边所需要的时间为常数, 以及
遍历顶点v的所有相邻顶点所需要的时间和v的度数成正比.

无向图
无向图只定义了顶点以及顶点之间的关系.
深度优先搜索


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


public class DepthFirstSearch {
    private boolean[] marked;
    private int count;

    public DepthFirstSearch(Graph G, int s) {
        marked = new boolean[G.V()];
        dfs(G, s);
    }

    private void dfs(Graph G, int v) {
        marked[v] = true;
        count++;
        for (int w : G.adj(v)) {
            if (!marked[w]) { dfs(G, w); }
        }
    }

    public boolean marked(int w) { return marked[w]; }

    public int count() { return count; }
}


深度优先搜索能够所有与起点相连的顶点, 且所需时间和所有连通顶点的度数之和成正比."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.sdlinks.net/posts/"},{"@type":"ListItem","position":2,"name":"图算法","item":"https://www.sdlinks.net/posts/2018/graph-algorithms/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"图算法","name":"图算法","description":"采用哪种数据结构来表示图, 主要考虑以下两个方面:\n必须为可能在应用中碰到的各种类型的图预留出足够的空间, 以及 Graph的实例方法一定要高效. 常见的表示方法有以下几种:\n邻接矩阵, 对于有N个顶点的图而言, 邻接矩阵需要$ N^2 $的空间. 边的数组, 通过定义边来定义图, 这种方法在寻找相邻的点时需要遍历整个数组. 邻接表数组, 使用一个顶点为索引的列表数组, 其中每个元素都是和该顶点相邻的顶点列表. 这种结构能够满足上述的两个条件. 常见实现的性能比较(V表示结点数, E表示边数):\n数据结构 所需空间 添加边 检查顶点是否相邻 遍历所有相邻顶点 边的列表 E 1 E E 邻接矩阵 $ V^2 $ 1 1 V 邻接表 E+V 1 degree(V) degree(V) 非稠密图的标准表示是邻接表, 这种表示具有以下特性:\n使用的空间和V+E成正比, 添加一条边所需要的时间为常数, 以及 遍历顶点v的所有相邻顶点所需要的时间和v的度数成正比. 无向图 无向图只定义了顶点以及顶点之间的关系.\n深度优先搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class DepthFirstSearch { private boolean[] marked; private int count; public DepthFirstSearch(Graph G, int s) { marked = new boolean[G.V()]; dfs(G, s); } private void dfs(Graph G, int v) { marked[v] = true; count++; for (int w : G.adj(v)) { if (!marked[w]) { dfs(G, w); } } } public boolean marked(int w) { return marked[w]; } public int count() { return count; } } 深度优先搜索能够所有与起点相连的顶点, 且所需时间和所有连通顶点的度数之和成正比.\n","keywords":["Java","Algorithm"],"articleBody":"采用哪种数据结构来表示图, 主要考虑以下两个方面:\n必须为可能在应用中碰到的各种类型的图预留出足够的空间, 以及 Graph的实例方法一定要高效. 常见的表示方法有以下几种:\n邻接矩阵, 对于有N个顶点的图而言, 邻接矩阵需要$ N^2 $的空间. 边的数组, 通过定义边来定义图, 这种方法在寻找相邻的点时需要遍历整个数组. 邻接表数组, 使用一个顶点为索引的列表数组, 其中每个元素都是和该顶点相邻的顶点列表. 这种结构能够满足上述的两个条件. 常见实现的性能比较(V表示结点数, E表示边数):\n数据结构 所需空间 添加边 检查顶点是否相邻 遍历所有相邻顶点 边的列表 E 1 E E 邻接矩阵 $ V^2 $ 1 1 V 邻接表 E+V 1 degree(V) degree(V) 非稠密图的标准表示是邻接表, 这种表示具有以下特性:\n使用的空间和V+E成正比, 添加一条边所需要的时间为常数, 以及 遍历顶点v的所有相邻顶点所需要的时间和v的度数成正比. 无向图 无向图只定义了顶点以及顶点之间的关系.\n深度优先搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class DepthFirstSearch { private boolean[] marked; private int count; public DepthFirstSearch(Graph G, int s) { marked = new boolean[G.V()]; dfs(G, s); } private void dfs(Graph G, int v) { marked[v] = true; count++; for (int w : G.adj(v)) { if (!marked[w]) { dfs(G, w); } } } public boolean marked(int w) { return marked[w]; } public int count() { return count; } } 深度优先搜索能够所有与起点相连的顶点, 且所需时间和所有连通顶点的度数之和成正比.\n广度优先搜索 深度优先搜索得到的路径不仅取决于图的结构, 还取决于图的表示和递归调用的性质.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class BreadthFirthSearch { private boolean[] marked; private int count; public BreadthFirthSearch(Graph G, int s) { marked = new boolean[G.V()]; bfs(G, s); } public void bfs(Graph G, int v) { Queue\u003cInteger\u003e queue = new Queue\u003c\u003e(); marked[v] = true; queue.enqueue(v); while (!queue.isEmpty()) { int x = queue.dequeue(); for (int w : G.adj(x)) { if (!marked[w]) { queue.enqueue(w); marked[w] = true; count++; } } } } public boolean marked(int v) { return marked[v]; } public int count() { return count; } } 深度优先搜索与广度优先搜索的差别在于数据结构的不同, 前者使用栈而后者使用队列, 我们在搜索的时候都会将起点加入数据结构, 然后重复以下步骤直到数据结构被 清空:\n取其中的下一个顶点并标记它 将v的所有相邻而又为被标记的顶点加入数据结构 两者的差别只在于数据结构如何获取下一个顶点, 而这种差异导致了图的两者不同视图, 但最终所有与顶点相连的点都会被检查到 有向图 环的检测 有向图常常需要检测是否存在环.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * only for one cycle */ public class DirectedCycle { private boolean[] marked; private int[] edgeTo; private Stack\u003cInteger\u003e cycle; private boolean[] onStack; public DirectedCycle(Digraph G) { onStack = new boolean[G.V()]; edgeTo = new int[G.V()]; marked = new boolean[G.V()]; for (int v = 0; v \u003c G.V(); v++) { if (!marked[v]) { dfs(G, v); } } } private void dfs(Digraph G, int v) { onStack[v] = true; marked[v] = true; for (int w : G.adj(v)) { if (this.hasCycle()) { return; } else if (!marked[w]) { edgeTo[w] = v; dfs(G, w); } else if (onStack[w]) { cycle = new Stack\u003c\u003e(); for (int x = v; x != w; x = edgeTo[x]) { cycle.push(x); } cycle.push(w); cycle.push(v); } } onStack[v] = false; } public boolean hasCycle() { return cycle != null; } public Iterable\u003cInteger\u003e cycle() { return cycle; } } 拓扑排序 拓扑排序是解决优先级限制下任务调度的常见算法, 能否进行拓扑排序的先决条件是是否是有向无环图. 进而问题变为有向无环图中基于深度优先遍历的顶点排序问题, 常见的排序方式有以下三种:\n前序, 在递归调用前将顶点加入队列 后序, 在递归调用之后将顶点加入队列 逆后序, 在递归调用之后将顶点加入栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class DepthFirthOrder { private boolean[] marked; private Queue\u003cInteger\u003e pre; private Queue\u003cInteger\u003e post; private Stack\u003cInteger\u003e reverstPost; public DepthFirthOrder(Digraph G) { marked = new boolean[G.V()]; pre = new Queue\u003c\u003e(); post = new Queue\u003c\u003e(); reverstPost = new Stack\u003c\u003e(); for (int v = 0; v \u003c G.V(); v++) { if (!marked[v]) { dfs(G, v); } } } private void dfs(Digraph G, int v) { marked[v] = true; pre.enqueue(v); for (int w : G.adj(v)) { if (!marked[w]) { dfs(G, w); } } post.enqueue(v); reverstPost.push(v); } public Iterable\u003cInteger\u003e pre() { return pre; } public Iterable\u003cInteger\u003e post() { return post; } public Iterable\u003cInteger\u003e reverstPost() { return reverstPost; } } 进而拓扑排序可以有如下实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Topological { private Iterable\u003cInteger\u003e order; public Topological(Digraph G) { DirectedCycle cycle = new DirectedCycle(G); if (!cycle.hasCycle()) { DepthFirthOrder dfs = new DepthFirthOrder(G); order = dfs.reverstPost(); } } public Iterable\u003cInteger\u003e order() { return order; } public boolean isDAG() { return order != null; } public static void main(String[] args) throws FileNotFoundException { String filename = args[0]; String sp = args[1]; SymbolDigraph sg = new SymbolDigraph(new File(filename), sp); Topological top = new Topological(sg.G()); top.order.forEach(v -\u003e System.out.println(sg.name(v))); } } 这种实现非常简单, 但它被忽略了很多年, 比它更流行的是一种使用队列存储顶点的直观算法:\n初始化一条含有所有起点的队列Q 如果Q为空, 停止, 否则从队列Q中删除一个起点并将其标记; 遍历由被删除顶点指出的所有边, 将被指向的顶点的入度减1; 如果顶点的入度变为0, 将其加入Q; 跳转至2. 加权无向图 加权无向图的一个典型问题是如何寻找最小生成树.\nprim算法 设N是连通网, 记U={ $u_0$ }, TE={} 在所有$ u \\in U, v \\in V-U $的边$ (u, v) \\in E $中找到一条代价最小的边$ (u_0, v_0)并加入TE $ 将$ v_0 $加入U 若U=V, 停止否则继续2 我们将使用优先队列来进行添加最小边的操作. 并且我们需要在添加新顶点之后检查队列中边的有效性. Prim的一种延时实现: public class LazyPrimMST {\rprivate boolean[] marked;\rprivate Queue mst;\rprivate MinPQ pq;\rpublic LazyPrimMST(EdgeWeightedGraph G) {\rpq = new MinPQ\u003c\u003e();\rmarked = new boolean[G.V()];\rmst = new Queue\u003c\u003e();\rvisit(G, 0);\rwhile (!pq.isEmpty()) {\rEdge e = pq.delMin();\rint v = e.either();\rint w = e.other(v);\rif (!marked[v] || !marked[w]) {\rmst.enqueue(e);\rif (!marked[v]) { visit(G, v); }\rif (!marked[w]) { visit(G, w); }\r}\r}\r}\rprivate void visit(EdgeWeightedGraph G, int v) {\rmarked[v] = true;\rfor (Edge e : G.adj(v)) {\rif (!marked[e.other(v)]) { pq.insert(e); }\r}\r}\rpublic Iterable edges() { return mst; }\rpublic double weight() {\rdouble weight = 0;\rfor (Edge e : edges()) {\rweight += e.weight();\r}\rreturn weight;\r}\r} 延时实现会将所有边都将入优先队列中, 并且不会删除失效的边, 而是在删除的时候检查边的有效性. 所需时间与ElgE成正比, 所需空间与E成正比.\n一种即时实现是总是删除优先队列中失效的边. 我们感兴趣的其实只是连接树顶点和非树顶点中权重最小的边. 当我们将一个顶点v将入到树中时, 对与一个非树中的 顶点w, 只可能使得w到最小生成树的距离更小. 换言之, 我们只会在优先队列中保存每个非树顶点的一条边: 使它与树中顶点连接起来权重最小的一条边.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class PrimMST { private Edge[] edgeTo; private double[] distTo; private boolean[] marked; private IndexMinPQ\u003cDouble\u003e pq; public PrimMST(EdgeWeightedGraph G) { edgeTo = new Edge[G.V()]; distTo = new double[G.V()]; marked = new boolean[G.V()]; for (int v = 0; v \u003c G.V(); v++) { distTo[v] = Double.POSITIVE_INFINITY; } pq = new IndexMinPQ\u003c\u003e(); distTo[0] = 0.0; pq.insert(0, 0.0); while (!pq.isEmpty()) { visit(G, pq.delMin()); } } private void visit(EdgeWeightedGraph G, int v) { marked[v] = true; for (Edge e : G.adj(v)) { int w = e.other(v); if (!marked[w] \u0026\u0026 e.weight() \u003c distTo[w]) { edgeTo[w] = e; distTo[w] = e.weight(); if (pq.contains(w)) { pq.change(w, distTo[w]); } else { pq.insert(w, distTo[w]); } } } } public Iterable\u003cEdge\u003e edges() { Bag\u003cEdge\u003e edges = new Bag\u003c\u003e(); for (int v = 1; v \u003c edgeTo.length; v++) { edges.add(edgeTo[v]); } return edges; } public double weight() { double weight = 0; for (Edge e : edges()) { weight += e.weight(); } return weight; } } 即时的版本所需时间与ElgV成正比, 空间和V成正比.\n对于常见的稀疏图而言, 两者在时间上限上没有明显的区别(对于稀疏图而言, lgE~lgV), 但空间占用上显然即时的版本更优秀.\nKruskal 算法 相较于Prim算法根据顶点构成树, Kruskal则算法根据边来构成树. 该算法不断地将最小边加入到树中并确保不会构成环. 可以使用最小队列来保存边, 并用 union-find来判断是否有环:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class KruskalMST { private Queue\u003cEdge\u003e mst; public KruskalMST(EdgeWeightedGraph G) { mst = new Queue\u003c\u003e(); MinPQ\u003cEdge\u003e pq = new MinPQ\u003c\u003e(); for (Edge e : G.edges()) { pq.insert(e); } WeightedQuickUnionUF uf = new WeightedQuickUnionUF(G.V()); while (!pq.isEmpty() \u0026\u0026 mst.size() \u003c G.V() - 1) { Edge e = pq.delMin(); int v = e.either(); int w = e.other(v); if (!uf.connected(v, w)) { uf.union(w, v); mst.enqueue(e); } } } public Iterable\u003cEdge\u003e edges() { return mst; } public double weight() { double weight = 0; for (Edge e : edges()) { weight += e.weight(); } return weight; } } Kruskal算法一般情况下会比Prim算法慢, 因为union-find还需要进行一次connect操作.\n最小生成树各算法比较(设V个顶点, E条边):\n算法 空间 时间 延时的Prim算法 E ElgE 即时的Prim算法 V ElgV Kruskal E ElgE Fredman-Tarjan V E+VlgV Chazelle V 非常接近E 加权有向图 加权有向图的一个典型的问题是如何寻找最短路径. 我们的重点是单点最短路径问题, 对于给定的起点s得到一颗包含s到所有可达顶点的最短路径树(SPT).\nDijkstra算法 Dijkstra算法按广度优先来寻找最短路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class DijkstraSP { private DirectedEdge[] edgeTo; private double[] distTo; private IndexMinPQ\u003cDouble\u003e pq; public DijkstraSP(EdgeWeightedDigraph G, int s) { edgeTo = new DirectedEdge[G.V()]; distTo = new double[G.V()]; pq = new IndexMinPQ\u003c\u003e(); for (int v = 0; v \u003c G.V(); v ++) { distTo[v] = Double.POSITIVE_INFINITY; } distTo[0] = 0.0; pq.insert(s, 0.0); while (!pq.isEmpty()) { relax(G, pq.delMin()); } } private void relax(EdgeWeightedDigraph G, int v) { for (DirectedEdge e : G.adj(v)) { int w = e.to(); double newWeight = distTo[v] + e.weight(); if (distTo[w] \u003e newWeight) { distTo[w] = newWeight; edgeTo[w] = e; if (pq.contains(w)) { pq.change(w, distTo[w]); } else { pq.insert(w, distTo[w]); } } } } public double distTo(int v) { return distTo[v]; } public boolean hasPathTo(int v) { return distTo[v] \u003c Double.POSITIVE_INFINITY; } public Iterable\u003cDirectedEdge\u003e pathTo(int v) { if (!hasPathTo(v)) { return null; } else { Stack\u003cDirectedEdge\u003e path = new Stack\u003c\u003e(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) { path.push(e); } return path; } } } 可以看到, Dijkstra算法和Prim算法两者之间非常类似. 某种程度上可以把Dijkstra看成是Prim算法的有向图版本. 类似的, Dijkstra算法所需的空间与V成正比 时间与ElgV成正比. 但是Dijkstra算法不适用于存在权重为负的有向图(因为在允许负权重的有向图中, 绕路经过更多的负权重边可能会使得权重之和更小, 而这在 Dijkstra算法中是不被允许的).\n无环加权有向图的最短路径算法 无环加权有向图可以利用拓扑排序来获得一个线性时间的最短路径算法, 并且能够处理负权重的边.\npublic class AcyclicSP {\rprivate DirectedEdge[] edgeTo;\rprivate double[] distTo;\rpublic AcyclicSP(EdgeWeightedDigraph G, int s) {\redgeTo = new DirectedEdge[G.V()];\rdistTo = new double[G.V()];\rfor (int v = 0; v \u003c G.V(); v++) { distTo[v] = Double.POSITIVE_INFINITY; }\rdistTo[s] = 0;\rEdgeweightedTopological top = new EdgeweightedTopological(G);\rfor (int v: top.order()) {\rrelax(G, v);\r}\r}\rprivate void relax(EdgeWeightedDigraph G, int v) {\rfor (DirectedEdge e : G.adj(v)) {\rint w = e.to();\rdouble newWeight = distTo[v] + e.weight();\rif (distTo[w] \u003e newWeight) {\rdistTo[w] = newWeight;\redgeTo[w] = e;\r}\r}\r}\rpublic double distTo(int v) { return distTo[v]; }\rpublic boolean hasPathTo(int v) { return distTo[v] \u003c Double.POSITIVE_INFINITY; }\rpublic Iterable pathTo(int v) {\rStack path = new Stack\u003c\u003e();\rfor (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) { path.push(e); }\rreturn path;\r}\rpublic static void main(String[] args) throws FileNotFoundException {\rFile file = new File(args[0]);\rEdgeWeightedDigraph G = new EdgeWeightedDigraph(file);\rint s = Integer.parseInt(args[1]);\rAcyclicSP sp = new AcyclicSP(G, s);\rfor (int t = 0; t \u003c G.V(); t++) {\rSystem.out.print(s + \" to \" + t);\rSystem.out.printf(\" (%4.2f): \", sp.distTo(t));\rif (sp.hasPathTo(t)) {\rfor (DirectedEdge e : sp.pathTo(t)) { System.out.print(e + \" \"); }\r}\rSystem.out.println();\r}\r}\r} 按照拓扑顺序来遍历并relax顶点, 就能够在和E+V成正比的时间内解决单点最短路径问题 按照拓扑顺序可以保证每条边都被relax一次, 任意一个顶点在relax后, 算法便不在处理任何指向该顶点的边. 而每次relax操作只会减少 路径长, 因此在所有从s可达的顶点都被加入到树中后, 最短路径的最优条件成立. 而拓扑排序的时间复杂度是线性的, 因此总时间复杂度也是线性的.\n因为该算法依赖于拓扑排序, 所以任何有环的图都将无法使用该算法. 另外一点是, 该算法可以解决负权重的边. 值得一提的是, 简单的修改上述算法可以在 线性时间复杂度内解决无环加权有向图的单点最长路径, 将Double.POSITIVE_INFINITY改为Double.NEGATIVE_INFINITY, 并修改relax的 不等号方向. 但是在一般的加权有向图中寻找最长简单路径的已知最好算法是指数级别的.\n关键路径 一种和无环加权有向图的最长路径等价的问题是优先级限制下的并行任务调度问题, 即关键路径问题. 将并行调度任务转换为无环有向图的步骤如下:\n创建一个包含起点s和终点t且每个任务都对应两个顶点(一个起始顶点和结束顶点); 对于每个任务, 都添加一条从起始顶点指向结束顶点且权重为任务所需时间的边. 对于每个优先级限制v -\u003e w, 添加一条从v结束顶点指向w起始顶点且 权重为0的边. 为每个任务添加一条从起点指向该任务起始顶点且权重为0的边, 以及一条从该任务结束顶点指向终点且权重为0的边. 例如, 有如下测试数据 10\r41.0 1 7 9 // 必须在1 7 9之前完成\r51.0 2\r50.0\r36.0\r38.0\r45.0\r21.0 3 8\r32.0 3 8\r32.0 2\r29.0 4 6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class CMP { public static void main(String[] args) { Scanner stdIn = new Scanner(System.in); int N = stdIn.nextInt(); stdIn.nextLine(); EdgeWeightedDigraph G = new EdgeWeightedDigraph(2 * N + 2); int s = 2 * N; int t = 2 * N + 1; for (int i = 0; i \u003c N; i++) { String[] line = stdIn.nextLine().split(\"\\\\s+\"); double duration = Double.parseDouble(line[0]); G.addEdge(new DirectedEdge(i, i + N, duration)); G.addEdge(new DirectedEdge(s, i, 0.0)); G.addEdge(new DirectedEdge(i + N, t, 0.0)); for (int j = 1; j \u003c line.length; j++) { int successor = Integer.parseInt(line[j]); G.addEdge(new DirectedEdge(i + N, successor, 0.0)); } } AcyclicLP lp = new AcyclicLP(G, s); System.out.println(\"Start times:\"); for (int i = 0; i \u003c N; i++) { System.out.printf(\"%4d: %5.1f\\n\", i, lp.distTo(i)); } System.out.printf(\"Finish time: %5.1f\\n\", lp.distTo(t)); } } 可以得到如下结果:\nStart times:\r0: 0.0\r1: 41.0\r2: 123.0\r3: 91.0\r4: 70.0\r5: 0.0\r6: 70.0\r7: 41.0\r8: 91.0\r9: 41.0\rFinish time: 173.0 之所以最长路径路径能够解决并行任务调度问题在于s到t的最长路径是所有任务完成所需的最短时间.\n一般加权有向图的最短路径算法 考虑包含deadline限制的相对最后期限限制下的并行任务调度问题, 一般的deadline限制都是相对与第一个的任务的开始时间而言, 即在任务调度的问题中加入某个任 务必须在指定的时间点之前开始. 该问题等价于加权有向图中最短路径问题(可以有环和负权重). 构造一个加权有向图与关键路径类似, 但需要为每条deadline限制添加一条边: 如果任务v必须在任务w启动后的d个单位时间内开始, 则添加一条从v指向w且权重为负的 边. 将所有边的权重取反即可得到一个加权有向图的最短路径问题.\n当且仅当加权有向图中至少存在一条从s到v的有向路径且其上的任意顶点都不存在与负权重环中时, 最短路径才存在. 对于任意一个负权重的环(权重之和为负数), 重复该环即可得到权重任意小的路径, 而这是无意义的.\n因此该算法要求能够:\n对于从起点不可达的顶点, 最短路径是$ +\\infty $ 对于从起点可达但存在与一个负权重环的顶点, 最短路径为$ -\\infty $ 对于其他顶点, 能够计算最短路径的权重 Bellman-Ford算法可以解决这样的问题, 基本思想是按节点依次构建最短路径, 于是该算法的时间与VE成正比, 空间和V成正比. 该方法非常通用, 因为其没有规定 边的放松顺序, 且总是放松VE条边. 我不会着力于这个版本, 而是介绍另外一个改进的版本.\n基于队列的Bellman-Ford算法\n我们很容易发现, 原始的版本在每一轮中有很多relax操作都不会成功, 只有在上一轮中起点到该点路径长度改变的点指出的边才能够改变起点到其他顶点的路径长. 为了记录这样的顶点, 可以使用一个FIFO的队列来记录这些点.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 public class BellmanFordSP { private double[] distTo; private DirectedEdge[] edgeTo; private boolean[] onQ; private Queue\u003cInteger\u003e queue; private int cost; // relax调用的次数 private Iterable\u003cInteger\u003e cycle; public BellmanFordSP(EdgeWeightedDigraph G, int s) { distTo = new double[G.V()]; edgeTo = new DirectedEdge[G.V()]; onQ = new boolean[G.V()]; queue = new Queue\u003c\u003e(); for (int v = 0; v \u003c G.V(); v++) { distTo[v] = Double.POSITIVE_INFINITY; } distTo[s] = 0.0; queue.enqueue(s); onQ[s] = true; while (!queue.isEmpty() \u0026\u0026 !hasNegativeCycle()) { int v = queue.dequeue(); onQ[v] = false; relax(G, v); } } private void relax(EdgeWeightedDigraph G, int v) { for (DirectedEdge e : G.adj(v)) { int w = e.to(); if (distTo[w] \u003e distTo[v] + e.weight()) { distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (!onQ[w]) { queue.enqueue(w); onQ[w] = true; } } cost += 1; if (cost % G.V() == 0) { findNegativeCycle(); } } } private void findNegativeCycle() { int V = edgeTo.length; EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V); for (int v = 0; v \u003c V; v++) { if (edgeTo[v] != null) { spt.addEdge(edgeTo[v]); } } EdgeWeightedCycleFinder cf = new EdgeWeightedCycleFinder(spt); cycle = cf.cycle(); } public boolean hasNegativeCycle() { return cycle != null; } public Iterable\u003cInteger\u003e negativeCycle() { return cycle; } public double distTO(int v) { return distTo[v]; } public boolean hasPathTo(int v) { return distTo[v] \u003c Double.POSITIVE_INFINITY; } public Iterable\u003cDirectedEdge\u003e pathTo(int v) { Stack\u003cDirectedEdge\u003e path = new Stack\u003c\u003e(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) { path.push(e); } return path; } } 为了避免负权重出现, 我们需要在每轮进行负权重环的检测.\n加权有向图最短路径算法比较 算法 限制 时间复杂度 空间复杂度 优势 Dijkstra算法 权重需要为正 ElgV V 最坏情况下仍有较好性能 利用拓扑排序的最短路径算法 只适用于无环加权有向图 E + V V 是无环图中的最优算法 Bellman-Ford算法 不能存在负权重环 E + V(最坏EV) V 适用性高 ","wordCount":"2267","inLanguage":"en","datePublished":"2018-04-20T19:21:30Z","dateModified":"2018-04-20T19:21:30Z","author":{"@type":"Person","name":"Christophe"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sdlinks.net/posts/2018/graph-algorithms/"},"publisher":{"@type":"Organization","name":"Neo VRAINS","logo":{"@type":"ImageObject","url":"https://www.sdlinks.net/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.sdlinks.net/ accesskey=h title="Neo VRAINS (Alt + H)">Neo VRAINS</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.sdlinks.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.sdlinks.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.sdlinks.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://www.sdlinks.net/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">图算法</h1><div class=post-meta><span title='2018-04-20 19:21:30 +0000 UTC'>April 20, 2018</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></div></header><div class=post-content><p>采用哪种数据结构来表示图, 主要考虑以下两个方面:</p><ul><li>必须为可能在应用中碰到的各种类型的图预留出足够的空间, 以及</li><li>Graph的实例方法一定要高效.</li></ul><p>常见的表示方法有以下几种:</p><ul><li>邻接矩阵, 对于有N个顶点的图而言, 邻接矩阵需要$ N^2 $的空间.</li><li>边的数组, 通过定义边来定义图, 这种方法在寻找相邻的点时需要遍历整个数组.</li><li>邻接表数组, 使用一个顶点为索引的列表数组, 其中每个元素都是和该顶点相邻的顶点列表. 这种结构能够满足上述的两个条件.</li></ul><p>常见实现的性能比较(V表示结点数, E表示边数):</p><table><thead><tr><th style=text-align:center>数据结构</th><th style=text-align:center>所需空间</th><th style=text-align:center>添加边</th><th style=text-align:center>检查顶点是否相邻</th><th style=text-align:center>遍历所有相邻顶点</th></tr></thead><tbody><tr><td style=text-align:center>边的列表</td><td style=text-align:center>E</td><td style=text-align:center>1</td><td style=text-align:center>E</td><td style=text-align:center>E</td></tr><tr><td style=text-align:center>邻接矩阵</td><td style=text-align:center>$ V^2 $</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>V</td></tr><tr><td style=text-align:center>邻接表</td><td style=text-align:center>E+V</td><td style=text-align:center>1</td><td style=text-align:center>degree(V)</td><td style=text-align:center>degree(V)</td></tr></tbody></table><p>非稠密图的标准表示是邻接表, 这种表示具有以下特性:</p><ul><li>使用的空间和V+E成正比,</li><li>添加一条边所需要的时间为常数, 以及</li><li>遍历顶点v的所有相邻顶点所需要的时间和v的度数成正比.</li></ul><h2 id=无向图>无向图<a hidden class=anchor aria-hidden=true href=#无向图>#</a></h2><p>无向图只定义了顶点以及顶点之间的关系.</p><h3 id=深度优先搜索>深度优先搜索<a hidden class=anchor aria-hidden=true href=#深度优先搜索>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DepthFirstSearch</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>marked</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>count</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>DepthFirstSearch</span><span class=p>(</span><span class=n>Graph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>dfs</span><span class=p>(</span><span class=n>Graph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>count</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>marked</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>count</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>count</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>深度优先搜索能够所有与起点相连的顶点, 且所需时间和所有连通顶点的度数之和成正比.</p><h3 id=广度优先搜索>广度优先搜索<a hidden class=anchor aria-hidden=true href=#广度优先搜索>#</a></h3><p>深度优先搜索得到的路径不仅取决于图的结构, 还取决于图的表示和递归调用的性质.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>BreadthFirthSearch</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>marked</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>count</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>BreadthFirthSearch</span><span class=p>(</span><span class=n>Graph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>bfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>bfs</span><span class=p>(</span><span class=n>Graph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>queue</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>queue</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>queue</span><span class=p>.</span><span class=na>dequeue</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>x</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>queue</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>w</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>count</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>marked</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>count</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>count</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>深度优先搜索与广度优先搜索的差别在于数据结构的不同, 前者使用栈而后者使用队列, 我们在搜索的时候都会将起点加入数据结构, 然后重复以下步骤直到数据结构被
清空:</p><ul><li>取其中的下一个顶点并标记它</li><li>将v的所有相邻而又为被标记的顶点加入数据结构
两者的差别只在于数据结构如何获取下一个顶点, 而这种差异导致了图的两者不同视图, 但最终所有与顶点相连的点都会被检查到</li></ul><h2 id=有向图>有向图<a hidden class=anchor aria-hidden=true href=#有向图>#</a></h2><h3 id=环的检测>环的检测<a hidden class=anchor aria-hidden=true href=#环的检测>#</a></h3><p>有向图常常需要检测是否存在环.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * only for one cycle
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DirectedCycle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>marked</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>edgeTo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>cycle</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>onStack</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>DirectedCycle</span><span class=p>(</span><span class=n>Digraph</span><span class=w> </span><span class=n>G</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>onStack</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>edgeTo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>();</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>dfs</span><span class=p>(</span><span class=n>Digraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>onStack</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=na>hasCycle</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>onStack</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cycle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>;</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>w</span><span class=p>;</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>x</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>cycle</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cycle</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>w</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cycle</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>onStack</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>hasCycle</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>cycle</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=nf>cycle</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>cycle</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=拓扑排序>拓扑排序<a hidden class=anchor aria-hidden=true href=#拓扑排序>#</a></h3><p>拓扑排序是解决优先级限制下任务调度的常见算法, 能否进行拓扑排序的先决条件是是否是有向无环图. 进而问题变为有向无环图中基于深度优先遍历的顶点排序问题,
常见的排序方式有以下三种:</p><ul><li>前序, 在递归调用前将顶点加入队列</li><li>后序, 在递归调用之后将顶点加入队列</li><li>逆后序, 在递归调用之后将顶点加入栈</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DepthFirthOrder</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>marked</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>pre</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>post</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>reverstPost</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>DepthFirthOrder</span><span class=p>(</span><span class=n>Digraph</span><span class=w> </span><span class=n>G</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pre</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>post</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>reverstPost</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>();</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>dfs</span><span class=p>(</span><span class=n>Digraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pre</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>post</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>reverstPost</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=nf>pre</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>pre</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=nf>post</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>post</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=nf>reverstPost</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>reverstPost</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>进而拓扑排序可以有如下实现:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Topological</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>order</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>Topological</span><span class=p>(</span><span class=n>Digraph</span><span class=w> </span><span class=n>G</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>DirectedCycle</span><span class=w> </span><span class=n>cycle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DirectedCycle</span><span class=p>(</span><span class=n>G</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>cycle</span><span class=p>.</span><span class=na>hasCycle</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>DepthFirthOrder</span><span class=w> </span><span class=n>dfs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DepthFirthOrder</span><span class=p>(</span><span class=n>G</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>order</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dfs</span><span class=p>.</span><span class=na>reverstPost</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=nf>order</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>order</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>isDAG</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>order</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>FileNotFoundException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>filename</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>args</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>sp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>args</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SymbolDigraph</span><span class=w> </span><span class=n>sg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SymbolDigraph</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>filename</span><span class=p>),</span><span class=w> </span><span class=n>sp</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Topological</span><span class=w> </span><span class=n>top</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Topological</span><span class=p>(</span><span class=n>sg</span><span class=p>.</span><span class=na>G</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>top</span><span class=p>.</span><span class=na>order</span><span class=p>.</span><span class=na>forEach</span><span class=p>(</span><span class=n>v</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>sg</span><span class=p>.</span><span class=na>name</span><span class=p>(</span><span class=n>v</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这种实现非常简单, 但它被忽略了很多年, 比它更流行的是一种使用队列存储顶点的直观算法:</p><ol><li>初始化一条含有所有起点的队列Q</li><li>如果Q为空, 停止, 否则从队列Q中删除一个起点并将其标记;</li><li>遍历由被删除顶点指出的所有边, 将被指向的顶点的入度减1;</li><li>如果顶点的入度变为0, 将其加入Q;</li><li>跳转至2.</li></ol><h2 id=加权无向图>加权无向图<a hidden class=anchor aria-hidden=true href=#加权无向图>#</a></h2><p>加权无向图的一个典型问题是如何寻找最小生成树.</p><h3 id=prim算法>prim算法<a hidden class=anchor aria-hidden=true href=#prim算法>#</a></h3><ol><li>设N&lt;V, {E}>是连通网, 记U={ $u_0$ }, TE={}</li><li>在所有$ u \in U, v \in V-U $的边$ (u, v) \in E $中找到一条代价最小的边$ (u_0, v_0)并加入TE $</li><li>将$ v_0 $加入U</li><li>若U=V, 停止否则继续2
我们将使用优先队列来进行添加最小边的操作. 并且我们需要在添加新顶点之后检查队列中边的有效性. Prim的一种延时实现:</li></ol><pre tabindex=0><code>public class LazyPrimMST {
    private boolean[] marked;
    private Queue&lt;Edge&gt; mst;
    private MinPQ&lt;Edge&gt; pq;

    public LazyPrimMST(EdgeWeightedGraph G) {
        pq = new MinPQ&lt;&gt;();
        marked = new boolean[G.V()];
        mst = new Queue&lt;&gt;();
        visit(G, 0);
        while (!pq.isEmpty()) {
            Edge e = pq.delMin();
            int v = e.either();
            int w = e.other(v);
            if (!marked[v] || !marked[w]) {
                mst.enqueue(e);
                if (!marked[v]) { visit(G, v); }
                if (!marked[w]) { visit(G, w); }
            }
        }
    }

    private void visit(EdgeWeightedGraph G, int v) {
        marked[v] = true;
        for (Edge e : G.adj(v)) {
            if (!marked[e.other(v)]) { pq.insert(e); }
        }
    }

    public Iterable&lt;Edge&gt; edges() { return mst; }

    public double weight() {
        double weight = 0;
        for (Edge e : edges()) {
            weight += e.weight();
        }
        return weight;
    }
}
</code></pre><p>延时实现会将所有边都将入优先队列中, 并且不会删除失效的边, 而是在删除的时候检查边的有效性. 所需时间与ElgE成正比, 所需空间与E成正比.</p><p>一种即时实现是总是删除优先队列中失效的边. 我们感兴趣的其实只是连接树顶点和非树顶点中权重最小的边. 当我们将一个顶点v将入到树中时, 对与一个非树中的
顶点w, 只可能使得w到最小生成树的距离更小. 换言之, 我们只会在优先队列中保存每个非树顶点的一条边: 使它与树中顶点连接起来权重最小的一条边.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>PrimMST</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Edge</span><span class=o>[]</span><span class=w> </span><span class=n>edgeTo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>double</span><span class=o>[]</span><span class=w> </span><span class=n>distTo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>marked</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>IndexMinPQ</span><span class=o>&lt;</span><span class=n>Double</span><span class=o>&gt;</span><span class=w> </span><span class=n>pq</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>PrimMST</span><span class=p>(</span><span class=n>EdgeWeightedGraph</span><span class=w> </span><span class=n>G</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>edgeTo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Edge</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>double</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>();</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Double</span><span class=p>.</span><span class=na>POSITIVE_INFINITY</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pq</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>IndexMinPQ</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pq</span><span class=p>.</span><span class=na>insert</span><span class=p>(</span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>pq</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>visit</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>delMin</span><span class=p>());</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>visit</span><span class=p>(</span><span class=n>EdgeWeightedGraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Edge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>other</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>()</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>pq</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>w</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>change</span><span class=p>(</span><span class=n>w</span><span class=p>,</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>insert</span><span class=p>(</span><span class=n>w</span><span class=p>,</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Edge</span><span class=o>&gt;</span><span class=w> </span><span class=nf>edges</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Bag</span><span class=o>&lt;</span><span class=n>Edge</span><span class=o>&gt;</span><span class=w> </span><span class=n>edges</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Bag</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>edgeTo</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>edges</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>edgeTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>edges</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>double</span><span class=w> </span><span class=nf>weight</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>double</span><span class=w> </span><span class=n>weight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Edge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>edges</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>weight</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>();</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>weight</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>即时的版本所需时间与ElgV成正比, 空间和V成正比.</p><p>对于常见的稀疏图而言, 两者在时间上限上没有明显的区别(对于稀疏图而言, lgE~lgV), 但空间占用上显然即时的版本更优秀.</p><h3 id=kruskal-算法>Kruskal 算法<a hidden class=anchor aria-hidden=true href=#kruskal-算法>#</a></h3><p>相较于Prim算法根据顶点构成树, Kruskal则算法根据边来构成树. 该算法不断地将最小边加入到树中并确保不会构成环. 可以使用最小队列来保存边, 并用
union-find来判断是否有环:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>KruskalMST</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Edge</span><span class=o>&gt;</span><span class=w> </span><span class=n>mst</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>KruskalMST</span><span class=p>(</span><span class=n>EdgeWeightedGraph</span><span class=w> </span><span class=n>G</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>mst</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>MinPQ</span><span class=o>&lt;</span><span class=n>Edge</span><span class=o>&gt;</span><span class=w> </span><span class=n>pq</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>MinPQ</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Edge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>edges</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>insert</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>WeightedQuickUnionUF</span><span class=w> </span><span class=n>uf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>WeightedQuickUnionUF</span><span class=p>(</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>pq</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>mst</span><span class=p>.</span><span class=na>size</span><span class=p>()</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Edge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>delMin</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>either</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>other</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>uf</span><span class=p>.</span><span class=na>connected</span><span class=p>(</span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>uf</span><span class=p>.</span><span class=na>union</span><span class=p>(</span><span class=n>w</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>mst</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Edge</span><span class=o>&gt;</span><span class=w> </span><span class=nf>edges</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>mst</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>double</span><span class=w> </span><span class=nf>weight</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>double</span><span class=w> </span><span class=n>weight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Edge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>edges</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>weight</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>();</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>weight</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Kruskal算法一般情况下会比Prim算法慢, 因为union-find还需要进行一次connect操作.</p><p>最小生成树各算法比较(设V个顶点, E条边):</p><table><thead><tr><th style=text-align:center>算法</th><th style=text-align:center>空间</th><th style=text-align:center>时间</th></tr></thead><tbody><tr><td style=text-align:center>延时的Prim算法</td><td style=text-align:center>E</td><td style=text-align:center>ElgE</td></tr><tr><td style=text-align:center>即时的Prim算法</td><td style=text-align:center>V</td><td style=text-align:center>ElgV</td></tr><tr><td style=text-align:center>Kruskal</td><td style=text-align:center>E</td><td style=text-align:center>ElgE</td></tr><tr><td style=text-align:center>Fredman-Tarjan</td><td style=text-align:center>V</td><td style=text-align:center>E+VlgV</td></tr><tr><td style=text-align:center>Chazelle</td><td style=text-align:center>V</td><td style=text-align:center>非常接近E</td></tr></tbody></table><h2 id=加权有向图>加权有向图<a hidden class=anchor aria-hidden=true href=#加权有向图>#</a></h2><p>加权有向图的一个典型的问题是如何寻找最短路径. 我们的重点是单点最短路径问题, 对于给定的起点s得到一颗包含s到所有可达顶点的最短路径树(SPT).</p><h3 id=dijkstra算法>Dijkstra算法<a hidden class=anchor aria-hidden=true href=#dijkstra算法>#</a></h3><p>Dijkstra算法按广度优先来寻找最短路径</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DijkstraSP</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>DirectedEdge</span><span class=o>[]</span><span class=w> </span><span class=n>edgeTo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>double</span><span class=o>[]</span><span class=w> </span><span class=n>distTo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>IndexMinPQ</span><span class=o>&lt;</span><span class=n>Double</span><span class=o>&gt;</span><span class=w> </span><span class=n>pq</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>DijkstraSP</span><span class=p>(</span><span class=n>EdgeWeightedDigraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>edgeTo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DirectedEdge</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>double</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pq</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>IndexMinPQ</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>();</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Double</span><span class=p>.</span><span class=na>POSITIVE_INFINITY</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pq</span><span class=p>.</span><span class=na>insert</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>pq</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>relax</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>delMin</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>relax</span><span class=p>(</span><span class=n>EdgeWeightedDigraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>DirectedEdge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>to</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>double</span><span class=w> </span><span class=n>newWeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>newWeight</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>newWeight</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>pq</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>w</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>change</span><span class=p>(</span><span class=n>w</span><span class=p>,</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>insert</span><span class=p>(</span><span class=n>w</span><span class=p>,</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>double</span><span class=w> </span><span class=nf>distTo</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>hasPathTo</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>Double</span><span class=p>.</span><span class=na>POSITIVE_INFINITY</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>DirectedEdge</span><span class=o>&gt;</span><span class=w> </span><span class=nf>pathTo</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>hasPathTo</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Stack</span><span class=o>&lt;</span><span class=n>DirectedEdge</span><span class=o>&gt;</span><span class=w> </span><span class=n>path</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>DirectedEdge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>e</span><span class=p>.</span><span class=na>from</span><span class=p>()</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>path</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>path</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>可以看到, Dijkstra算法和Prim算法两者之间非常类似. 某种程度上可以把Dijkstra看成是Prim算法的有向图版本. 类似的, Dijkstra算法所需的空间与V成正比
时间与ElgV成正比. 但是Dijkstra算法不适用于存在权重为负的有向图(因为在允许负权重的有向图中, 绕路经过更多的负权重边可能会使得权重之和更小, 而这在
Dijkstra算法中是不被允许的).</p><h3 id=无环加权有向图的最短路径算法>无环加权有向图的最短路径算法<a hidden class=anchor aria-hidden=true href=#无环加权有向图的最短路径算法>#</a></h3><p>无环加权有向图可以利用拓扑排序来获得一个线性时间的最短路径算法, 并且能够处理负权重的边.</p><pre tabindex=0><code>public class AcyclicSP {
    private DirectedEdge[] edgeTo;
    private double[] distTo;

    public AcyclicSP(EdgeWeightedDigraph G, int s) {
        edgeTo = new DirectedEdge[G.V()];
        distTo = new double[G.V()];
        for (int v = 0; v &lt; G.V(); v++) { distTo[v] = Double.POSITIVE_INFINITY; }
        distTo[s] = 0;
        EdgeweightedTopological top = new EdgeweightedTopological(G);
        for (int v: top.order()) {
            relax(G, v);
        }
    }

    private void relax(EdgeWeightedDigraph G, int v) {
        for (DirectedEdge e : G.adj(v)) {
            int w = e.to();
            double newWeight = distTo[v] + e.weight();
            if (distTo[w] &gt; newWeight) {
                distTo[w] = newWeight;
                edgeTo[w] = e;
            }
        }
    }

    public double distTo(int v) { return distTo[v]; }

    public boolean hasPathTo(int v) { return distTo[v] &lt; Double.POSITIVE_INFINITY; }
    public Iterable&lt;DirectedEdge&gt; pathTo(int v) {
        Stack&lt;DirectedEdge&gt; path = new Stack&lt;&gt;();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) { path.push(e); }
        return path;
    }

    public static void main(String[] args) throws FileNotFoundException {
        File file = new File(args[0]);
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(file);
        int s = Integer.parseInt(args[1]);
        AcyclicSP sp = new AcyclicSP(G, s);

        for (int t = 0; t &lt; G.V(); t++) {
            System.out.print(s + &#34; to &#34; + t);
            System.out.printf(&#34; (%4.2f): &#34;, sp.distTo(t));
            if (sp.hasPathTo(t)) {
                for (DirectedEdge e : sp.pathTo(t)) { System.out.print(e + &#34;   &#34;); }
            }
            System.out.println();
        }
    }
}
</code></pre><blockquote><p>按照拓扑顺序来遍历并<code>relax</code>顶点, 就能够在和E+V成正比的时间内解决单点最短路径问题
按照拓扑顺序可以保证每条边都被<code>relax</code>一次, 任意一个顶点在<code>relax</code>后, 算法便不在处理任何指向该顶点的边. 而每次<code>relax</code>操作只会减少
路径长, 因此在所有从s可达的顶点都被加入到树中后, 最短路径的最优条件成立. 而拓扑排序的时间复杂度是线性的, 因此总时间复杂度也是线性的.</p></blockquote><p>因为该算法依赖于拓扑排序, 所以任何有环的图都将无法使用该算法. 另外一点是, 该算法可以解决负权重的边. 值得一提的是, 简单的修改上述算法可以在
线性时间复杂度内解决无环加权有向图的单点最长路径, 将<code>Double.POSITIVE_INFINITY</code>改为<code>Double.NEGATIVE_INFINITY</code>, 并修改<code>relax</code>的
不等号方向. 但是在一般的加权有向图中寻找最长简单路径的已知最好算法是指数级别的.</p><h3 id=关键路径>关键路径<a hidden class=anchor aria-hidden=true href=#关键路径>#</a></h3><p>一种和无环加权有向图的最长路径等价的问题是优先级限制下的并行任务调度问题, 即关键路径问题. 将并行调度任务转换为无环有向图的步骤如下:</p><ol><li>创建一个包含起点s和终点t且每个任务都对应两个顶点(一个起始顶点和结束顶点);</li><li>对于每个任务, 都添加一条从起始顶点指向结束顶点且权重为任务所需时间的边. 对于每个优先级限制v -> w, 添加一条从v结束顶点指向w起始顶点且
权重为0的边.</li><li>为每个任务添加一条从起点指向该任务起始顶点且权重为0的边, 以及一条从该任务结束顶点指向终点且权重为0的边.
例如, 有如下测试数据</li></ol><pre tabindex=0><code>10
41.0  1 7 9 // 必须在1 7 9之前完成
51.0  2
50.0
36.0
38.0
45.0
21.0  3 8
32.0  3 8
32.0  2
29.0  4 6
</code></pre><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>CMP</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Scanner</span><span class=w> </span><span class=n>stdIn</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Scanner</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>in</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stdIn</span><span class=p>.</span><span class=na>nextInt</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>stdIn</span><span class=p>.</span><span class=na>nextLine</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>EdgeWeightedDigraph</span><span class=w> </span><span class=n>G</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>EdgeWeightedDigraph</span><span class=p>(</span><span class=n>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>line</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stdIn</span><span class=p>.</span><span class=na>nextLine</span><span class=p>().</span><span class=na>split</span><span class=p>(</span><span class=s>&#34;\\s+&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>double</span><span class=w> </span><span class=n>duration</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Double</span><span class=p>.</span><span class=na>parseDouble</span><span class=p>(</span><span class=n>line</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>G</span><span class=p>.</span><span class=na>addEdge</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>DirectedEdge</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>N</span><span class=p>,</span><span class=w> </span><span class=n>duration</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>G</span><span class=p>.</span><span class=na>addEdge</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>DirectedEdge</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>G</span><span class=p>.</span><span class=na>addEdge</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>DirectedEdge</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>N</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>line</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>int</span><span class=w> </span><span class=n>successor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>parseInt</span><span class=p>(</span><span class=n>line</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>G</span><span class=p>.</span><span class=na>addEdge</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>DirectedEdge</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>N</span><span class=p>,</span><span class=w> </span><span class=n>successor</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>AcyclicLP</span><span class=w> </span><span class=n>lp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AcyclicLP</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Start times:&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>printf</span><span class=p>(</span><span class=s>&#34;%4d: %5.1f\n&#34;</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>lp</span><span class=p>.</span><span class=na>distTo</span><span class=p>(</span><span class=n>i</span><span class=p>));</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>printf</span><span class=p>(</span><span class=s>&#34;Finish time: %5.1f\n&#34;</span><span class=p>,</span><span class=w> </span><span class=n>lp</span><span class=p>.</span><span class=na>distTo</span><span class=p>(</span><span class=n>t</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>可以得到如下结果:</p><pre tabindex=0><code>Start times:
   0:   0.0
   1:  41.0
   2: 123.0
   3:  91.0
   4:  70.0
   5:   0.0
   6:  70.0
   7:  41.0
   8:  91.0
   9:  41.0
Finish time: 173.0
</code></pre><p>之所以最长路径路径能够解决并行任务调度问题在于s到t的最长路径是所有任务完成所需的最短时间.</p><h3 id=一般加权有向图的最短路径算法>一般加权有向图的最短路径算法<a hidden class=anchor aria-hidden=true href=#一般加权有向图的最短路径算法>#</a></h3><p>考虑包含deadline限制的相对最后期限限制下的并行任务调度问题, 一般的deadline限制都是相对与第一个的任务的开始时间而言, 即在任务调度的问题中加入某个任
务必须在指定的时间点之前开始. 该问题等价于加权有向图中最短路径问题(可以有环和负权重).
构造一个加权有向图与关键路径类似, 但需要为每条deadline限制添加一条边: 如果任务v必须在任务w启动后的d个单位时间内开始, 则添加一条从v指向w且权重为负的
边. 将所有边的权重取反即可得到一个加权有向图的最短路径问题.</p><blockquote><p>当且仅当加权有向图中至少存在一条从s到v的有向路径且其上的任意顶点都不存在与负权重环中时, 最短路径才存在.
对于任意一个负权重的环(权重之和为负数), 重复该环即可得到权重任意小的路径, 而这是无意义的.</p></blockquote><p>因此该算法要求能够:</p><ul><li>对于从起点不可达的顶点, 最短路径是$ +\infty $</li><li>对于从起点可达但存在与一个负权重环的顶点, 最短路径为$ -\infty $</li><li>对于其他顶点, 能够计算最短路径的权重</li></ul><p>Bellman-Ford算法可以解决这样的问题, 基本思想是按节点依次构建最短路径, 于是该算法的时间与VE成正比, 空间和V成正比. 该方法非常通用, 因为其没有规定
边的放松顺序, 且总是放松VE条边. 我不会着力于这个版本, 而是介绍另外一个改进的版本.</p><p><strong>基于队列的Bellman-Ford算法</strong></p><p>我们很容易发现, 原始的版本在每一轮中有很多<code>relax</code>操作都不会成功, 只有在上一轮中起点到该点路径长度改变的点指出的边才能够改变起点到其他顶点的路径长.
为了记录这样的顶点, 可以使用一个FIFO的队列来记录这些点.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>BellmanFordSP</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>double</span><span class=o>[]</span><span class=w> </span><span class=n>distTo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>DirectedEdge</span><span class=o>[]</span><span class=w> </span><span class=n>edgeTo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>onQ</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>queue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>cost</span><span class=p>;</span><span class=w>  </span><span class=c1>// relax调用的次数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>cycle</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>BellmanFordSP</span><span class=p>(</span><span class=n>EdgeWeightedDigraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>double</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>edgeTo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DirectedEdge</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>onQ</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>();</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Double</span><span class=p>.</span><span class=na>POSITIVE_INFINITY</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=o>[</span><span class=n>s</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>queue</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>onQ</span><span class=o>[</span><span class=n>s</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>queue</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=o>!</span><span class=n>hasNegativeCycle</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>queue</span><span class=p>.</span><span class=na>dequeue</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>onQ</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>relax</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>relax</span><span class=p>(</span><span class=n>EdgeWeightedDigraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>DirectedEdge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>to</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>onQ</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>queue</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>w</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>onQ</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>cost</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>cost</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>findNegativeCycle</span><span class=p>();</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>findNegativeCycle</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>edgeTo</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>EdgeWeightedDigraph</span><span class=w> </span><span class=n>spt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>EdgeWeightedDigraph</span><span class=p>(</span><span class=n>V</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>V</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>edgeTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>spt</span><span class=p>.</span><span class=na>addEdge</span><span class=p>(</span><span class=n>edgeTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>EdgeWeightedCycleFinder</span><span class=w> </span><span class=n>cf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>EdgeWeightedCycleFinder</span><span class=p>(</span><span class=n>spt</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cycle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cf</span><span class=p>.</span><span class=na>cycle</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>hasNegativeCycle</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>cycle</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=nf>negativeCycle</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>cycle</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>double</span><span class=w> </span><span class=nf>distTO</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>hasPathTo</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>Double</span><span class=p>.</span><span class=na>POSITIVE_INFINITY</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>DirectedEdge</span><span class=o>&gt;</span><span class=w> </span><span class=nf>pathTo</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Stack</span><span class=o>&lt;</span><span class=n>DirectedEdge</span><span class=o>&gt;</span><span class=w> </span><span class=n>path</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>DirectedEdge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>e</span><span class=p>.</span><span class=na>from</span><span class=p>()</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>path</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>path</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>为了避免负权重出现, 我们需要在每轮进行负权重环的检测.</p><h3 id=加权有向图最短路径算法比较>加权有向图最短路径算法比较<a hidden class=anchor aria-hidden=true href=#加权有向图最短路径算法比较>#</a></h3><table><thead><tr><th style=text-align:center>算法</th><th style=text-align:center>限制</th><th style=text-align:center>时间复杂度</th><th style=text-align:center>空间复杂度</th><th style=text-align:center>优势</th></tr></thead><tbody><tr><td style=text-align:center>Dijkstra算法</td><td style=text-align:center>权重需要为正</td><td style=text-align:center>ElgV</td><td style=text-align:center>V</td><td style=text-align:center>最坏情况下仍有较好性能</td></tr><tr><td style=text-align:center>利用拓扑排序的最短路径算法</td><td style=text-align:center>只适用于无环加权有向图</td><td style=text-align:center>E + V</td><td style=text-align:center>V</td><td style=text-align:center>是无环图中的最优算法</td></tr><tr><td style=text-align:center>Bellman-Ford算法</td><td style=text-align:center>不能存在负权重环</td><td style=text-align:center>E + V(最坏EV)</td><td style=text-align:center>V</td><td style=text-align:center>适用性高</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.sdlinks.net/tags/java/>Java</a></li><li><a href=https://www.sdlinks.net/tags/algorithm/>Algorithm</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 图算法 on x" href="https://x.com/intent/tweet/?text=%e5%9b%be%e7%ae%97%e6%b3%95&amp;url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fgraph-algorithms%2f&amp;hashtags=Java%2cAlgorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 图算法 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fgraph-algorithms%2f&amp;title=%e5%9b%be%e7%ae%97%e6%b3%95&amp;summary=%e5%9b%be%e7%ae%97%e6%b3%95&amp;source=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fgraph-algorithms%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 图算法 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fgraph-algorithms%2f&title=%e5%9b%be%e7%ae%97%e6%b3%95"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 图算法 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fgraph-algorithms%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 图算法 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%9b%be%e7%ae%97%e6%b3%95%20-%20https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fgraph-algorithms%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 图算法 on telegram" href="https://telegram.me/share/url?text=%e5%9b%be%e7%ae%97%e6%b3%95&amp;url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fgraph-algorithms%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 图算法 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%9b%be%e7%ae%97%e6%b3%95&u=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fgraph-algorithms%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=Christophe1997/blog data-repo-id="MDEwOlJlcG9zaXRvcnkyMjU4MTQyMTM=" data-category=Announcements data-category-id=DIC_kwDODXWmxc4CmuF3 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.sdlinks.net/>Neo VRAINS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>