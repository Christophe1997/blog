<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer System 2 | Neo VRAINS</title>
<meta name=keywords content="System"><meta name=description content="Assembler
Computer execute machine code, sequences of bytes encoding the low-level operations that manipulate data manage memory,
read and write data on storage devices, and communicate over networks.
We will focus on x86-64, the commonest machine language used in processor with laptop and PC, also it&rsquo;s widely used in
supercomputer and lager data center.
the x86-64 machine code is much different with the corresponding C code, the processor states below are everywhere:"><meta name=author content="Christophe"><link rel=canonical href=https://www.sdlinks.net/posts/2018/computer-system-2/><meta name=google-site-verification content="Neo VRAINS"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://www.sdlinks.net/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.sdlinks.net/images/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.sdlinks.net/images/favicon-32x32.png><link rel=apple-touch-icon href=https://www.sdlinks.net/images/apple-touch-icon.png><link rel=mask-icon href=https://www.sdlinks.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.sdlinks.net/posts/2018/computer-system-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/katex.min.css><script defer src=/js/katex.min.js></script><script defer src=/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RH029G1TZ5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RH029G1TZ5")}</script><meta property="og:url" content="https://www.sdlinks.net/posts/2018/computer-system-2/"><meta property="og:site_name" content="Neo VRAINS"><meta property="og:title" content="Computer System 2"><meta property="og:description" content="Assembler Computer execute machine code, sequences of bytes encoding the low-level operations that manipulate data manage memory, read and write data on storage devices, and communicate over networks.
We will focus on x86-64, the commonest machine language used in processor with laptop and PC, also it’s widely used in supercomputer and lager data center.
the x86-64 machine code is much different with the corresponding C code, the processor states below are everywhere:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-05-28T17:20:36+00:00"><meta property="article:modified_time" content="2018-05-28T17:20:36+00:00"><meta property="article:tag" content="System"><meta name=twitter:card content="summary"><meta name=twitter:title content="Computer System 2"><meta name=twitter:description content="Assembler
Computer execute machine code, sequences of bytes encoding the low-level operations that manipulate data manage memory,
read and write data on storage devices, and communicate over networks.
We will focus on x86-64, the commonest machine language used in processor with laptop and PC, also it&rsquo;s widely used in
supercomputer and lager data center.
the x86-64 machine code is much different with the corresponding C code, the processor states below are everywhere:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.sdlinks.net/posts/"},{"@type":"ListItem","position":2,"name":"Computer System 2","item":"https://www.sdlinks.net/posts/2018/computer-system-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Computer System 2","name":"Computer System 2","description":"Assembler Computer execute machine code, sequences of bytes encoding the low-level operations that manipulate data manage memory, read and write data on storage devices, and communicate over networks.\nWe will focus on x86-64, the commonest machine language used in processor with laptop and PC, also it\u0026rsquo;s widely used in supercomputer and lager data center.\nthe x86-64 machine code is much different with the corresponding C code, the processor states below are everywhere:\n","keywords":["System"],"articleBody":"Assembler Computer execute machine code, sequences of bytes encoding the low-level operations that manipulate data manage memory, read and write data on storage devices, and communicate over networks.\nWe will focus on x86-64, the commonest machine language used in processor with laptop and PC, also it’s widely used in supercomputer and lager data center.\nthe x86-64 machine code is much different with the corresponding C code, the processor states below are everywhere:\nprogram counter: called “%rip”, indicates the address in memory of the next instruction to be executed. the integer register file contains 16 named location storing 64-bit values. the condition code register hold status information about the most recently executed arithmetic or logical instruction. a set of vector registers store one or more integer and floating-point data. for example, the below C code: 1 2 3 4 5 6 7 //mstore.c long mult2(long, long); void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t; } could have the assembly code used by gcc -Og -S mstore.c command:\n//mstore.s\r.file\t\"mstore.c\"\r.text\r.globl\tmultstore\r.type\tmultstore, @function\rmultstore:\r.LFB0:\r.cfi_startproc\rpushq\t%rbx\r.cfi_def_cfa_offset 16\r.cfi_offset 3, -16\rmovq\t%rdx, %rbx\rcall\tmult2\rmovq\t%rax, (%rbx)\rpopq\t%rbx\r.cfi_def_cfa_offset 8\rret\r.cfi_endproc\r.LFE0:\r.size\tmultstore, .-multstore\r.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\r.section\t.note.GNU-stack,\"\",@progbits where the lines beginning with ‘.’ are directives to guide the assembler and linker, we can generally ignore these, thus we obtain(in ATT format distinguish with Intel format):\nmultstore:\rpushq\t%rbx\rmovq\t%rdx, %rbx\rcall\tmult2\rmovq\t%rax, (%rbx)\rpopq\t%rbx\rret Intel use term word to represent 16-bit data types, so it calls 32-bit as double words, and 64-bit as quad words. The table below illsulates the default C data types and its x86-64 representation.\nC declartive Intel data type assembly suffix size(byte) char byte b 1 short word w 2 int double words l 4 long quad words q 8 char* quad words q 8 float single-precision s 4 double double-precision l 8 A x86-64 CPU contains a set of 16 universal destination registers storing 64-bit values. They are: %rax, %rbx, %rcx, %rdx, %rsi, %rdi, %rbp, %rsp(in 32-bit those begin with e, e.g. %eax), %r8 to %r15(in 32-bit those ends with d, e.g. %r9d). It’s worth noting that the stack point %rsp, which indicates the address of program finished stack.\nData movement instructions Among the most heavily used instructions are those that copy data from one location to another. The most simplest instructions is the MOV class, cosists of four instructions: movb, movw, movl, movq; they differ only in that they operate on data of size 1, 2, 4 and 8 bytes. In most casees, MOV only update the register and memory address indicated by the operands, but movl will fill the left bit with 0 in a register with a 32-bit data, which is the convention in x86-64. The MOVZ class will always fill the other bit with zero, while the MOVS class fill by sign expansion. MOVS and MOVZ always ends with two characters indicates the size of size, e.g. movzbw moves byte to word with zero expansion. but there no movzlq because it could replaced by movl as we mentioned above. The cltq always moves from %eax to %rax with sign expansion, so it is the same as movslq %eax, %rax.\nThe final two data movement instructions are used to push data onto and pop data from the program stack: pushq and popq. For example to push a quad words onto a stack, first we subtract %rsp(the stack point) with 8(the stack grows from high address to low address) and write the data to the new address of %rsp. Since the stack is contained in the same memory as the program code and other forms of program data, programs can access arbitrary positions within the stack using the standard memory addressing methods.\nArithmetic and logical operations Instruction Effect Description leal S, D D := \u0026S Load effective address INC D D := D + 1 Increment DEC D D := D - 1 Decrement NEG D D := -D Negate NOT D D := ~D Complement ADD S, D D := D + S Add SUB S, D D := D - S Subtract IMUL S, D D := D * S Multiply XOR S, D D := D ^ S Exclusive-or OR S, D D := D | S Or AND S, D D := D \u0026 S And SAL k, D D := D « k Left shift SHL k, D D := D « k the same as SAL SAR k, D D := D » k Arithmetic right shift(with sign expansion) SHR k, D D := D » k Logical right shift(with zero expansion) The load effective address instruction leal is actually a variant of the movl instruction. It just works as the \u0026 in C. In addition, it can be used co compactly describe common arithmetic operations, e.g. if register %edx contains value x, then the instruction leal 7(%edx, \u0026edx, 4), %eax will set register %eax to 5x+7. But the destination operand must be a register.\nFor shift operations, the shift amount is given either as an immediate or in the single-byte register element %c1(in %rcx),\nControl Machine code provides two basic low-level mechanisms for implementing coditional behavior: it tests data values and then either alters the control flow or the data flow based on the result of these test. Data-dependent control flow is the more general and more common approach for implementing coditional behavior. The execution order of a set of machine-code instructions can be altered with jump instruction, indicating that control should pass to some other part of the program, possibly contingent on the result of some test.\nIn addition to the integer register, the CPU maintains a set of single-bit condition code register describing attributes of the most rescent arthmetic or logical operation. These register can then be tested to perform conditional branches. The most useful cndition codes are:\nCF: Carry Flag. The most recent operation generated a carry out of the most significant bit. Used to detect overflow for unsigned operations ZF: Zero Flag. The most recent operation yielded zero. SF: Sign Flag. The most recent operation yielded negative value. OF: Overflow Flag. The most recent operation caused a two’s-complement overflow, either negative or positive. For example, suppose we used one of the ADD instructions to perform the equivalent of the C assignment t=a+b, where variables a, b, and t are integers. Then the condition codes would be set according to the following C expressions:\nCF: (unsigned) t \u003c (unsigned) a Unsigned overflow ZF: t == 0 Zero SF: t \u003c 0 Negative OF: (a \u003c 0 == b \u003c 0) \u0026\u0026 (t \u003c 0 != a \u003c 0) Signed overflow There are two instruction classes that set condition codes without altering any other registers, the CMP class and TEST class. The CMP instructions behave in the same manner as the SUB instructions except that they don’t update their destinations. The TEST instructions behave in the same manner as the And instructions except that they don’t update their destinations, too.\nRather than reading the condition codes directly, there are three common ways of using the codition code:\nwe can set a single byte to 0 or 1 depending on somecombination of the condition codes we can coditionally jump to some other part og the program, or we can conditionally transfer data. For the first case, there are SET class instructions to set a single byte to 0 or 1 depending on some combination of the condition codes. e.g. setl and setb denote “set less” and “set below”\nA jump instruction can cause the execution to switch to a completely new position in the program. These jump destinations are negerally indicated in assembly code by a label\nTranslating Conditional Branches The most general way to translate conditional expressions and statement from C into machine code is to use combinations of conditional and unconditional jumps.\nThe general form of an if-else statement in C is given by the template\n1 2 3 4 if (test-expr) then-statement else else-statement for this general form the assmebly implementation typically adheres to the following form, where we use C syntax(use goto) to describe the control flow.\n1 2 3 4 5 6 7 8 t = test-expr if (!t) goto false; then-statement goto done; false: else-statement done: Translating conditional branches by control is simple and in common use. But in modern processor, it sometimes may be much inefficient. A substitution strategy is using data to translate conditional branches, this strategy compute both branches’ result and choose one according to the condition. It could only be feasible in some constraint situation, but if feasible, then we can use one conditional transfer instruction to implement.\nTo explain why using conditional transfer is faster than using control(jump), we need to know how instructions are executed in processor. Moder processor gains high performance by using pipelining. In pipelining, it takes many phases to process a instruction, such like read instruction from memory, determine the class of instruction, etc. This method obtains high performace by coinciding sequential those phases of instructions, e.g. the processor could execute the arithmetic of the previous instruction while reading the current instruction. To do this, the processor need to know the order of instructions sequence before, to ensure that there are enough instruction to execute. Then we stand on the conditional branch, the processor need to compute what branch to go. Though moder processor using very accurate branch prediction logic to predict which jump instructions will be execute(the accuracy \u003e 90%) to assure there are enough instruction in the pipelining, it have to deprecate the work done for the wrong jump instruction, which takes 15~30 clock cycle. On the other hand, it would always takes 8 clock cycle by data transfer, it not depending what the data like, thus it would be easy to fill the piplining with instructions.\nThe CMOVE class implaments for conditional move(e.g. cmovene S R, move data from S to R while). Consider the expression v = test-expr : then-expr : else-expr, using control to compile it could be below:\n1 2 3 4 5 6 7 if (!test-expr) goto false; v = then-expr; goto done; false: v = else-expr; done: either then-expr or else-expr would be execute, while using conditional transfer it would execute both of them:\n1 2 3 4 v = then-expr; ve = else-expr; t = test-expr; if(!t) v = ve; So, it’s easy to see that it could be much slow if the cost if then-expr and else-expr is too expensive.\nLoop Do-while loop do-while have the form below:\n1 2 3 do body-statement while (test-expr) it can be translate into conditionals and goto statements as follow:\n1 2 3 4 5 loop: body-statement t = test-expr; if (t) goto loop; While loop while loop have the form below:\n1 2 while (test-expr) body-statement There multiple ways to translate it, the GCC uses two of them, the first is called jump to middle, in goto form that is:\n1 2 3 4 5 6 7 goto test; loop: body-statement test: t = test-expr; if (t) goto loop; the second method is called guarded-do, it first translate to the do-while form:\n1 2 3 4 5 6 7 t = test-expr; if (!t) goto done; do body-statement while (test-expr); done: futher more, it can be translated below:\n1 2 3 4 5 6 7 8 9 t = test-expr; if (!t) goto done; loop: body-statement t = test-expr; if (t) goto loop; done: GCC would translate while loop in guarded-do form with -O1 option.\nFor loop for loop has the form below:\n1 2 for (init-expr; test-expr; update-expr) body-statement C standard indicate that it is the same as the while loop below(except one situation):\n1 2 3 4 init-expr while (test-expr) body-statement update-expr; So GCC translate the for loop as same as the while loop above, choosing which form depending to the optimization degree.\nSwitch statement A switch statement provides a multi way branching capability vased on the value of an integer index. They are particularly useful when dealing with tests where there can be a large number of possible outcomes. Not only do they make the C code more readable, they also allow an efficiant implementation using a data structure called jump table. JUmp tables are used when there are a number of cases(e.g. four or more) and they span a small range of values. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void switch_eg(long x, long n, long *dest) { long val = x; switch (n) { case 100: val *= 13; break; case 102: val += 10; case 103: val += 11; break; case 104: case 106: val *= val; break; default: val = 0; } *dest = val; } the code above would be translated below by a jump table:\nswitch_eg:\r.LFB0:\r.cfi_startproc\rsubq\t$100, %rsi\rcmpq\t$6, %rsi\rja\t.L8\rjmp\t*.L4(,%rsi,8) the jump table\r.section\t.rodata\r.align 8\r.align 4\r.L4:\r.quad\t.L3\r.quad\t.L8\r.quad\t.L5\r.quad\t.L6\r.quad\t.L7\r.quad\t.L8\r.quad\t.L7\r.text\r.L3:\rleaq\t(%rdi,%rdi,2), %rax\rleaq\t(%rdi,%rax,4), %rdi\rjmp\t.L2\r.L5:\raddq\t$10, %rdi\r.L6:\raddq\t$11, %rdi\rjmp\t.L2\r.L7:\rimulq\t%rdi, %rdi\rjmp\t.L2\r.L8:\rmovl\t$0, %edi\r.L2:\rmovq\t%rdi, (%rdx)\rret\r.cfi_endproc Procedures A procedure call involves passing both data and control form one part of program to another, it could have different form in different language: function, method, subroutine, handler. To supprot procedures, machine must have the abilities:\ntransfer control transfer data allocate and deallocate memory sapce. Runtime stack While the x86-64 procedure need more spaces than register have, then it would allocate space on stack, which called a stack frame of the procedure. If all local variables could be stored in register, the procedure don’t need the stack frame.\nTransfer control To transfer control from procedure P to Q, it just simply set the PC with the start of Q, x86-64 uses call Q to push address A and then set the PC with the start of Q, the corresponding instruction ret would pop the address A, and set the PC with A.\nTransfer data In x86-64, it can store 6 parameters in register at most, for 64-bit size data, they stored in the order: %rdi, %rsi, %rdx %rcx, %r8, %r9. So the parameters beyond should transfer by stack.\nRegister local space Register is the only resource shared by all procedures. Conventionally, register %rbx, %rbp and %r12 ~ %r15 are called callee-saved registers, this means when procedure Q is called by P, then Q must save the values of any of these registers on the stack before overwriting them and restore them before returning. Any other registers except the stack point %rsp are called caller-saved registers, this means any procedure can overwriting this registers without restoring. The prefix of “saved” means who should store the data before pass the control to another procedure.\nOut-of-Bounds Memory References and Buffer Overflow We have see that C does not perform any bounds checking for array references, and that local variables are stored on the stack along with state information such as saved register values and return addresses. This combination can lead to serious program errors, where the state stored on the stack gets corrupted by a write to an out-of-bounds array element. When the program then tries to reload the register or execute a ret instruction with this corrupted state, things can go seriously wrong.\n","wordCount":"2608","inLanguage":"en","datePublished":"2018-05-28T17:20:36Z","dateModified":"2018-05-28T17:20:36Z","author":{"@type":"Person","name":"Christophe"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sdlinks.net/posts/2018/computer-system-2/"},"publisher":{"@type":"Organization","name":"Neo VRAINS","logo":{"@type":"ImageObject","url":"https://www.sdlinks.net/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.sdlinks.net/ accesskey=h title="Neo VRAINS (Alt + H)">Neo VRAINS</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.sdlinks.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.sdlinks.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.sdlinks.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://www.sdlinks.net/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Computer System 2</h1><div class=post-meta><span title='2018-05-28 17:20:36 +0000 UTC'>May 28, 2018</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;<a href=/categories/things-i-learned> Things I Learned</a></div></header><div class=post-content><h2 id=assembler>Assembler<a hidden class=anchor aria-hidden=true href=#assembler>#</a></h2><p>Computer execute machine code, sequences of bytes encoding the low-level operations that manipulate data manage memory,
read and write data on storage devices, and communicate over networks.</p><p>We will focus on x86-64, the commonest machine language used in processor with laptop and PC, also it&rsquo;s widely used in
supercomputer and lager data center.</p><p>the x86-64 machine code is much different with the corresponding C code, the processor states below are everywhere:</p><ul><li><em>program counter</em>: called &ldquo;%rip&rdquo;, indicates the address in memory of the next instruction to be executed.</li><li>the integer register file contains 16 named location storing 64-bit values.</li><li>the condition code register hold status information about the most recently executed arithmetic or logical instruction.</li><li>a set of vector registers store one or more integer and floating-point data.
for example, the below C code:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>//mstore.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>long</span> <span class=nf>mult2</span><span class=p>(</span><span class=kt>long</span><span class=p>,</span> <span class=kt>long</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>multstore</span><span class=p>(</span><span class=kt>long</span> <span class=n>x</span><span class=p>,</span> <span class=kt>long</span> <span class=n>y</span><span class=p>,</span> <span class=kt>long</span> <span class=o>*</span><span class=n>dest</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>t</span> <span class=o>=</span> <span class=nf>mult2</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>could have the assembly code used by <code>gcc -Og -S mstore.c</code> command:</p><pre tabindex=0><code>//mstore.s
	.file	&#34;mstore.c&#34;
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	&#34;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609&#34;
	.section	.note.GNU-stack,&#34;&#34;,@progbits
</code></pre><p>where the lines beginning with ‘.’ are directives to guide the assembler and linker, we can generally ignore these, thus
we obtain(in ATT format distinguish with Intel format):</p><pre tabindex=0><code>multstore:
	pushq	%rbx
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	ret
</code></pre><p>Intel use term <em>word</em> to represent 16-bit data types, so it calls 32-bit as <em>double words</em>, and 64-bit as <em>quad words</em>.
The table below illsulates the default C data types and its x86-64 representation.</p><table><thead><tr><th style=text-align:center>C declartive</th><th style=text-align:center>Intel data type</th><th style=text-align:center>assembly suffix</th><th style=text-align:center>size(byte)</th></tr></thead><tbody><tr><td style=text-align:center>char</td><td style=text-align:center>byte</td><td style=text-align:center>b</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>short</td><td style=text-align:center>word</td><td style=text-align:center>w</td><td style=text-align:center>2</td></tr><tr><td style=text-align:center>int</td><td style=text-align:center>double words</td><td style=text-align:center>l</td><td style=text-align:center>4</td></tr><tr><td style=text-align:center>long</td><td style=text-align:center>quad words</td><td style=text-align:center>q</td><td style=text-align:center>8</td></tr><tr><td style=text-align:center>char*</td><td style=text-align:center>quad words</td><td style=text-align:center>q</td><td style=text-align:center>8</td></tr><tr><td style=text-align:center>float</td><td style=text-align:center>single-precision</td><td style=text-align:center>s</td><td style=text-align:center>4</td></tr><tr><td style=text-align:center>double</td><td style=text-align:center>double-precision</td><td style=text-align:center>l</td><td style=text-align:center>8</td></tr></tbody></table><p>A x86-64 CPU contains a set of 16 universal destination registers storing 64-bit values. They are: %rax, %rbx, %rcx, %rdx,
%rsi, %rdi, %rbp, %rsp(in 32-bit those begin with e, e.g. %eax), %r8 to %r15(in 32-bit those ends with d, e.g. %r9d).
It&rsquo;s worth noting that the stack point %rsp, which indicates the address of program finished stack.</p><h3 id=data-movement-instructions>Data movement instructions<a hidden class=anchor aria-hidden=true href=#data-movement-instructions>#</a></h3><p>Among the most heavily used instructions are those that copy data from one location to another. The most simplest instructions
is the MOV class, cosists of four instructions: <code>movb</code>, <code>movw</code>, <code>movl</code>, <code>movq</code>; they differ only in that they operate on data
of size 1, 2, 4 and 8 bytes. In most casees, MOV only update the register and memory address indicated by the operands,
but <code>movl</code> will fill the left bit with 0 in a register with a 32-bit data, which is the convention in x86-64. The MOVZ class
will always fill the other bit with zero, while the MOVS class fill by sign expansion. MOVS and MOVZ always ends with
two characters indicates the size of size, e.g. <code>movzbw</code> moves byte to word with zero expansion. but there no movzlq
because it could replaced by <code>movl</code> as we mentioned above. The <code>cltq</code> always moves from %eax to %rax with sign expansion,
so it is the same as <code>movslq %eax, %rax</code>.</p><p>The final two data movement instructions are used to push data onto and pop data from the program stack: pushq and popq.
For example to push a quad words onto a stack, first we subtract %rsp(the stack point) with 8(the stack grows from high
address to low address) and write the data to the new address of %rsp. Since the stack is contained in the same memory as
the program code and other forms of program data, programs can access arbitrary positions within the stack using the
standard memory addressing methods.</p><h3 id=arithmetic-and-logical-operations>Arithmetic and logical operations<a hidden class=anchor aria-hidden=true href=#arithmetic-and-logical-operations>#</a></h3><table><thead><tr><th style=text-align:center>Instruction</th><th style=text-align:center>Effect</th><th style=text-align:center>Description</th></tr></thead><tbody><tr><td style=text-align:center>leal S, D</td><td style=text-align:center>D := &amp;S</td><td style=text-align:center>Load effective address</td></tr><tr><td style=text-align:center>INC D</td><td style=text-align:center>D := D + 1</td><td style=text-align:center>Increment</td></tr><tr><td style=text-align:center>DEC D</td><td style=text-align:center>D := D - 1</td><td style=text-align:center>Decrement</td></tr><tr><td style=text-align:center>NEG D</td><td style=text-align:center>D := -D</td><td style=text-align:center>Negate</td></tr><tr><td style=text-align:center>NOT D</td><td style=text-align:center>D := ~D</td><td style=text-align:center>Complement</td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>ADD S, D</td><td style=text-align:center>D := D + S</td><td style=text-align:center>Add</td></tr><tr><td style=text-align:center>SUB S, D</td><td style=text-align:center>D := D - S</td><td style=text-align:center>Subtract</td></tr><tr><td style=text-align:center>IMUL S, D</td><td style=text-align:center>D := D * S</td><td style=text-align:center>Multiply</td></tr><tr><td style=text-align:center>XOR S, D</td><td style=text-align:center>D := D ^ S</td><td style=text-align:center>Exclusive-or</td></tr><tr><td style=text-align:center>OR S, D</td><td style=text-align:center>D := D | S</td><td style=text-align:center>Or</td></tr><tr><td style=text-align:center>AND S, D</td><td style=text-align:center>D := D & S</td><td style=text-align:center>And</td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>SAL k, D</td><td style=text-align:center>D := D &#171; k</td><td style=text-align:center>Left shift</td></tr><tr><td style=text-align:center>SHL k, D</td><td style=text-align:center>D := D &#171; k</td><td style=text-align:center>the same as SAL</td></tr><tr><td style=text-align:center>SAR k, D</td><td style=text-align:center>D := D &#187; k</td><td style=text-align:center>Arithmetic right shift(with sign expansion)</td></tr><tr><td style=text-align:center>SHR k, D</td><td style=text-align:center>D := D &#187; k</td><td style=text-align:center>Logical right shift(with zero expansion)</td></tr></tbody></table><p>The <em>load effective address</em> instruction leal is actually a variant of the movl instruction. It just works as the <code>&</code> in C.
In addition, it can be used co compactly describe common arithmetic operations, e.g. if register %edx contains value x,
then the instruction <code>leal 7(%edx, &amp;edx, 4), %eax</code> will set register %eax to 5x+7. But the destination operand must be a
register.</p><p>For shift operations, the shift amount is given either as an immediate or in the single-byte register element %c1(in %rcx),</p><h3 id=control>Control<a hidden class=anchor aria-hidden=true href=#control>#</a></h3><p>Machine code provides two basic low-level mechanisms for implementing coditional behavior: it tests data values and then
either alters the control flow or the data flow based on the result of these test. Data-dependent control flow is the
more general and more common approach for implementing coditional behavior. The execution order of a set of machine-code
instructions can be altered with <em>jump</em> instruction, indicating that control should pass to some other part of the program,
possibly contingent on the result of some test.</p><p>In addition to the integer register, the CPU maintains a set of single-bit <em>condition code</em> register describing attributes
of the most rescent arthmetic or logical operation. These register can then be tested to perform conditional branches.
The most useful cndition codes are:</p><ul><li>CF: Carry Flag. The most recent operation generated a carry out of the most significant bit. Used to detect overflow
for unsigned operations</li><li>ZF: Zero Flag. The most recent operation yielded zero.</li><li>SF: Sign Flag. The most recent operation yielded negative value.</li><li>OF: Overflow Flag. The most recent operation caused a two&rsquo;s-complement overflow, either negative or positive.</li></ul><p>For example, suppose we used one of the ADD instructions to perform the equivalent of the C assignment <code>t=a+b</code>, where
variables a, b, and t are integers. Then the condition codes would be set according to the following C expressions:</p><ul><li>CF: <code>(unsigned) t &lt; (unsigned) a</code> Unsigned overflow</li><li>ZF: <code>t == 0</code> Zero</li><li>SF: <code>t &lt; 0</code> Negative</li><li>OF: <code>(a &lt; 0 == b &lt; 0) && (t &lt; 0 != a &lt; 0)</code> Signed overflow</li></ul><p>There are two instruction classes that set condition codes without altering any other registers, the CMP class and TEST
class. The CMP instructions behave in the same manner as the SUB instructions except that they don&rsquo;t update their destinations.
The TEST instructions behave in the same manner as the And instructions except that they don&rsquo;t update their destinations,
too.</p><p>Rather than reading the condition codes directly, there are three common ways of using the codition code:</p><ol><li>we can set a single byte to 0 or 1 depending on somecombination of the condition codes</li><li>we can coditionally jump to some other part og the program, or</li><li>we can conditionally transfer data.</li></ol><p>For the first case, there are SET class instructions to set a single byte to 0 or 1 depending on some combination of the
condition codes. e.g. <code>setl</code> and <code>setb</code> denote &ldquo;set less&rdquo; and &ldquo;set below&rdquo;</p><p>A <em>jump</em> instruction can cause the execution to switch to a completely new position in the program. These jump destinations
are negerally indicated in assembly code by a <em>label</em></p><h2 id=translating-conditional-branches>Translating Conditional Branches<a hidden class=anchor aria-hidden=true href=#translating-conditional-branches>#</a></h2><p>The most general way to translate conditional expressions and statement from C into machine code is to use combinations
of conditional and unconditional jumps.</p><p>The general form of an if-else statement in C is given by the template</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>then</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>-</span><span class=n>statement</span>
</span></span></code></pre></td></tr></table></div></div><p>for this general form the assmebly implementation typically adheres to the following form, where we use C syntax(use goto)
to describe the control flow.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>then</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl><span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nb>false</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl><span class=nl>done</span><span class=p>:</span>
</span></span></code></pre></td></tr></table></div></div><p>Translating conditional branches by control is simple and in common use. But in modern processor, it sometimes may be
much inefficient. A substitution strategy is using data to translate conditional branches, this strategy compute both
branches&rsquo; result and choose one according to the condition. It could only be feasible in some constraint situation, but
if feasible, then we can use one conditional transfer instruction to implement.</p><p>To explain why using conditional transfer is faster than using control(jump), we need to know how instructions are executed
in processor. Moder processor gains high performance by using pipelining. In pipelining, it takes many phases to process
a instruction, such like read instruction from memory, determine the class of instruction, etc. This method obtains high
performace by coinciding sequential those phases of instructions, e.g. the processor could execute the arithmetic of the
previous instruction while reading the current instruction. To do this, the processor need to know the order of instructions
sequence before, to ensure that there are enough instruction to execute. Then we stand on the conditional branch, the
processor need to compute what branch to go. Though moder processor using very accurate branch prediction logic to predict
which jump instructions will be execute(the accuracy > 90%) to assure there are enough instruction in the pipelining, it
have to deprecate the work done for the wrong jump instruction, which takes 15~30 clock cycle. On the other hand, it would
always takes 8 clock cycle by data transfer, it not depending what the data like, thus it would be easy to fill the piplining
with instructions.</p><p>The CMOVE class implaments for conditional move(e.g. cmovene S R, move data from S to R while). Consider the expression
<code>v = test-expr : then-expr : else-expr</code>, using control to compile it could be below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>then</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nb>false</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span> <span class=o>=</span> <span class=k>else</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>done</span><span class=p>:</span>
</span></span></code></pre></td></tr></table></div></div><p>either then-expr or else-expr would be execute, while using conditional transfer it would execute both of them:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>then</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>ve</span> <span class=o>=</span> <span class=k>else</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span> <span class=n>v</span> <span class=o>=</span> <span class=n>ve</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>So, it&rsquo;s easy to see that it could be much slow if the cost if <code>then-expr</code> and <code>else-expr</code> is too expensive.</p><h2 id=loop>Loop<a hidden class=anchor aria-hidden=true href=#loop>#</a></h2><h3 id=do-while-loop>Do-while loop<a hidden class=anchor aria-hidden=true href=#do-while-loop>#</a></h3><p>do-while have the form below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>it can be translate into conditionals and goto statements as follow:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nl>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>loop</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=while-loop>While loop<a hidden class=anchor aria-hidden=true href=#while-loop>#</a></h3><p>while loop have the form below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span></code></pre></td></tr></table></div></div><p>There multiple ways to translate it, the GCC uses two of them, the first is called <em>jump to middle</em>, in goto form that is:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>goto</span> <span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl><span class=nl>test</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>loop</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>the second method is called guarded-do, it first translate to the do-while form:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nl>done</span><span class=p>:</span>
</span></span></code></pre></td></tr></table></div></div><p>futher more, it can be translated below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>loop</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>done</span><span class=p>:</span>
</span></span></code></pre></td></tr></table></div></div><p>GCC would translate while loop in guarded-do form with <code>-O1</code> option.</p><h3 id=for-loop>For loop<a hidden class=anchor aria-hidden=true href=#for-loop>#</a></h3><p>for loop has the form below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>init</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> <span class=n>update</span><span class=o>-</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span></code></pre></td></tr></table></div></div><p>C standard indicate that it is the same as the while loop below(except one situation):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>init</span><span class=o>-</span><span class=n>expr</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl>    <span class=n>update</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>So GCC translate the for loop as same as the while loop above, choosing which form depending to the optimization degree.</p><h3 id=switch-statement>Switch statement<a hidden class=anchor aria-hidden=true href=#switch-statement>#</a></h3><p>A switch statement provides a multi way branching capability vased on the value of an integer index. They are particularly
useful when dealing with tests where there can be a large number of possible outcomes. Not only do they make the C code
more readable, they also allow an efficiant implementation using a data structure called <em>jump table</em>. JUmp tables are
used when there are a number of cases(e.g. four or more) and they span a small range of values. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>switch_eg</span><span class=p>(</span><span class=kt>long</span> <span class=n>x</span><span class=p>,</span> <span class=kt>long</span> <span class=n>n</span><span class=p>,</span> <span class=kt>long</span> <span class=o>*</span><span class=n>dest</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>val</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>100</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>val</span> <span class=o>*=</span> <span class=mi>13</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>102</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>val</span> <span class=o>+=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>103</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>val</span> <span class=o>+=</span> <span class=mi>11</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>104</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>106</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>val</span> <span class=o>*=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>val</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>the code above would be translated below by a jump table:</p><pre tabindex=0><code>switch_eg:
.LFB0:
	.cfi_startproc
	subq	$100, %rsi
	cmpq	$6, %rsi
	ja	.L8
	jmp	*.L4(,%rsi,8)               the jump table
	.section	.rodata
	.align 8
	.align 4
.L4:
	.quad	.L3
	.quad	.L8
	.quad	.L5
	.quad	.L6
	.quad	.L7
	.quad	.L8
	.quad	.L7
	.text
.L3:
	leaq	(%rdi,%rdi,2), %rax
	leaq	(%rdi,%rax,4), %rdi
	jmp	.L2
.L5:
	addq	$10, %rdi
.L6:
	addq	$11, %rdi
	jmp	.L2
.L7:
	imulq	%rdi, %rdi
	jmp	.L2
.L8:
	movl	$0, %edi
.L2:
	movq	%rdi, (%rdx)
	ret
	.cfi_endproc
</code></pre><h2 id=procedures>Procedures<a hidden class=anchor aria-hidden=true href=#procedures>#</a></h2><p>A procedure call involves passing both data and control form one part of program to another, it could have different form
in different language: function, method, subroutine, handler. To supprot procedures, machine must have the abilities:</p><ul><li>transfer control</li><li>transfer data</li><li>allocate and deallocate memory sapce.</li></ul><h3 id=runtime-stack>Runtime stack<a hidden class=anchor aria-hidden=true href=#runtime-stack>#</a></h3><p>While the x86-64 procedure need more spaces than register have, then it would allocate space on stack, which called a
stack frame of the procedure. If all local variables could be stored in register, the procedure don&rsquo;t need the stack frame.</p><h3 id=transfer-control>Transfer control<a hidden class=anchor aria-hidden=true href=#transfer-control>#</a></h3><p>To transfer control from procedure P to Q, it just simply set the PC with the start of Q, x86-64 uses <code>call Q</code> to push
address A and then set the PC with the start of Q, the corresponding instruction <code>ret</code> would pop the address A, and set
the PC with A.</p><h3 id=transfer-data>Transfer data<a hidden class=anchor aria-hidden=true href=#transfer-data>#</a></h3><p>In x86-64, it can store 6 parameters in register at most, for 64-bit size data, they stored in the order: %rdi, %rsi, %rdx
%rcx, %r8, %r9. So the parameters beyond should transfer by stack.</p><h3 id=register-local-space>Register local space<a hidden class=anchor aria-hidden=true href=#register-local-space>#</a></h3><p>Register is the only resource shared by all procedures. Conventionally, register %rbx, %rbp and %r12 ~ %r15 are called
<em>callee-saved</em> registers, this means when procedure Q is called by P, then Q must save the values of any of these registers
on the stack before overwriting them and restore them before returning. Any other registers except the stack point %rsp
are called <em>caller-saved</em> registers, this means any procedure can overwriting this registers without restoring. The prefix
of &ldquo;saved&rdquo; means who should store the data before pass the control to another procedure.</p><h2 id=out-of-bounds-memory-references-and-buffer-overflow>Out-of-Bounds Memory References and Buffer Overflow<a hidden class=anchor aria-hidden=true href=#out-of-bounds-memory-references-and-buffer-overflow>#</a></h2><p>We have see that C does not perform any bounds checking for array references, and that local variables are stored on the
stack along with state information such as saved register values and return addresses. This combination can lead to serious
program errors, where the state stored on the stack gets corrupted by a write to an out-of-bounds array element. When the
program then tries to reload the register or execute a <code>ret</code> instruction with this corrupted state, things can go seriously
wrong.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.sdlinks.net/tags/system/>System</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 2 on x" href="https://x.com/intent/tweet/?text=Computer%20System%202&amp;url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-2%2f&amp;hashtags=System"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-2%2f&amp;title=Computer%20System%202&amp;summary=Computer%20System%202&amp;source=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 2 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-2%2f&title=Computer%20System%202"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 2 on whatsapp" href="https://api.whatsapp.com/send?text=Computer%20System%202%20-%20https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 2 on telegram" href="https://telegram.me/share/url?text=Computer%20System%202&amp;url=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer System 2 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Computer%20System%202&u=https%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2fcomputer-system-2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=Christophe1997/blog data-repo-id="MDEwOlJlcG9zaXRvcnkyMjU4MTQyMTM=" data-category=Announcements data-category-id=DIC_kwDODXWmxc4CmuF3 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.sdlinks.net/>Neo VRAINS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>