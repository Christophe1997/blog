<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Functional Data Structure 2 | CastOff</title>
<meta name=keywords content="OCaml,Functional"><meta name=description content="Amortization
Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case
bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about
the running time of any individual operation.
For instance, given a sequence of n operations, we may wish to bound the
total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might
be satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n).
This freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and
faster than worst-case solutions with equivalent bounds."><meta name=author content="Christophe"><link rel=canonical href=http://www.sdlinks.net/posts/2018/functional-data-structure-2/><meta name=google-site-verification content="CastOff"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://www.sdlinks.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://www.sdlinks.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://www.sdlinks.net/favicon-32x32.png><link rel=apple-touch-icon href=http://www.sdlinks.net/apple-touch-icon.png><link rel=mask-icon href=http://www.sdlinks.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://www.sdlinks.net/posts/2018/functional-data-structure-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://www.sdlinks.net/posts/2018/functional-data-structure-2/"><meta property="og:site_name" content="CastOff"><meta property="og:title" content="Functional Data Structure 2"><meta property="og:description" content="Amortization Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about the running time of any individual operation.
For instance, given a sequence of n operations, we may wish to bound the total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might be satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n). This freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and faster than worst-case solutions with equivalent bounds."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-07-24T15:54:24+00:00"><meta property="article:modified_time" content="2018-07-24T15:54:24+00:00"><meta property="article:tag" content="OCaml"><meta property="article:tag" content="Functional"><meta name=twitter:card content="summary"><meta name=twitter:title content="Functional Data Structure 2"><meta name=twitter:description content="Amortization
Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case
bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about
the running time of any individual operation.
For instance, given a sequence of n operations, we may wish to bound the
total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might
be satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n).
This freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and
faster than worst-case solutions with equivalent bounds."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://www.sdlinks.net/posts/"},{"@type":"ListItem","position":2,"name":"Functional Data Structure 2","item":"http://www.sdlinks.net/posts/2018/functional-data-structure-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Functional Data Structure 2","name":"Functional Data Structure 2","description":"Amortization Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about the running time of any individual operation.\nFor instance, given a sequence of n operations, we may wish to bound the total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might be satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n). This freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and faster than worst-case solutions with equivalent bounds.\n","keywords":["OCaml","Functional"],"articleBody":"Amortization Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about the running time of any individual operation.\nFor instance, given a sequence of n operations, we may wish to bound the total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might be satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n). This freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and faster than worst-case solutions with equivalent bounds.\nTo provide an amortized bound, one defines the amortized cost of each operation and then proves that, for any sequence of operations, the total amortized cost of the operations in an upper bound on the total actual cost, $$ \\sum_{i=1}^m a_i \\geq \\sum_{i=1}^m t_i $$ where $ a_i $ is the amortized cost of operation i, $t_i$ is the actual cost of operation i, and m is the total number of operations. Usually, in fact, one proves a slightly strong result: that at any intermediate stage in a sequence of operations, the accumulated amortized cost is an upper bound on the accumulated actual cost, $$ \\sum_{i=1}^j a_i \\geq \\sum_{i=1}^j t_i $$ for any j. The difference between the accumulated amortized costs and the accumulated actual costs is called the accumulated savings. Thus, the accumulated amortized costs are an upper bound on the accumulated actual costs whenever the accumulated saving is non-negative.\nAmortization allows for occasional operations to have actual costs that exceed their amortized costs, such operations are called expensive, while the operations whose actual costs are less than their amortized costs are called cheap. It’s easy to see that expensive operations decrease the accumulated saving and cheap operations increase it. The key to proving amortized bounds is to show that expensive operations occur only when the accumulated saving are sufficient to cover the remaining cost.\nThere are two techniques for analyzing amortized data structures: the banker’s method and the physicist’s method. In the banker’s method, the accumulated saving are represented as credits that are associated with individual locations in the data structure. These credits are used to pay for future accesses to these locations. The amortized cost of any operation is defined to be the actual cost of the operation plus the credits allocated by the operation minus the credits spent by the operation: $$ a_i = t_i + c_i - \\bar{c_i} $$ where $ c_i $ is the number of credits allocated by operation i and $\\bar{c_i}$ is the number of credits spent by operation i. Every credit must be allocated before it is spent, and no credit may be spent more than once. Therefore, $\\sum c_i \\geq \\sum \\bar{c_i}$ which in turn guarantees that $\\sum a_i \\geq \\sum t_i$, as desired. Proofs using the banker’s method typically define a credit invariant that regulates the distribution of credits in such a way that, whenever an expensive operation might occur, sufficient credits have been allocated in the right locations to cover its cost.\nIn the physicist’s method, one describes a function $\\Phi$ that maps each object d to a real number called the potential of d. The function $\\Phi$ is typically chosen so that the potential is initially zero and is always non-negative. Then the potential represents a lower bound on the accumulated savings.\nLet d_i be the output of operation i and input of operation i + 1. Then the amortized cost of operation i is defined to be the actual cost plus the change in potential between $d_{i-1}$ and $d_i$: $$ a_i = t_i + \\Phi(d_i) + \\Phi(d_{i-1}) $$ so, the accumulated actual costs of the sequence of operations are: $$ \\sum_{i=1}^j t_i = \\sum_{i=1}^j a_i + \\Phi(d_0) - \\Phi(d_j) $$ Provided $\\Phi$ is chosen in such a way that $\\Phi(d_0)$ is zero and $\\Phi(d_j)$ is non-negative, then we conclude that the accumulated amoritized costs are an upper bound on the accumulated actual costs.\nQueue We illustrate the banker’s and physicist’s methods by analyzing a simple functional implementation of the FIFO queue abstraction as:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 module type Queue = sig type 'a t val empty : 'a t val isEmpty : 'a t -\u003e bool (** snoc means \"cons on the right\" *) val snoc : 'a -\u003e 'a t -\u003e 'a t val head : 'a t -\u003e 'a val tail : 'a t -\u003e 'a t end The most common implementation of queues in a purely functional setting is a pair of lists, front contains the front elements of the queue in the correct order and rear contains the rear elements of the queue in reverse order:\ntype 'a t = 'a list * 'a list in this representation, the head of the queue is the first element of front, and the last element of the queue is the first element of rear, so the remains can implement straightforward:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let head = function | [], _ -\u003e raise Empty | x :: tl, _ -\u003e x let checkf = function | [], rear -\u003e (List.rev rear, []) | queue -\u003e queue let tail = function | [], _ -\u003e raise Empty | x :: tl, rear -\u003e checkf (tl, rear) let snoc x = function | (front, rear) -\u003e checkf (front, x :: rear) Here we use the auxiliary function checkf so that we check if the front is empty and then reverse the rear as the new front. Notice that, if front were empty when rear was not, then the first element of the queue would be the last element of rear, which would take O(n) time to access. By maintaining this invariant, we guarantee that head can always find the first element in O(1) time, and we also know that if the front is empty, then so is rear.\nNow we show that snoc and tail both take O(1) amortized time using either the banker’s method or the physicist’s method, though tail takes O(n) time in the worse-case. Using the banker’s method, we maintain a credit invariant that every element in the real list is assiciated with a single credit. Every snoc into a non-empty queue takes one actual step and allocates a credit to the new element of the rear list, for an amortized cost of two. Every tail that does not reverse the rear list, takes one actual step and neither allocates nor spends any credits, for an amortized cost of one. Finally, every tail that does reverse the rear list takes $ m+1 $ actual steps, where m is the length of the rear list, and spends the m credits contained by that list, for an amortized cost of $ m + 1 - m = 1 $.\nUsing the physicist’s method, we define the potential function $\\Phi$ to be the length of the rear list. Then every snoc into a non-empty queue takes one actual step and increases the potential by one, for an amortized cost of two. Every tail that does not reverse the rear list takes one actual step and leaves the potential unchanged, for an amortized cost of one. Finally, every tail that does reverse the rear list takes $m + 1$ actual steps and sets the new rear list to [], decreasing the potential by m, for an amortized cost of $ m+1-m = 1 $\nSplay heaps Splay trees are perhaps the most famous and successful of all amortized data structure. Splay trees are a close relative of balanced binary search trees, but they maintain no explicit balance information. Instead, every operation blindly restructures the tree using some simple transformations that tend to increase balance. Although any individual operation can take as much as O(n) time, but every operation runs in O(log n) amortized time. A major difference between splay trees and balanced binary search trees such as the red-black trees is that splay trees are restructured even during queries instead of only during updates. This property makes it awkward to use splay trees to implement abstractions such as sets or finite maps in a purely functional setting, because the query would have to return the new tree along with the answer. For some abstractions, however, the queries are limited enough to avoid these problems. A good example is the heap abstraction, where the only interesting query is findMin. In fact, splay tree make an excellent implementation of heaps.\nThe representation of splay tree in identical to that of unbalanced binary search trees:\n1 type t = Leaf | Node of t * elem * t unlike the unbalanced binary search trees, we allow duplicate elements within a single tree. Unlike the insertion into ordinary binary search trees, we just partition the existing tree into two subtrees, one containing all the elements smaller than or equal to the new element and one in contrast, and then construct a new tree where the root is the new element and other two as its children:\n1 let insert x t = Node (smaller x t, x, bigger x t) and bigger implement as bellow(smaller implement same way):\n1 2 3 4 5 6 7 8 9 10 11 let bigger pivot = function | Leaf -\u003e Leaf | Node (left, v, right) -\u003e if Elem.compare v pivot \u003c= 0 then bigger pivot right else match left with | Leaf -\u003e Node (Leaf, v, right) | Node (left1, v1, right1) -\u003e if Elem.compare v1 pivot \u003c= 0 then Node (bigger pivot right1, v, right) else Node (bigger pivot left1, v1, Node (right1, v, right)) Notice that we restructure the tree to make in more balanced: every time we follow two left branches in a row, we rotate those two nodes. Although, the tree may be still not balance in the usual sense, the new tree will be much more balanced than the original tree. In fact, this is the guiding principle of splay trees: search paths should be restructured to reduce the depth of every node in the path by about half.\nAlso we can combine bigger and smaller as one function partition, which return a pair:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 let rec partition pivot = function | Leaf -\u003e Leaf, Leaf | Node (left, v, right) as tree -\u003e if Elem.compare v pivot \u003c= 0 then match right with | Leaf -\u003e tree, Leaf | Node (left1, v1, right1) -\u003e if Elem.compare v1 pivot \u003c= 0 then let small, big = partition pivot right1 in Node (Node (left, v, left1), v1, small), big else let small, big = partition pivot left1 in Node (left, v, small), Node (big, v1, right1) else match left with | Leaf -\u003e Leaf, tree | Node (left1, v1, right1) -\u003e if Elem.compare v1 pivot \u003c= 0 then let small, big = partition pivot right1 in Node (left1, v1, small), Node (big, v, right) else let small, big = partition pivot left1 in small, Node (big, v1, Node (right1, v, right)) The remains are straightforward:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 (** splayHeap.ml *) open Core module type Heap = sig type t type elem exception Empty val empty : t val isEmpty : t -\u003e bool val insert : elem -\u003e t -\u003e t val merge : t -\u003e t -\u003e t val findMin : t -\u003e elem val deleteMin : t -\u003e t end module Make (Elem : Comparable) : (Heap with type elem = Elem.t) = struct type elem = Elem.t type t = Leaf | Node of t * elem * t exception Empty let empty = Leaf let isEmpty = function | Leaf -\u003e true | _ -\u003e false let rec partition pivot = function | Leaf -\u003e Leaf, Leaf | Node (left, v, right) as tree -\u003e if Elem.compare v pivot \u003c= 0 then match right with | Leaf -\u003e tree, Leaf | Node (left1, v1, right1) -\u003e if Elem.compare v1 pivot \u003c= 0 then let small, big = partition pivot right1 in Node (Node (left, v, left1), v1, small), big else let small, big = partition pivot left1 in Node (left, v, small), Node (big, v1, right1) else match left with | Leaf -\u003e Leaf, tree | Node (left1, v1, right1) -\u003e if Elem.compare v1 pivot \u003c= 0 then let small, big = partition pivot right1 in Node (left1, v1, small), Node (big, v, right) else let small, big = partition pivot left1 in small, Node (big, v1, Node (right1, v, right)) let insert x t = let left, right = partition x t in Node (left, x, right) let rec merge t1 t2 = match t1, t2 with | Leaf, _ -\u003e t2 | Node (left, v, right), _ -\u003e let small, big = partition v t2 in Node (merge small left, v, merge big right) let rec findMin = function | Leaf -\u003e raise Empty | Node (Leaf, v, _) -\u003e v | Node (left, v, _) -\u003e findMin left let rec deleteMin = function | Leaf -\u003e raise Empty | Node (Leaf, v, right) -\u003e right | Node (Node (Leaf, v1, right1), v2, right2) -\u003e Node (right1, v2, right2) | Node (Node (left1, v1, right1), v2, right2) -\u003e Node (deleteMin left1, v1, Node (right1, v2, right2)) end And the amortized cost of insert and deleteMin run in O(log n) time, proofs are omited.\nA particularly pleasant feature of splay trees is that they naturally adapt to any order that happens to be present in the input data. For example, using splay heaps to sort an already sorted list takes only O(n) time rather than O(nlog n) time. Leftist heaps also share this property, but only for decreasing sequences. Splay heaps excel on both increasing and decreasing sequences, as well as on sequence that are only partially sorted.\nPairing heaps Pairing heaps are simple to implement and perform extremely well in parctice, but they have resisted analysis for over ten years. Pairing heaps are heap-ordered multiway trees, as defined:\n1 type t = Leaf | Node of elem * t list We allow only well-formed trees, in which Leaf never occurs in the child list of Node. Pairing heaps get their name from deleteMin operation. deleteMin discards the root and then merges the children in two passes. The first pass merges children in pairs from left to right. The second pass merges the resulting trees from right to left:\n1 2 3 4 5 6 7 8 let mergePairs = function | [] -\u003e Leaf | [h] -\u003e h | h1 :: h2 :: hs -\u003e merge (merge h1 h2) (mergePairs hs) let deleteMin = function | Leaf -\u003e raise Empty | Node (x, hs) -\u003e mergePairs hs and others are straightforward:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 (** pairing heaps *) open Core module type Heap = sig type t type elem exception Empty val empty : t val isEmpty : t -\u003e bool val insert : elem -\u003e t -\u003e t val merge : t -\u003e t -\u003e t val findMin : t -\u003e elem val deleteMin : t -\u003e t val fromList : elem list -\u003e t end module Make (Elem : Comparable) : (Heap with type elem = Elem.t) = struct type elem = Elem.t type t = Leaf | Node of elem * t list exception Empty let empty = Leaf let isEmpty = function | Leaf -\u003e true | _ -\u003e false let merge h1 h2 = match h1, h2 with | Leaf, _ as h | _ as h, Leaf -\u003e h | Node (v1, hs1), Node (v2, hs2) -\u003e if Elem.compare v1 v2 \u003c= 0 then Node (v1, h2 :: hs1) else Node (v2, h1 :: hs2) let insert x h = merge (Node (x, [])) h let mergePairs = function | [] -\u003e Leaf | [h] -\u003e h | h1 :: h2 :: hs -\u003e merge (merge h1 h2) (mergePairs hs) let findMin = function | Leaf -\u003e raise Empty | Node (x, hs) -\u003e x let deleteMin = function | Leaf -\u003e raise Empty | Node (x, hs) -\u003e mergePairs hs end Notice that findMin, insert and merge all run in O(1) worst-case time, however, deleteMin can take up to O(n) time in the worst case. And deleteMin run in O(log n) amortized time.\nAll amortized data structures we have discussed are tremendously effective in pratice. Unfortunately, they perform a bad in persistence. Let q be the result of inserting n elements into an initially empty queue, so that the front list of q contains only a single element and the rear list contains n - 1 elements. So if we use q persistently by taking tail n times, each call takes n actual steps. And the total actual cost, including the time to build q, is $ n^2 + n $, Thus the operation can not take O(1) amortized time, and this can be solved via lazy evaluation.\nNumerical Representations Consider the usual representations of lists and natural numbers, along with several typical functions on each type:\n1 2 3 4 5 6 7 8 9 type 'a list = Nil | Cons of 'a * 'a list let tail = function | Cons (x, xs) -\u003e xs | _ -\u003e raise Empty let rec append xs ys = match xs with | Nil -\u003e ys | hd :: tl -\u003e Cons (hd, append tl ys) 1 2 3 4 5 6 7 8 9 type nat = Zero | Succ of nat let pred = function | Succ n -\u003e n | Zero -\u003e raise PredZero let rec plus n1 n2 = match n1 with | Zero -\u003e n2 | Succ n -\u003e Succ (plus n n2) Other than the fact that list contain elements and natural numbers do not, these implementations are virtually identical. Binomial heaps exhibit a similar relationship with binary numbers. These examples suggest a strong anology between representations of the number n and representations container objects of size n. Functions on the container strongly resemble arithmetic functions on the number. This analogy can be exploited to design new implementations of container abstractions – simply choose a representation of natural numbers with certain desired properties and define the function on the container objects accordingly. This design fashion is called numerical representation.\nGiven a positional number system, we can implement a numerical representation based on than number system as a sequence of trees. For example, the binary representation of 73 is 1001001, so a collection of size 73 in a binary numberical representation would contain three trees, of size 1, 8 and 64. Trees in numerical representations typically exhibit a very regular structure, for example, in binary numerical representations, all trees have size that are powers of 2. And there are three common kinds of trees that exhibit this structure are complete binary leaf trees, binomial trees, and pennants. Each tree with rank r has $ 2^r $ element.\nBinary random-access lists A random-access list, also called a one-sided flexible array, is a data structure that supports array-like lookup and update functions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 module type RandomAccessList = sig type 'a t val empty : 'a t val isEmpty : 'a t -\u003e bool val cons : 'a -\u003e 'a t -\u003e 'a t val head : 'a t -\u003e 'a val tail : 'a t -\u003e 'a t val lookup : int -\u003e 'a t -\u003e 'a val update : int -\u003e 'a -\u003e 'a t -\u003e 'a t end We implement random-access lists using a binary numerical representation. A binary random-access list of size n contains a tree for each one in the binary representation of n. We choose the simplest combination of features: complete binary leaf trees and a dense representation:\n1 2 3 type 'a tree = Leaf of 'a | Node of int * 'a tree * 'a tree type 'a digit = Zero | One of 'a tree type 'a t = 'a digit list The integer in each Node is the size of the tree, this number is redundant. Trees are sorted in increasing order of size, and the order of elements is left-to-right both within and between trees. The maximum number of trees in a list of size n is log(n+1)(all position are one), and the maximum depth of any tree is logn. Inserting an element into a binary random-acess list is analogous to increasing a binary number. The increment function on dense binary numbers like:\n1 2 3 4 let rec inc = function | [] -\u003e One | Zero :: ds -\u003e One :: ds | One :: ds -\u003e Zero :: inc ds Similarly, we first convert the element into a leaf, and then insert the leaf into the list follow the rule of inc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 let size = function | Leaf _ -\u003e 1 | Node (n, _, _) -\u003e n let link t1 t2 = Node (size t1 + size t2, t1, t2) let cons x ts = let rec consTree t = function | [] -\u003e [One t] | Zero :: tl -\u003e One t :: tl | One t1 :: tl -\u003e Zero :: consTree (link t t1) tl in consTree (Leaf x) ts Deleting an element from a binary random-access list is analogous to decrementing a binary number:\n1 2 3 4 let rec dec = function | [One] -\u003e [] | One :: ds -\u003e Zero :: ds | Zero :: ds -\u003e One :: dec ds So the implementation also follow the dec rule:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let rec unconsTree = function | [] -\u003e raise Empty | [One t] -\u003e t, [] | One t :: tl -\u003e t, Zero :: tl | Zero :: tl -\u003e match (unconsTree tl) with | Node (_, t1, t2), ts -\u003e t1, One t2 :: ts | _ -\u003e assert false let head ts = match (unconsTree ts) with | Leaf x, _ -\u003e x | _ -\u003e assert false let tail ts = match (unconsTree ts) with | _, tl -\u003e tl The lookup and update functions do not have analogous arithmetic operations. Rather, they take advantage of the organization of binary random-access lists as logarthmic-length lists of logarthmic-depth trees. Looking up or updating an element is a two stage process, we first search the list for the correct tree, and then search the tree for the correct element. To sum up we have:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 (** randomAccessList.ml *) type 'a t = 'a digit list and 'a digit = Zero | One of 'a tree and 'a tree = Leaf of 'a | Node of int * 'a tree * 'a tree exception Empty let empty = [] let isEmpty = function | [] -\u003e true | _ -\u003e false let size = function | Leaf _ -\u003e 1 | Node (n, _, _) -\u003e n let link t1 t2 = Node (size t1 + size t2, t1, t2) let cons x ts = let rec consTree t = function | [] -\u003e [One t] | Zero :: tl -\u003e One t :: tl | One t1 :: tl -\u003e Zero :: consTree (link t t1) tl in consTree (Leaf x) ts let rec unconsTree = function | [] -\u003e raise Empty | [One t] -\u003e t, [] | One t :: tl -\u003e t, Zero :: tl | Zero :: tl -\u003e match (unconsTree tl) with | Node (_, t1, t2), ts -\u003e t1, One t2 :: ts | _ -\u003e assert false let head ts = match (unconsTree ts) with | Leaf x, _ -\u003e x | _ -\u003e assert false let tail ts = match (unconsTree ts) with | _, tl -\u003e tl let rec lookupTree i t = match i, t with | 0, Leaf x -\u003e x | i, Node (n, left, right) -\u003e if i \u003c n / 2 then lookupTree i left else lookupTree (i - n / 2) right let rec updateTree i x t =match i, t with | 0, Leaf _ -\u003e Leaf x | i, Leaf _ -\u003e raise Empty | i, Node (n, left, right) -\u003e if i \u003c n / 2 then Node (n, updateTree i x left, right) else Node (n, left, updateTree (i - n / 2) x right) let rec lookup i = function | [] -\u003e raise Empty | Zero :: tl -\u003e lookup i tl | One t :: tl -\u003e if i \u003c size t then lookupTree i t else lookup (i - size t) tl let rec update i x = function | [] -\u003e raise Empty | Zero :: tl -\u003e Zero :: update i x tl | One t :: tl -\u003e if i \u003c size t then One (updateTree i x t) :: tl else One t :: update (i - size t) x tl All operations run in O(logn) worst-case time. But cons, head and tail run in O(logn) not O(1) is one disappointing aspect.\nZeroless representation Currently, head is implemented via a call to unconsTree, this approach yields compact code unconsTree supports both head and tail, but wastes time building lists that are immediately discard by head. For greater efficiency, we should implement head directly. As a special case, head can easily be made to run in O(1) time whenever the first digit is non-zero. So we seek to arrange that the first digit is always non-zero, one more principled solution is to use a zeroless representation, in which binary numbers are constructed from ones and twos instead of zeros and ones:\n1 2 3 4 5 6 7 type nat = digit list and digit = One | Two let inc = function | [] -\u003e [One] | One :: ds -\u003e Two :: ds | Two :: ds -\u003e One :: inc ds And the implementation of random-access list is:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 (** randomAccessListZeroless.ml * the interface is same as RandomAccessList *) type 'a t = 'a digit list and 'a digit = One of 'a tree | Two of 'a tree * 'a tree and 'a tree = Leaf of 'a | Node of int * 'a tree * 'a tree let empty = [] let isEmpty = function | [] -\u003e true | _ -\u003e false exception Empty let size = function | Leaf _ -\u003e 1 | Node (n, _, _) -\u003e n let link t1 t2 = Node (size t1 + size t2, t1, t2) let cons x ts = let rec consTree t = function | [] -\u003e [One t] | One t1 :: tl -\u003e Two (t, t1) :: tl | Two (t1, t2) :: tl -\u003e One t :: consTree (link t1 t2) tl in consTree (Leaf x) ts let head = function | One Leaf x :: tl -\u003e x | Two (Leaf x, _) :: tl -\u003e x | _ -\u003e assert false let tail = function | [] -\u003e raise Empty | [One _] -\u003e [] | One _ :: One Node (_, left, right) :: tl -\u003e Two (left, right) :: tl | One _ :: Two (t, Node (_, left, right)) :: tl -\u003e Two (left, right) :: One t :: tl | Two (_, t) :: tl -\u003e One t :: tl | _ -\u003e assert false let rec lookupTree i t = match i, t with | 0, Leaf x -\u003e x | i, Leaf _ -\u003e raise Empty | i, Node (n, left, right) -\u003e if i \u003c n / 2 then lookupTree i left else lookupTree (i - n / 2) right let rec updateTree i x t =match i, t with | 0, Leaf _ -\u003e Leaf x | i, Leaf _ -\u003e raise Empty | i, Node (n, left, right) -\u003e if i \u003c n / 2 then Node (n, updateTree i x left, right) else Node (n, left, updateTree (i - n / 2) x right) let rec lookup i = function | [] -\u003e raise Empty | One t :: tl -\u003e if i \u003c size t then lookupTree i t else lookup (i - size t) tl | Two (t1, t2) :: tl -\u003e if i \u003c size t1 then lookupTree i t1 else if i \u003c size t2 then lookupTree (i - size t1) t2 else lookup (i - size t1 - size t2) tl let rec update i x = function | [] -\u003e raise Empty | (One t as hd) :: tl -\u003e if i \u003c size t then One (updateTree i x t) :: tl else hd :: update (i - size t) x tl | (Two (t1, t2) as hd) :: tl -\u003e if i \u003c size t1 then Two (updateTree i x t1, t2) :: tl else if i \u003c size t2 then Two (t1, updateTree (i - size t1) x t2) :: tl else hd :: update (i - size t1 - size t2) x tl Now the head and tail take O(1) time.\nData-structural bootstrapping The term “bootstrapping” refers to solving problems via solving simple instance of the same problem. And there are three algorithmic design techniques of data-structural bootstrapping. The first, structural decomposition, involves bootstrapping complete data structures from incomplete data structures. The second, structural abstraction, involves bootstrapping efficient data structures from inefficient data structures. The last bootstrapping data structures with aggregate elements from data structures with atomic elements.\nStructural decomposition Typically structural decomposition involves taking an implementation can handle objects only up to some bound size, and extending it to handle objects of unbounded size. Consider typical recursive datatypes such as lists and binary leaf trees:\n1 2 type 'a list = Nil | Cons of 'a * 'a list type 'a tree = Leaf of 'a | Node of 'a tree * 'a tree In some ways, these can be regarded as instances of some bounded size(zero for lists and one fo tree) and a rule for recursively decomposing larger objects into smaller objects until eventually each object is small enough to be handled by the bounded case.\nHowever, both of these definitions are particularly simple that the recursive component in each definition is identical to the type being defined, which called uniformly recursive. In general, we reserve the term structural decomposition to describe recursive data structure that are non-uniform for cases that the recursive component is different from its definition, e.g. type 'a seq = Nil | Cons of 'a * ('a * 'a) seq. But you can not implement structural decomposition directly in ML, althought it allows the definition of non-uniform recursive datatypes. But the type system always disallow the functions on such types like below:\n1 2 3 4 (type illegal) let rec size = function | Nil -\u003e 0 | Cons (x, ps) -\u003e 1 + 2 * size ps Fortunately it is always possible to convert a non-uniform type into a uniform type by introducing a new datatype to collapse the different instances into a single type, for example, we can rewrite the seq as:\n1 2 type 'a ep = Elem of 'a | Pair of 'a ep * 'a ep type 'a seq = Nil | Cons of 'a ep * 'a seq Notice that the 'a ep type is isomorphic to binary leaf trees, so the version of 'a seq is equivalent to 'a tree list, though we would tend to think a list of trees differently that we would think of a sequence of pairs – some algorithms will seem simpler or more natural for one of the representations, and some for the other.\nTo use sequence represent positional number system, we need to represent zero, it’s easily corrected by adding another constructor of the type:\n1 2 3 4 type 'a seq = | Nil | Zero of ('a * 'a) seq | One of 'a * ('a * 'a) seq Now we can represent the sequence 0…10 as One(0, One((1, 2), Zero(One((((3, 4), (5, 6)), ((7, 8), (9, 10))), Nil)))), which has 11 elements, written 1101 in binary. The pairs in this type are always balanced. In fact, another way to think of pairs of elements is as complete binary leaf trees. And then we can replement binary random-access lists use this type.\nTries Binary search trees work well when comparisons on the key or element type are cheap. This is true for simple types like integers or characters, but may not be true for aggregate types like strings. A better solution for aggregate types such as string is to choose a representation that takes advantage of the structure of that type. One such representation is tries, also known as a digital search trees.\nA trie is a multiway tree where each edge is labelled with a character. Edges leaving the root of a trie represent the first character of a string, and so on. and if the node is vaild, which means it contains a value, we can mark it as Some x, otherwise None. The critical remaining question is how to represent the edges leaving a node, we can represent edges as a vector, an association list, a binary search tree, or even another trie. But all of these are just finite maps from edges labels to tries. So we can use a given structure Map implementing finite maps over base type:\n1 type 'a t = Trie of 'a option * 'a Map Map.t Thus we can implement Trie as a functor from finiteMap to finiteMap:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 module type FiniteMap = sig type 'a t type key exception NotFound val empty : 'a t val bind : key -\u003e 'a -\u003e 'a t -\u003e 'a t val lookup : key -\u003e 'a t -\u003e 'a end module Make (Map : FiniteMap) : FiniteMap = struct type key = Map.key list type 'a t = Trie of 'a option * 'a t Map.t exception NotFound let empty = Trie(None, Map.empty) let rec lookup key trie = match key, trie with | [], Trie (None, _) -\u003e raise NotFound | [], Trie (Some x, _) -\u003e x | k :: ks, Trie (_, m) -\u003e lookup ks (Map.lookup k m) let rec bind key x trie = match key, x, trie with | [], x, Trie (_, m) -\u003e Trie (Some x, m) | k :: ks, x, Trie (v, m) -\u003e let t = try Map.lookup k m with NotFound -\u003e empty in let t' = bind ks x t in Trie (v, Map.bind k t' m) end ","wordCount":"6157","inLanguage":"en","datePublished":"2018-07-24T15:54:24Z","dateModified":"2018-07-24T15:54:24Z","author":{"@type":"Person","name":"Christophe"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://www.sdlinks.net/posts/2018/functional-data-structure-2/"},"publisher":{"@type":"Organization","name":"CastOff","logo":{"@type":"ImageObject","url":"http://www.sdlinks.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://www.sdlinks.net/ accesskey=h title="CastOff (Alt + H)">CastOff</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://www.sdlinks.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://www.sdlinks.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://www.sdlinks.net/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Functional Data Structure 2</h1><div class=post-meta><span title='2018-07-24 15:54:24 +0000 UTC'>July 24, 2018</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Christophe</div></header><div class=post-content><h2 id=amortization>Amortization<a hidden class=anchor aria-hidden=true href=#amortization>#</a></h2><p>Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case
bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about
the running time of any individual operation.</p><p>For instance, given a sequence of n operations, we may wish to bound the
total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might
be satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n).
This freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and
faster than worst-case solutions with equivalent bounds.</p><p>To provide an amortized bound, one defines the amortized cost of each operation and then proves that, for any sequence
of operations, the total amortized cost of the operations in an upper bound on the total actual cost,
$$ \sum_{i=1}^m a_i \geq \sum_{i=1}^m t_i $$
where $ a_i $ is the amortized cost of operation i, $t_i$ is the actual cost of operation i, and m is the total number
of operations. Usually, in fact, one proves a slightly strong result: that at any intermediate stage in a sequence of
operations, the accumulated amortized cost is an upper bound on the accumulated actual cost,
$$ \sum_{i=1}^j a_i \geq \sum_{i=1}^j t_i $$
for any j. The difference between the accumulated amortized costs and the accumulated actual costs is called the <em>accumulated
savings</em>. Thus, the accumulated amortized costs are an upper bound on the accumulated actual costs whenever the accumulated
saving is non-negative.</p><p>Amortization allows for occasional operations to have actual costs that exceed their amortized costs, such operations are
called <em>expensive</em>, while the operations whose actual costs are less than their amortized costs are called <em>cheap</em>. It&rsquo;s
easy to see that expensive operations decrease the accumulated saving and cheap operations increase it. The key to proving
amortized bounds is to show that expensive operations occur only when the accumulated saving are sufficient to cover the
remaining cost.</p><p>There are two techniques for analyzing amortized data structures: the <em>banker&rsquo;s method</em> and the <em>physicist&rsquo;s method</em>. In
the banker&rsquo;s method, the accumulated saving are represented as <em>credits</em> that are associated with individual locations
in the data structure. These credits are used to pay for future accesses to these locations. The amortized cost of any
operation is defined to be the actual cost of the operation plus the credits allocated by the operation minus the credits
spent by the operation:
$$ a_i = t_i + c_i - \bar{c_i} $$
where $ c_i $ is the number of credits allocated by operation i and $\bar{c_i}$ is the number of credits spent by operation
i. Every credit must be allocated before it is spent, and no credit may be spent more than once. Therefore, $\sum c_i \geq
\sum \bar{c_i}$ which in turn guarantees that $\sum a_i \geq \sum t_i$, as desired. Proofs using the banker&rsquo;s method
typically define a <em>credit invariant</em> that regulates the distribution of credits in such a way that, whenever an expensive
operation might occur, sufficient credits have been allocated in the right locations to cover its cost.</p><p>In the physicist&rsquo;s method, one describes a function $\Phi$ that maps each object d to a real number called the <em>potential</em>
of d. The function $\Phi$ is typically chosen so that the potential is initially zero and is always non-negative. Then the
potential represents a lower bound on the accumulated savings.</p><p>Let d_i be the output of operation i and input of operation i + 1. Then the amortized cost of operation i is defined to
be the actual cost plus the change in potential between $d_{i-1}$ and $d_i$:
$$ a_i = t_i + \Phi(d_i) + \Phi(d_{i-1}) $$
so, the accumulated actual costs of the sequence of operations are:
$$ \sum_{i=1}^j t_i = \sum_{i=1}^j a_i + \Phi(d_0) - \Phi(d_j) $$
Provided $\Phi$ is chosen in such a way that $\Phi(d_0)$ is zero and $\Phi(d_j)$ is non-negative, then we conclude that
the accumulated amoritized costs are an upper bound on the accumulated actual costs.</p><h3 id=queue>Queue<a hidden class=anchor aria-hidden=true href=#queue>#</a></h3><p>We illustrate the banker&rsquo;s and physicist&rsquo;s methods by analyzing a simple functional implementation of the FIFO queue
abstraction as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>Queue</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>isEmpty</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c>(** snoc means &#34;cons on the right&#34; *)</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>snoc</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>head</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>tail</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>The most common implementation of queues in a purely functional setting is a pair of lists, <em>front</em> contains the front
elements of the queue in the correct order and <em>rear</em> contains the rear elements of the queue in reverse order:</p><pre tabindex=0><code>type &#39;a t = &#39;a list * &#39;a list
</code></pre><p>in this representation, the head of the queue is the first element of <em>front</em>, and the last element of the queue is the
first element of <em>rear</em>, so the remains can implement straightforward:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>head</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span><span class=o>,</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>x</span> <span class=o>::</span> <span class=n>tl</span><span class=o>,</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>checkf</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span><span class=o>,</span> <span class=n>rear</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=nn>List</span><span class=p>.</span><span class=n>rev</span> <span class=n>rear</span><span class=o>,</span> <span class=bp>[]</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>queue</span> <span class=o>-&gt;</span> <span class=n>queue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>tail</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span><span class=o>,</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>x</span> <span class=o>::</span> <span class=n>tl</span><span class=o>,</span> <span class=n>rear</span> <span class=o>-&gt;</span> <span class=n>checkf</span> <span class=o>(</span><span class=n>tl</span><span class=o>,</span> <span class=n>rear</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>snoc</span> <span class=n>x</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>(</span><span class=n>front</span><span class=o>,</span> <span class=n>rear</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>checkf</span> <span class=o>(</span><span class=n>front</span><span class=o>,</span> <span class=n>x</span> <span class=o>::</span> <span class=n>rear</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Here we use the auxiliary function <code>checkf</code> so that we check if the front is empty and then reverse the rear as the new
front. Notice that, if <em>front</em> were empty when <em>rear</em> was not, then the first element of the queue would be the last
element of rear, which would take O(n) time to access. By maintaining this invariant, we guarantee that head can always
find the first element in O(1) time, and we also know that if the <em>front</em> is empty, then so is <em>rear</em>.</p><p>Now we show that snoc and tail both take O(1) amortized time using either the banker&rsquo;s method or the physicist&rsquo;s method,
though <code>tail</code> takes O(n) time in the worse-case. Using the banker&rsquo;s method, we maintain a credit invariant that every element
in the real list is assiciated with a single credit. Every snoc into a non-empty queue takes one actual step and allocates
a credit to the new element of the rear list, for an amortized cost of two. Every tail that does not reverse the rear list,
takes one actual step and neither allocates nor spends any credits, for an amortized cost of one. Finally, every tail that
does reverse the rear list takes $ m+1 $ actual steps, where m is the length of the rear list, and spends the m credits
contained by that list, for an amortized cost of $ m + 1 - m = 1 $.</p><p>Using the physicist&rsquo;s method, we define the potential function $\Phi$ to be the length of the rear list. Then every snoc
into a non-empty queue takes one actual step and increases the potential by one, for an amortized cost of two. Every tail
that does not reverse the rear list takes one actual step and leaves the potential unchanged, for an amortized cost of
one. Finally, every tail that does reverse the rear list takes $m + 1$ actual steps and sets the new rear list to [],
decreasing the potential by m, for an amortized cost of $ m+1-m = 1 $</p><h3 id=splay-heaps>Splay heaps<a hidden class=anchor aria-hidden=true href=#splay-heaps>#</a></h3><p>Splay trees are perhaps the most famous and successful of all amortized data structure. Splay trees are a close relative
of balanced binary search trees, but they maintain no explicit balance information. Instead, every operation blindly
restructures the tree using some simple transformations that tend to increase balance. Although any individual operation
can take as much as O(n) time, but every operation runs in O(log n) amortized time. A major difference between splay trees
and balanced binary search trees such as the red-black trees is that splay trees are restructured even during queries instead
of only during updates. This property makes it awkward to use splay trees to implement abstractions such as sets or finite
maps in a purely functional setting, because the query would have to return the new tree along with the answer. For some
abstractions, however, the queries are limited enough to avoid these problems. A good example is the heap abstraction,
where the only interesting query is findMin. In fact, splay tree make an excellent implementation of heaps.</p><p>The representation of splay tree in identical to that of unbalanced binary search trees:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=nc>Leaf</span> <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=n>t</span> <span class=o>*</span> <span class=n>elem</span> <span class=o>*</span> <span class=n>t</span>
</span></span></code></pre></td></tr></table></div></div><p>unlike the unbalanced binary search trees, we allow duplicate elements within a single tree. Unlike the insertion into
ordinary binary search trees, we just partition the existing tree into two subtrees, one containing all the elements smaller
than or equal to the new element and one in contrast, and then construct a new tree where the root is the new element
and other two as its children:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>insert</span> <span class=n>x</span> <span class=n>t</span> <span class=o>=</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>smaller</span> <span class=n>x</span> <span class=n>t</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>bigger</span> <span class=n>x</span> <span class=n>t</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>and bigger implement as bellow(smaller implement same way):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>bigger</span> <span class=n>pivot</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>v</span> <span class=n>pivot</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=n>bigger</span> <span class=n>pivot</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=k>match</span> <span class=n>left</span> <span class=k>with</span> 
</span></span><span class=line><span class=cl>        <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Leaf</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>right1</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>v1</span> <span class=n>pivot</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>          <span class=k>then</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>bigger</span> <span class=n>pivot</span> <span class=n>right1</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>bigger</span> <span class=n>pivot</span> <span class=n>left1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>right1</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>))</span>
</span></span></code></pre></td></tr></table></div></div><p>Notice that we restructure the tree to make in more balanced: every time we follow two left branches in a row, we rotate
those two nodes. Although, the tree may be still not balance in the usual sense, the new tree will be much more balanced
than the original tree. In fact, this is the guiding principle of splay trees: search paths should be restructured to
reduce the depth of every node in the path by about half.</p><p>Also we can combine bigger and smaller as one function <code>partition</code>, which return a pair:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>partition</span> <span class=n>pivot</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=nc>Leaf</span><span class=o>,</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=k>as</span> <span class=n>tree</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>v</span> <span class=n>pivot</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=k>match</span> <span class=n>right</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=n>tree</span><span class=o>,</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>right1</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>v1</span> <span class=n>pivot</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>        <span class=k>then</span> <span class=k>let</span> <span class=n>small</span><span class=o>,</span> <span class=n>big</span> <span class=o>=</span> <span class=n>partition</span> <span class=n>pivot</span> <span class=n>right1</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>          <span class=nc>Node</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>left1</span><span class=o>),</span> <span class=n>v1</span><span class=o>,</span> <span class=n>small</span><span class=o>),</span> <span class=n>big</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>let</span> <span class=n>small</span><span class=o>,</span> <span class=n>big</span> <span class=o>=</span> <span class=n>partition</span> <span class=n>pivot</span> <span class=n>left1</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>          <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>small</span><span class=o>),</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>big</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>right1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>match</span> <span class=n>left</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=nc>Leaf</span><span class=o>,</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>right1</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>v1</span> <span class=n>pivot</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>        <span class=k>then</span> <span class=k>let</span> <span class=n>small</span><span class=o>,</span> <span class=n>big</span> <span class=o>=</span> <span class=n>partition</span> <span class=n>pivot</span> <span class=n>right1</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>          <span class=nc>Node</span> <span class=o>(</span><span class=n>left1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>small</span><span class=o>),</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>big</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>let</span> <span class=n>small</span><span class=o>,</span> <span class=n>big</span> <span class=o>=</span> <span class=n>partition</span> <span class=n>pivot</span> <span class=n>left1</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>          <span class=n>small</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>big</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>right1</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>))</span>
</span></span></code></pre></td></tr></table></div></div><p>The remains are straightforward:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=c>(** splayHeap.ml *)</span>
</span></span><span class=line><span class=cl><span class=k>open</span> <span class=nc>Core</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>Heap</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>isEmpty</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>insert</span> <span class=o>:</span> <span class=n>elem</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>merge</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>findMin</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>deleteMin</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>Make</span> <span class=o>(</span><span class=nc>Elem</span> <span class=o>:</span> <span class=nc>Comparable</span><span class=o>)</span> <span class=o>:</span> <span class=o>(</span><span class=nc>Heap</span> <span class=k>with</span> <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span><span class=o>)</span> <span class=o>=</span> <span class=k>struct</span> 
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=nc>Leaf</span> <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=n>t</span> <span class=o>*</span> <span class=n>elem</span> <span class=o>*</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>isEmpty</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=bp>true</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>partition</span> <span class=n>pivot</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=nc>Leaf</span><span class=o>,</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=k>as</span> <span class=n>tree</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>v</span> <span class=n>pivot</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=k>match</span> <span class=n>right</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>        <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=n>tree</span><span class=o>,</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>        <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>right1</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>v1</span> <span class=n>pivot</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>          <span class=k>then</span> <span class=k>let</span> <span class=n>small</span><span class=o>,</span> <span class=n>big</span> <span class=o>=</span> <span class=n>partition</span> <span class=n>pivot</span> <span class=n>right1</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>            <span class=nc>Node</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>left1</span><span class=o>),</span> <span class=n>v1</span><span class=o>,</span> <span class=n>small</span><span class=o>),</span> <span class=n>big</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span> <span class=k>let</span> <span class=n>small</span><span class=o>,</span> <span class=n>big</span> <span class=o>=</span> <span class=n>partition</span> <span class=n>pivot</span> <span class=n>left1</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>            <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>small</span><span class=o>),</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>big</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>right1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=k>match</span> <span class=n>left</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>        <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=nc>Leaf</span><span class=o>,</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>        <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>right1</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>v1</span> <span class=n>pivot</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>          <span class=k>then</span> <span class=k>let</span> <span class=n>small</span><span class=o>,</span> <span class=n>big</span> <span class=o>=</span> <span class=n>partition</span> <span class=n>pivot</span> <span class=n>right1</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>            <span class=nc>Node</span> <span class=o>(</span><span class=n>left1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>small</span><span class=o>),</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>big</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span> <span class=k>let</span> <span class=n>small</span><span class=o>,</span> <span class=n>big</span> <span class=o>=</span> <span class=n>partition</span> <span class=n>pivot</span> <span class=n>left1</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>            <span class=n>small</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>big</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>right1</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>insert</span> <span class=n>x</span> <span class=n>t</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span> <span class=o>=</span> <span class=n>partition</span> <span class=n>x</span> <span class=n>t</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>merge</span> <span class=n>t1</span> <span class=n>t2</span> <span class=o>=</span> <span class=k>match</span> <span class=n>t1</span><span class=o>,</span> <span class=n>t2</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Leaf</span><span class=o>,</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>t2</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>),</span> <span class=o>_</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>      <span class=k>let</span> <span class=n>small</span><span class=o>,</span> <span class=n>big</span> <span class=o>=</span> <span class=n>partition</span> <span class=n>v</span> <span class=n>t2</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>      <span class=nc>Node</span> <span class=o>(</span><span class=n>merge</span> <span class=n>small</span> <span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>merge</span> <span class=n>big</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>findMin</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Leaf</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>v</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>findMin</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>deleteMin</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Leaf</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=nc>Leaf</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>right1</span><span class=o>),</span> <span class=n>v2</span><span class=o>,</span> <span class=n>right2</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>right1</span><span class=o>,</span> <span class=n>v2</span><span class=o>,</span> <span class=n>right2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=n>left1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=n>right1</span><span class=o>),</span> <span class=n>v2</span><span class=o>,</span> <span class=n>right2</span><span class=o>)</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>      <span class=nc>Node</span> <span class=o>(</span><span class=n>deleteMin</span> <span class=n>left1</span><span class=o>,</span> <span class=n>v1</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>right1</span><span class=o>,</span> <span class=n>v2</span><span class=o>,</span> <span class=n>right2</span><span class=o>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>And the amortized cost of insert and deleteMin run in O(log n) time, proofs are omited.</p><p>A particularly pleasant feature of splay trees is that they naturally adapt to any order that happens to be present in
the input data. For example, using splay heaps to sort an already sorted list takes only O(n) time rather than O(nlog n)
time. Leftist heaps also share this property, but only for decreasing sequences. Splay heaps excel on both increasing and
decreasing sequences, as well as on sequence that are only partially sorted.</p><h3 id=pairing-heaps>Pairing heaps<a hidden class=anchor aria-hidden=true href=#pairing-heaps>#</a></h3><p>Pairing heaps are simple to implement and perform extremely well in parctice, but they have resisted analysis for over
ten years. Pairing heaps are heap-ordered multiway trees, as defined:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=nc>Leaf</span> <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=n>elem</span> <span class=o>*</span> <span class=n>t</span> <span class=kt>list</span>
</span></span></code></pre></td></tr></table></div></div><p>We allow only well-formed trees, in which <code>Leaf</code> never occurs in the child list of <code>Node</code>. Pairing heaps get their name
from deleteMin operation. <code>deleteMin</code> discards the root and then merges the children in two passes. The first pass merges
children in pairs from left to right. The second pass merges the resulting trees from right to left:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>mergePairs</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>-&gt;</span> <span class=n>h</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>h1</span> <span class=o>::</span> <span class=n>h2</span> <span class=o>::</span> <span class=n>hs</span> <span class=o>-&gt;</span> <span class=n>merge</span> <span class=o>(</span><span class=n>merge</span> <span class=n>h1</span> <span class=n>h2</span><span class=o>)</span> <span class=o>(</span><span class=n>mergePairs</span> <span class=n>hs</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>deleteMin</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>hs</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>mergePairs</span> <span class=n>hs</span> 
</span></span></code></pre></td></tr></table></div></div><p>and others are straightforward:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=c>(** pairing heaps *)</span>
</span></span><span class=line><span class=cl><span class=k>open</span> <span class=nc>Core</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>Heap</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>isEmpty</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>insert</span> <span class=o>:</span> <span class=n>elem</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>merge</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>findMin</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>elem</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>deleteMin</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>fromList</span> <span class=o>:</span> <span class=n>elem</span> <span class=kt>list</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>Make</span> <span class=o>(</span><span class=nc>Elem</span> <span class=o>:</span> <span class=nc>Comparable</span><span class=o>)</span> <span class=o>:</span> <span class=o>(</span><span class=nc>Heap</span> <span class=k>with</span> <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span><span class=o>)</span> <span class=o>=</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>elem</span> <span class=o>=</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=nc>Leaf</span> <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=n>elem</span> <span class=o>*</span> <span class=n>t</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>isEmpty</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=bp>true</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>merge</span> <span class=n>h1</span> <span class=n>h2</span> <span class=o>=</span> <span class=k>match</span> <span class=n>h1</span><span class=o>,</span> <span class=n>h2</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Leaf</span><span class=o>,</span> <span class=o>_</span> <span class=k>as</span> <span class=n>h</span> <span class=o>|</span> <span class=o>_</span> <span class=k>as</span> <span class=n>h</span><span class=o>,</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=n>h</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>v1</span><span class=o>,</span> <span class=n>hs1</span><span class=o>),</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>v2</span><span class=o>,</span> <span class=n>hs2</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nn>Elem</span><span class=p>.</span><span class=n>compare</span> <span class=n>v1</span> <span class=n>v2</span> <span class=o>&lt;=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>      <span class=k>then</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>v1</span><span class=o>,</span> <span class=n>h2</span> <span class=o>::</span> <span class=n>hs1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>v2</span><span class=o>,</span> <span class=n>h1</span> <span class=o>::</span> <span class=n>hs2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>insert</span> <span class=n>x</span> <span class=n>h</span> <span class=o>=</span> <span class=n>merge</span> <span class=o>(</span><span class=nc>Node</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=bp>[]</span><span class=o>))</span> <span class=n>h</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>mergePairs</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=nc>Leaf</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>-&gt;</span> <span class=n>h</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>h1</span> <span class=o>::</span> <span class=n>h2</span> <span class=o>::</span> <span class=n>hs</span> <span class=o>-&gt;</span> <span class=n>merge</span> <span class=o>(</span><span class=n>merge</span> <span class=n>h1</span> <span class=n>h2</span><span class=o>)</span> <span class=o>(</span><span class=n>mergePairs</span> <span class=n>hs</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>findMin</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>hs</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>deleteMin</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>hs</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>mergePairs</span> <span class=n>hs</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>Notice that <code>findMin</code>, <code>insert</code> and <code>merge</code> all run in O(1) worst-case time, however, deleteMin can take up to O(n) time
in the worst case. And <code>deleteMin</code> run in O(log n) amortized time.</p><p>All amortized data structures we have discussed are tremendously effective in pratice. Unfortunately, they perform a
bad in persistence. Let q be the result of inserting n elements into an initially empty queue, so that the front list
of q contains only a single element and the rear list contains n - 1 elements. So if we use q persistently by taking
tail n times, each call takes n actual steps. And the total actual cost, including the time to build q, is $ n^2 + n $,
Thus the operation can not take O(1) amortized time, and this can be solved via lazy evaluation.</p><h2 id=numerical-representations>Numerical Representations<a hidden class=anchor aria-hidden=true href=#numerical-representations>#</a></h2><p>Consider the usual representations of lists and natural numbers, along with several typical functions on each type:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span> <span class=o>=</span> <span class=nc>Nil</span> <span class=o>|</span> <span class=nc>Cons</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>tail</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>xs</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>xs</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>append</span> <span class=n>xs</span> <span class=n>ys</span> <span class=o>=</span> <span class=k>match</span> <span class=n>xs</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Nil</span> <span class=o>-&gt;</span> <span class=n>ys</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>hd</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>hd</span><span class=o>,</span> <span class=n>append</span> <span class=n>tl</span> <span class=n>ys</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>nat</span> <span class=o>=</span> <span class=nc>Zero</span> <span class=o>|</span> <span class=nc>Succ</span> <span class=k>of</span> <span class=n>nat</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>pred</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Succ</span> <span class=n>n</span> <span class=o>-&gt;</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Zero</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>PredZero</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>plus</span> <span class=n>n1</span> <span class=n>n2</span> <span class=o>=</span> <span class=k>match</span> <span class=n>n1</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Zero</span> <span class=o>-&gt;</span> <span class=n>n2</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Succ</span> <span class=n>n</span> <span class=o>-&gt;</span> <span class=nc>Succ</span> <span class=o>(</span><span class=n>plus</span> <span class=n>n</span> <span class=n>n2</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Other than the fact that list contain elements and natural numbers do not, these implementations are virtually identical.
Binomial heaps exhibit a similar relationship with binary numbers. These examples suggest a strong anology between representations
of the number n and representations container objects of size n. Functions on the container strongly resemble arithmetic
functions on the number. This analogy can be exploited to design new implementations of container abstractions &ndash; simply
choose a representation of natural numbers with certain desired properties and define the function on the container objects
accordingly. This design fashion is called <em>numerical representation</em>.</p><p>Given a positional number system, we can implement a numerical representation based on than number system as a sequence
of trees. For example, the binary representation of 73 is 1001001, so a collection of size 73 in a binary numberical
representation would contain three trees, of size 1, 8 and 64. Trees in numerical representations typically exhibit a
very regular structure, for example, in binary numerical representations, all trees have size that are powers of 2. And
there are three common kinds of trees that exhibit this structure are <em>complete binary leaf trees</em>, <em>binomial trees</em>, and
<em>pennants</em>. Each tree with rank r has $ 2^r $ element.</p><h3 id=binary-random-access-lists>Binary random-access lists<a hidden class=anchor aria-hidden=true href=#binary-random-access-lists>#</a></h3><p>A random-access list, also called a one-sided flexible array, is a data structure that supports array-like lookup and
update functions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>RandomAccessList</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>isEmpty</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>cons</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>head</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>tail</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>lookup</span> <span class=o>:</span> <span class=kt>int</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>update</span> <span class=o>:</span> <span class=kt>int</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>We implement random-access lists using a binary numerical representation. A binary random-access list of size n contains
a tree for each one in the binary representation of n. We choose the simplest combination of features: complete binary
leaf trees and a dense representation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span> <span class=o>=</span> <span class=nc>Leaf</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=kt>int</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>digit</span> <span class=o>=</span> <span class=nc>Zero</span> <span class=o>|</span> <span class=nc>One</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>=</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>digit</span> <span class=kt>list</span>
</span></span></code></pre></td></tr></table></div></div><p>The integer in each <code>Node</code> is the size of the tree, this number is redundant. Trees are sorted in increasing order of size,
and the order of elements is left-to-right both within and between trees. The maximum number of trees in a list of size n
is log(n+1)(all position are one), and the maximum depth of any tree is logn. Inserting an element into a binary random-acess
list is analogous to increasing a binary number. The increment function on dense binary numbers like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>inc</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=nc>One</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>ds</span> <span class=o>-&gt;</span> <span class=nc>One</span> <span class=o>::</span> <span class=n>ds</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=o>::</span> <span class=n>ds</span> <span class=o>-&gt;</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>inc</span> <span class=n>ds</span>
</span></span></code></pre></td></tr></table></div></div><p>Similarly, we first convert the element into a leaf, and then insert the leaf into the list follow the rule of <code>inc</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>size</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>1</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=o>_,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>link</span> <span class=n>t1</span> <span class=n>t2</span> <span class=o>=</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>size</span> <span class=n>t1</span> <span class=o>+</span> <span class=n>size</span> <span class=n>t2</span><span class=o>,</span> <span class=n>t1</span><span class=o>,</span> <span class=n>t2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>cons</span> <span class=n>x</span> <span class=n>ts</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>consTree</span> <span class=n>t</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=o>[</span><span class=nc>One</span> <span class=n>t</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>One</span> <span class=n>t1</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>consTree</span> <span class=o>(</span><span class=n>link</span> <span class=n>t</span> <span class=n>t1</span><span class=o>)</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>consTree</span> <span class=o>(</span><span class=nc>Leaf</span> <span class=n>x</span><span class=o>)</span> <span class=n>ts</span>
</span></span></code></pre></td></tr></table></div></div><p>Deleting an element from a binary random-access list is analogous to decrementing a binary number:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>dec</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>[</span><span class=nc>One</span><span class=o>]</span> <span class=o>-&gt;</span> <span class=bp>[]</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=o>::</span> <span class=n>ds</span> <span class=o>-&gt;</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>ds</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>ds</span> <span class=o>-&gt;</span> <span class=nc>One</span> <span class=o>::</span> <span class=n>dec</span> <span class=n>ds</span>
</span></span></code></pre></td></tr></table></div></div><p>So the implementation also follow the <code>dec</code> rule:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>unconsTree</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>[</span><span class=nc>One</span> <span class=n>t</span><span class=o>]</span> <span class=o>-&gt;</span> <span class=n>t</span><span class=o>,</span> <span class=bp>[]</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=n>t</span><span class=o>,</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=k>match</span> <span class=o>(</span><span class=n>unconsTree</span> <span class=n>tl</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>t1</span><span class=o>,</span> <span class=n>t2</span><span class=o>),</span> <span class=n>ts</span> <span class=o>-&gt;</span> <span class=n>t1</span><span class=o>,</span> <span class=nc>One</span> <span class=n>t2</span> <span class=o>::</span> <span class=n>ts</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>assert</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>head</span> <span class=n>ts</span> <span class=o>=</span> <span class=k>match</span> <span class=o>(</span><span class=n>unconsTree</span> <span class=n>ts</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Leaf</span> <span class=n>x</span><span class=o>,</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>assert</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>tail</span> <span class=n>ts</span> <span class=o>=</span> <span class=k>match</span> <span class=o>(</span><span class=n>unconsTree</span> <span class=n>ts</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_,</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=n>tl</span>
</span></span></code></pre></td></tr></table></div></div><p>The lookup and update functions do not have analogous arithmetic operations. Rather, they take advantage of the organization
of binary random-access lists as logarthmic-length lists of logarthmic-depth trees. Looking up or updating an element is
a two stage process, we first search the list for the correct tree, and then search the tree for the correct element. To
sum up we have:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=c>(** randomAccessList.ml *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>=</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>digit</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl><span class=ow>and</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>digit</span> <span class=o>=</span> <span class=nc>Zero</span> <span class=o>|</span> <span class=nc>One</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl><span class=ow>and</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span> <span class=o>=</span> <span class=nc>Leaf</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=kt>int</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>                                     
</span></span><span class=line><span class=cl><span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=bp>[]</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>isEmpty</span> <span class=o>=</span> <span class=k>function</span> 
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=bp>true</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>size</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>1</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=o>_,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>link</span> <span class=n>t1</span> <span class=n>t2</span> <span class=o>=</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>size</span> <span class=n>t1</span> <span class=o>+</span> <span class=n>size</span> <span class=n>t2</span><span class=o>,</span> <span class=n>t1</span><span class=o>,</span> <span class=n>t2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>cons</span> <span class=n>x</span> <span class=n>ts</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>consTree</span> <span class=n>t</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=o>[</span><span class=nc>One</span> <span class=n>t</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>One</span> <span class=n>t1</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>consTree</span> <span class=o>(</span><span class=n>link</span> <span class=n>t</span> <span class=n>t1</span><span class=o>)</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>consTree</span> <span class=o>(</span><span class=nc>Leaf</span> <span class=n>x</span><span class=o>)</span> <span class=n>ts</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>unconsTree</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>[</span><span class=nc>One</span> <span class=n>t</span><span class=o>]</span> <span class=o>-&gt;</span> <span class=n>t</span><span class=o>,</span> <span class=bp>[]</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=n>t</span><span class=o>,</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=k>match</span> <span class=o>(</span><span class=n>unconsTree</span> <span class=n>tl</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>t1</span><span class=o>,</span> <span class=n>t2</span><span class=o>),</span> <span class=n>ts</span> <span class=o>-&gt;</span> <span class=n>t1</span><span class=o>,</span> <span class=nc>One</span> <span class=n>t2</span> <span class=o>::</span> <span class=n>ts</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>assert</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>head</span> <span class=n>ts</span> <span class=o>=</span> <span class=k>match</span> <span class=o>(</span><span class=n>unconsTree</span> <span class=n>ts</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Leaf</span> <span class=n>x</span><span class=o>,</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>assert</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>tail</span> <span class=n>ts</span> <span class=o>=</span> <span class=k>match</span> <span class=o>(</span><span class=n>unconsTree</span> <span class=n>ts</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_,</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>lookupTree</span> <span class=n>i</span> <span class=n>t</span> <span class=o>=</span> <span class=k>match</span> <span class=n>i</span><span class=o>,</span> <span class=n>t</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>0</span><span class=o>,</span> <span class=nc>Leaf</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>i</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>/</span> <span class=n>2</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>lookupTree</span> <span class=n>i</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>lookupTree</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>n</span> <span class=o>/</span> <span class=n>2</span><span class=o>)</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>updateTree</span> <span class=n>i</span> <span class=n>x</span> <span class=n>t</span> <span class=o>=</span><span class=k>match</span> <span class=n>i</span><span class=o>,</span> <span class=n>t</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>0</span><span class=o>,</span> <span class=nc>Leaf</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=nc>Leaf</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>i</span><span class=o>,</span> <span class=nc>Leaf</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>i</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>/</span> <span class=n>2</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=n>updateTree</span> <span class=n>i</span> <span class=n>x</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>updateTree</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>n</span> <span class=o>/</span> <span class=n>2</span><span class=o>)</span> <span class=n>x</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>lookup</span> <span class=n>i</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=n>lookup</span> <span class=n>i</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=n>t</span> 
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>lookupTree</span> <span class=n>i</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>lookup</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>size</span> <span class=n>t</span><span class=o>)</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>update</span> <span class=n>i</span> <span class=n>x</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>Zero</span> <span class=o>::</span> <span class=n>update</span> <span class=n>i</span> <span class=n>x</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=nc>One</span> <span class=o>(</span><span class=n>updateTree</span> <span class=n>i</span> <span class=n>x</span> <span class=n>t</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>update</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>size</span> <span class=n>t</span><span class=o>)</span> <span class=n>x</span> <span class=n>tl</span>
</span></span></code></pre></td></tr></table></div></div><p>All operations run in O(logn) worst-case time. But <code>cons</code>, <code>head</code> and <code>tail</code> run in O(logn) not O(1) is one disappointing
aspect.</p><h3 id=zeroless-representation>Zeroless representation<a hidden class=anchor aria-hidden=true href=#zeroless-representation>#</a></h3><p>Currently, <code>head</code> is implemented via a call to <code>unconsTree</code>, this approach yields compact code <code>unconsTree</code> supports both
<code>head</code> and <code>tail</code>, but wastes time building lists that are immediately discard by <code>head</code>. For greater efficiency, we should
implement <code>head</code> directly. As a special case, <code>head</code> can easily be made to run in O(1) time whenever the first digit is
non-zero. So we seek to arrange that the first digit is always non-zero, one more principled solution is to use a zeroless
representation, in which binary numbers are constructed from ones and twos instead of zeros and ones:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>nat</span> <span class=o>=</span> <span class=n>digit</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl><span class=ow>and</span> <span class=n>digit</span> <span class=o>=</span> <span class=nc>One</span> <span class=o>|</span> <span class=nc>Two</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>inc</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=o>[</span><span class=nc>One</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=o>::</span> <span class=n>ds</span> <span class=o>-&gt;</span> <span class=nc>Two</span> <span class=o>::</span> <span class=n>ds</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Two</span> <span class=o>::</span> <span class=n>ds</span> <span class=o>-&gt;</span> <span class=nc>One</span> <span class=o>::</span> <span class=n>inc</span> <span class=n>ds</span>
</span></span></code></pre></td></tr></table></div></div><p>And the implementation of random-access list is:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=c>(** randomAccessListZeroless.ml 
</span></span></span><span class=line><span class=cl><span class=c>  * the interface is same as RandomAccessList *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>=</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>digit</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl><span class=ow>and</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>digit</span> <span class=o>=</span> <span class=nc>One</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span> <span class=o>|</span> <span class=nc>Two</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl><span class=ow>and</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span> <span class=o>=</span> <span class=nc>Leaf</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=kt>int</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=bp>[]</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>isEmpty</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=bp>true</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>exception</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>size</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Leaf</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>1</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=o>_,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>link</span> <span class=n>t1</span> <span class=n>t2</span> <span class=o>=</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>size</span> <span class=n>t1</span> <span class=o>+</span> <span class=n>size</span> <span class=n>t2</span><span class=o>,</span> <span class=n>t1</span><span class=o>,</span> <span class=n>t2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>cons</span> <span class=n>x</span> <span class=n>ts</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>consTree</span> <span class=n>t</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=o>[</span><span class=nc>One</span> <span class=n>t</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>One</span> <span class=n>t1</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>Two</span> <span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>t1</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Two</span> <span class=o>(</span><span class=n>t1</span><span class=o>,</span> <span class=n>t2</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>consTree</span> <span class=o>(</span><span class=n>link</span> <span class=n>t1</span> <span class=n>t2</span><span class=o>)</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=k>in</span> <span class=n>consTree</span> <span class=o>(</span><span class=nc>Leaf</span> <span class=n>x</span><span class=o>)</span> <span class=n>ts</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>head</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=nc>Leaf</span> <span class=n>x</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Two</span> <span class=o>(</span><span class=nc>Leaf</span> <span class=n>x</span><span class=o>,</span> <span class=o>_)</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>assert</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>tail</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>[</span><span class=nc>One</span> <span class=o>_]</span> <span class=o>-&gt;</span> <span class=bp>[]</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=o>_</span> <span class=o>::</span> <span class=nc>One</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>Two</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=o>_</span> <span class=o>::</span> <span class=nc>Two</span> <span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(_,</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>))</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>Two</span> <span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>::</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Two</span> <span class=o>(_,</span> <span class=n>t</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>assert</span> <span class=bp>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>lookupTree</span> <span class=n>i</span> <span class=n>t</span> <span class=o>=</span> <span class=k>match</span> <span class=n>i</span><span class=o>,</span> <span class=n>t</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>0</span><span class=o>,</span> <span class=nc>Leaf</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>i</span><span class=o>,</span> <span class=nc>Leaf</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>i</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>/</span> <span class=n>2</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>lookupTree</span> <span class=n>i</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>lookupTree</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>n</span> <span class=o>/</span> <span class=n>2</span><span class=o>)</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>updateTree</span> <span class=n>i</span> <span class=n>x</span> <span class=n>t</span> <span class=o>=</span><span class=k>match</span> <span class=n>i</span><span class=o>,</span> <span class=n>t</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>0</span><span class=o>,</span> <span class=nc>Leaf</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=nc>Leaf</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>i</span><span class=o>,</span> <span class=nc>Leaf</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>i</span><span class=o>,</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>/</span> <span class=n>2</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=n>updateTree</span> <span class=n>i</span> <span class=n>x</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nc>Node</span> <span class=o>(</span><span class=n>n</span><span class=o>,</span> <span class=n>left</span><span class=o>,</span> <span class=n>updateTree</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>n</span> <span class=o>/</span> <span class=n>2</span><span class=o>)</span> <span class=n>x</span> <span class=n>right</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>lookup</span> <span class=n>i</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span> <span class=n>t</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>lookupTree</span> <span class=n>i</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>lookup</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>size</span> <span class=n>t</span><span class=o>)</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Two</span> <span class=o>(</span><span class=n>t1</span><span class=o>,</span> <span class=n>t2</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=n>t1</span> 
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>lookupTree</span> <span class=n>i</span> <span class=n>t1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=n>t2</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=n>lookupTree</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>size</span> <span class=n>t1</span><span class=o>)</span> <span class=n>t2</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>lookup</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>size</span> <span class=n>t1</span> <span class=o>-</span> <span class=n>size</span> <span class=n>t2</span><span class=o>)</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>update</span> <span class=n>i</span> <span class=n>x</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>Empty</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>(</span><span class=nc>One</span> <span class=n>t</span> <span class=k>as</span> <span class=n>hd</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=n>t</span> 
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=nc>One</span> <span class=o>(</span><span class=n>updateTree</span> <span class=n>i</span> <span class=n>x</span> <span class=n>t</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>hd</span> <span class=o>::</span> <span class=n>update</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>size</span> <span class=n>t</span><span class=o>)</span> <span class=n>x</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>(</span><span class=nc>Two</span> <span class=o>(</span><span class=n>t1</span><span class=o>,</span> <span class=n>t2</span><span class=o>)</span> <span class=k>as</span> <span class=n>hd</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=n>t1</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=nc>Two</span> <span class=o>(</span><span class=n>updateTree</span> <span class=n>i</span> <span class=n>x</span> <span class=n>t1</span><span class=o>,</span> <span class=n>t2</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=n>t2</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> <span class=nc>Two</span> <span class=o>(</span><span class=n>t1</span><span class=o>,</span> <span class=n>updateTree</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>size</span> <span class=n>t1</span><span class=o>)</span> <span class=n>x</span> <span class=n>t2</span><span class=o>)</span> <span class=o>::</span> <span class=n>tl</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>hd</span> <span class=o>::</span> <span class=n>update</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>size</span> <span class=n>t1</span> <span class=o>-</span> <span class=n>size</span> <span class=n>t2</span><span class=o>)</span> <span class=n>x</span> <span class=n>tl</span>
</span></span></code></pre></td></tr></table></div></div><p>Now the <code>head</code> and <code>tail</code> take O(1) time.</p><h2 id=data-structural-bootstrapping>Data-structural bootstrapping<a hidden class=anchor aria-hidden=true href=#data-structural-bootstrapping>#</a></h2><p>The term &ldquo;bootstrapping&rdquo; refers to solving problems via solving simple instance of the same problem. And there are three
algorithmic design techniques of data-structural bootstrapping. The first, <em>structural decomposition</em>, involves bootstrapping
complete data structures from incomplete data structures. The second, <em>structural abstraction</em>, involves bootstrapping
efficient data structures from inefficient data structures. The last bootstrapping data structures with aggregate elements
from data structures with atomic elements.</p><h3 id=structural-decomposition>Structural decomposition<a hidden class=anchor aria-hidden=true href=#structural-decomposition>#</a></h3><p>Typically <em>structural decomposition</em> involves taking an implementation can handle objects only up to some bound size, and
extending it to handle objects of unbounded size. Consider typical recursive datatypes such as lists and binary leaf trees:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span> <span class=o>=</span> <span class=nc>Nil</span> <span class=o>|</span> <span class=nc>Cons</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span> <span class=o>=</span> <span class=nc>Leaf</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>|</span> <span class=nc>Node</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>tree</span>
</span></span></code></pre></td></tr></table></div></div><p>In some ways, these can be regarded as instances of some bounded size(zero for lists and one fo tree) and a rule for
recursively decomposing larger objects into smaller objects until eventually each object is small enough to be handled
by the bounded case.</p><p>However, both of these definitions are particularly simple that the recursive component in each definition is identical
to the type being defined, which called <em>uniformly recursive</em>. In general, we reserve the term <em>structural decomposition</em>
to describe recursive data structure that are <em>non-uniform</em> for cases that the recursive component is different from its
definition, e.g. <code>type 'a seq = Nil | Cons of 'a * ('a * 'a) seq</code>. But you can not implement structural decomposition
directly in ML, althought it allows the definition of non-uniform recursive datatypes. But the type system always disallow
the functions on such types like below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=o>(</span><span class=k>type</span> <span class=n>illegal</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>size</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Nil</span> <span class=o>-&gt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Cons</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>ps</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>1</span> <span class=o>+</span> <span class=n>2</span> <span class=o>*</span> <span class=n>size</span> <span class=n>ps</span>
</span></span></code></pre></td></tr></table></div></div><p>Fortunately it is always possible to convert a non-uniform type into a uniform type by introducing a new datatype to
collapse the different instances into a single type, for example, we can rewrite the <code>seq</code> as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>ep</span> <span class=o>=</span> <span class=nc>Elem</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>|</span> <span class=nc>Pair</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>ep</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>ep</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>seq</span> <span class=o>=</span> <span class=nc>Nil</span> <span class=o>|</span> <span class=nc>Cons</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>ep</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>seq</span>
</span></span></code></pre></td></tr></table></div></div><p>Notice that the <code>'a ep</code> type is isomorphic to binary leaf trees, so the version of <code>'a seq</code> is equivalent to <code>'a tree list</code>,
though we would tend to think a list of trees differently that we would think of a sequence of pairs &ndash; some algorithms
will seem simpler or more natural for one of the representations, and some for the other.</p><p>To use sequence represent positional number system, we need to represent zero, it&rsquo;s easily corrected by adding another
constructor of the type:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>seq</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>   <span class=o>|</span> <span class=nc>Nil</span>
</span></span><span class=line><span class=cl>   <span class=o>|</span> <span class=nc>Zero</span> <span class=k>of</span> <span class=o>(</span><span class=k>&#39;</span><span class=n>a</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span><span class=o>)</span> <span class=n>seq</span>
</span></span><span class=line><span class=cl>   <span class=o>|</span> <span class=nc>One</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>*</span> <span class=o>(</span><span class=k>&#39;</span><span class=n>a</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span><span class=o>)</span> <span class=n>seq</span>
</span></span></code></pre></td></tr></table></div></div><p>Now we can represent the sequence 0&mldr;10 as <code>One(0, One((1, 2), Zero(One((((3, 4), (5, 6)), ((7, 8), (9, 10))), Nil))))</code>,
which has 11 elements, written 1101 in binary. The pairs in this type are always balanced. In fact, another way to think
of pairs of elements is as complete binary leaf trees. And then we can replement binary random-access lists use this type.</p><h3 id=tries>Tries<a hidden class=anchor aria-hidden=true href=#tries>#</a></h3><p>Binary search trees work well when comparisons on the key or element type are cheap. This is true for simple types like
integers or characters, but may not be true for aggregate types like strings. A better solution for aggregate types such
as string is to choose a representation that takes advantage of the structure of that type. One such representation is
<em>tries</em>, also known as a <em>digital search trees</em>.</p><p>A trie is a multiway tree where each edge is labelled with a character. Edges leaving the root of a trie represent the
first character of a string, and so on. and if the node is vaild, which means it contains a value, we can mark it as
<code>Some x</code>, otherwise <code>None</code>. The critical remaining question is how to represent the edges leaving a node, we can represent
edges as a vector, an association list, a binary search tree, or even another trie. But all of these are just finite maps
from edges labels to tries. So we can use a given structure Map implementing finite maps over base type:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>=</span> <span class=nc>Trie</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>option</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=nc>Map</span> <span class=nn>Map</span><span class=p>.</span><span class=n>t</span>
</span></span></code></pre></td></tr></table></div></div><p>Thus we can implement Trie as a functor from finiteMap to finiteMap:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>FiniteMap</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>exception</span> <span class=nc>NotFound</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>empty</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>bind</span> <span class=o>:</span> <span class=n>key</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>lookup</span> <span class=o>:</span> <span class=n>key</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>Make</span> <span class=o>(</span><span class=nc>Map</span> <span class=o>:</span> <span class=nc>FiniteMap</span><span class=o>)</span> <span class=o>:</span> <span class=nc>FiniteMap</span> <span class=o>=</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>key</span> <span class=o>=</span> <span class=nn>Map</span><span class=p>.</span><span class=n>key</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>=</span> <span class=nc>Trie</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>option</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=nn>Map</span><span class=p>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>exception</span> <span class=nc>NotFound</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>empty</span> <span class=o>=</span> <span class=nc>Trie</span><span class=o>(</span><span class=nc>None</span><span class=o>,</span> <span class=nn>Map</span><span class=p>.</span><span class=n>empty</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>lookup</span> <span class=n>key</span> <span class=n>trie</span> <span class=o>=</span> <span class=k>match</span> <span class=n>key</span><span class=o>,</span> <span class=n>trie</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span><span class=o>,</span> <span class=nc>Trie</span> <span class=o>(</span><span class=nc>None</span><span class=o>,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=k>raise</span> <span class=nc>NotFound</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span><span class=o>,</span> <span class=nc>Trie</span> <span class=o>(</span><span class=nc>Some</span> <span class=n>x</span><span class=o>,</span> <span class=o>_)</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>k</span> <span class=o>::</span> <span class=n>ks</span><span class=o>,</span> <span class=nc>Trie</span> <span class=o>(_,</span> <span class=n>m</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>lookup</span> <span class=n>ks</span> <span class=o>(</span><span class=nn>Map</span><span class=p>.</span><span class=n>lookup</span> <span class=n>k</span> <span class=n>m</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=k>rec</span> <span class=n>bind</span> <span class=n>key</span> <span class=n>x</span> <span class=n>trie</span> <span class=o>=</span> <span class=k>match</span> <span class=n>key</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=n>trie</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=bp>[]</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=nc>Trie</span> <span class=o>(_,</span> <span class=n>m</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=nc>Trie</span> <span class=o>(</span><span class=nc>Some</span> <span class=n>x</span><span class=o>,</span> <span class=n>m</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>k</span> <span class=o>::</span> <span class=n>ks</span><span class=o>,</span> <span class=n>x</span><span class=o>,</span> <span class=nc>Trie</span> <span class=o>(</span><span class=n>v</span><span class=o>,</span> <span class=n>m</span><span class=o>)</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>      <span class=k>let</span> <span class=n>t</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=nn>Map</span><span class=p>.</span><span class=n>lookup</span> <span class=n>k</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=nc>NotFound</span> <span class=o>-&gt;</span> <span class=n>empty</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>      <span class=k>let</span> <span class=n>t&#39;</span> <span class=o>=</span> <span class=n>bind</span> <span class=n>ks</span> <span class=n>x</span> <span class=n>t</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>      <span class=nc>Trie</span> <span class=o>(</span><span class=n>v</span><span class=o>,</span> <span class=nn>Map</span><span class=p>.</span><span class=n>bind</span> <span class=n>k</span> <span class=n>t&#39;</span> <span class=n>m</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://www.sdlinks.net/tags/ocaml/>OCaml</a></li><li><a href=http://www.sdlinks.net/tags/functional/>Functional</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 2 on x" href="https://x.com/intent/tweet/?text=Functional%20Data%20Structure%202&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-2%2f&amp;hashtags=OCaml%2cFunctional"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-2%2f&amp;title=Functional%20Data%20Structure%202&amp;summary=Functional%20Data%20Structure%202&amp;source=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 2 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-2%2f&title=Functional%20Data%20Structure%202"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 2 on whatsapp" href="https://api.whatsapp.com/send?text=Functional%20Data%20Structure%202%20-%20http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 2 on telegram" href="https://telegram.me/share/url?text=Functional%20Data%20Structure%202&amp;url=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Functional Data Structure 2 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Functional%20Data%20Structure%202&u=http%3a%2f%2fwww.sdlinks.net%2fposts%2f2018%2ffunctional-data-structure-2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=Christophe1996/blog data-repo-id="MDEwOlJlcG8zaXRvcnkyMjU4MTQyMTM=" data-category=Announcements data-category-id=DIC_kwDODXWmxc3CmuF3 data-mapping=pathname data-strict=-1 data-reactions-enabled=0 data-emit-metadata=-1 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=http://www.sdlinks.net/>CastOff</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>