[{"content":"阿里巴巴开源的 Zvec 向量数据库是一个轻量级、快速的进程内向量数据库，为开发者提供了一个简单而强大的方式来构建向量搜索应用。今天我来深入了解这个项目。\n什么是 Zvec？ Zvec 是一个开源的进程内向量数据库，主打\u0026quot;轻量级、闪电般快速\u0026quot;。它基于阿里巴巴经过实战检验的 Proxima 向量搜索引擎构建，可以在应用程序内部直接嵌入运行，无需独立的数据库服务器。\n核心特性 极快的速度：能够在毫秒级别搜索数十亿个向量 开箱即用：安装后几秒钟即可开始使用，无需复杂的服务器配置 多种向量支持：同时支持密集向量（dense vectors）和稀疏向量（sparse vectors） 混合搜索：可以结合语义相似度和结构化过滤条件进行精确搜索 跨平台运行：作为进程内库，可以在笔记本、服务器、CLI 工具甚至边缘设备上运行 快速上手 Zvec 目前支持 Python 和 Node.js 两种语言，Python 版本支持 3.10-3.12。\n安装 1 pip install zvec 基本使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import zvec # 定义集合 schema schema = zvec.CollectionSchema( name=\u0026#34;example\u0026#34;, vectors=zvec.VectorSchema(\u0026#34;embedding\u0026#34;, zvec.DataType.VECTOR_FP32, 4), ) # 创建集合 collection = zvec.create_and_open(path=\u0026#34;./zvec_example\u0026#34;, schema=schema) # 插入文档 collection.insert([ zvec.Doc(id=\u0026#34;doc_1\u0026#34;, vectors={\u0026#34;embedding\u0026#34;: [0.1, 0.2, 0.3, 0.4]}), zvec.Doc(id=\u0026#34;doc_2\u0026#34;, vectors={\u0026#34;embedding\u0026#34;: [0.2, 0.3, 0.4, 0.1]}), ]) # 按向量相似度搜索 results = collection.query( zvec.VectorQuery(\u0026#34;embedding\u0026#34;, vector=[0.4, 0.3, 0.3, 0.1]), topk=10 ) # 结果按相关性排序 print(results) 支持的搜索类型 Zvec 支持两种主要的搜索方式：\n基础相似度搜索：纯粹基于向量相似度进行检索 过滤相似度搜索：结合向量搜索和条件过滤，只有匹配条件的文档才会被考虑 性能表现 根据官方提供的基准测试数据，Zvec 在性能方面表现出色：\n索引构建速度：1000 万个 768 维向量的索引构建时间约为 1 小时 查询吞吐量：在 1000 万向量的数据集上可以达到 8500+ QPS 测试数据集：使用 Cohere 1M（100 万向量）和 Cohere 10M（1000 万向量）标准数据集 评估指标：QPS（每秒查询数）、召回率（Recall）、索引构建时间 这些性能数据基于阿里云 g9i.4xlarge 实例（16 vCPU, 64 GiB RAM）测试得出，使用 VectorDBBench 框架进行评估。\n应用场景 Zvec 特别适合以下应用场景：\n1. RAG（检索增强生成） 为 LLM 提供相关的外部知识，增强回答的准确性和时效性。Zvec 可以快速从知识库中检索最相关的文档片段。\n2. 图像搜索 基于图像的视觉或语义相似度进行大规模图像检索。无论是查找相似的产品图片，还是按内容检索照片，都能提供高效的解决方案。\n3. 代码搜索 通过自然语言描述来搜索代码片段。这对于开发者工具、代码库管理系统等场景非常有用。\n技术架构 Zvec 基于阿里巴巴内部广泛使用的 Proxima 向量搜索引擎，这意味着：\n生产环境验证：技术已经在阿里巴巴的高流量、大规模生产环境中得到验证 成熟稳定：经过多年的实战检验，稳定性和可靠性有保障 持续优化：阿里巴巴团队会持续优化和更新项目 与传统向量数据库的对比 传统的向量数据库（如 Milvus、Pinecone、Weaviate 等）通常作为独立服务运行，需要额外的部署和运维成本。而 Zvec 采用了不同的设计理念：\n进程内架构的优势：\n无需部署独立服务，降低运维复杂度 减少网络通信开销，提升性能 更容易集成到现有应用中 适合边缘计算和本地部署场景 适用场景差异：\n传统向量数据库更适合大规模分布式场景 Zvec 更适合需要快速集成、低复杂度的应用场景 社区与生态 Zvec 拥有活跃的社区支持：\n文档完善：提供详细的快速入门指南、API 文档和性能基准测试报告 多语言支持：Python 和 Node.js SDK 跨平台：支持 Linux（x86_64, ARM64）和 macOS（ARM64） 开源社区：Discord 社区和 Twitter 账号，方便开发者交流和获取支持 总结 Zvec 作为阿里巴巴开源的向量数据库，在轻量级和性能之间找到了很好的平衡点。对于需要快速集成向量搜索能力的开发者来说，它提供了一个简单而强大的解决方案。\n它的核心优势在于：\n极简使用：无需复杂配置，几行代码即可上手 高性能：基于 Proxima 的成熟技术，性能表现优异 灵活部署：进程内设计，适合各种部署场景 开源免费：完全开源，没有商业授权成本 如果你正在构建需要向量搜索功能的应用，尤其是 RAG、图像搜索或代码搜索等场景，Zvec 值得考虑。它可能不是最强大的向量数据库，但可能是最简单易用的之一。\n本文包含AI生成内容\n","permalink":"https://www.sdlinks.net/posts/2026/zvec-lightweight-vector-database/","summary":"\u003cp\u003e阿里巴巴开源的 Zvec 向量数据库是一个轻量级、快速的进程内向量数据库，为开发者提供了一个简单而强大的方式来构建向量搜索应用。今天我来深入了解这个项目。\u003c/p\u003e\n\u003ch2 id=\"什么是-zvec\"\u003e什么是 Zvec？\u003c/h2\u003e\n\u003cp\u003eZvec 是一个开源的进程内向量数据库，主打\u0026quot;轻量级、闪电般快速\u0026quot;。它基于阿里巴巴经过实战检验的 Proxima 向量搜索引擎构建，可以在应用程序内部直接嵌入运行，无需独立的数据库服务器。\u003c/p\u003e\n\u003ch3 id=\"核心特性\"\u003e核心特性\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e极快的速度\u003c/strong\u003e：能够在毫秒级别搜索数十亿个向量\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e开箱即用\u003c/strong\u003e：安装后几秒钟即可开始使用，无需复杂的服务器配置\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e多种向量支持\u003c/strong\u003e：同时支持密集向量（dense vectors）和稀疏向量（sparse vectors）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e混合搜索\u003c/strong\u003e：可以结合语义相似度和结构化过滤条件进行精确搜索\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e跨平台运行\u003c/strong\u003e：作为进程内库，可以在笔记本、服务器、CLI 工具甚至边缘设备上运行\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"快速上手\"\u003e快速上手\u003c/h2\u003e\n\u003cp\u003eZvec 目前支持 Python 和 Node.js 两种语言，Python 版本支持 3.10-3.12。\u003c/p\u003e\n\u003ch3 id=\"安装\"\u003e安装\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epip install zvec\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"基本使用示例\"\u003e基本使用示例\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003ezvec\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 定义集合 schema\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eschema\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ezvec\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCollectionSchema\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;example\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evectors\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ezvec\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eVectorSchema\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;embedding\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ezvec\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDataType\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eVECTOR_FP32\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 创建集合\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecollection\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ezvec\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecreate_and_open\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epath\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;./zvec_example\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eschema\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eschema\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 插入文档\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecollection\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003einsert\u003c/span\u003e\u003cspan class=\"p\"\u003e([\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ezvec\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;doc_1\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evectors\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;embedding\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.4\u003c/span\u003e\u003cspan class=\"p\"\u003e]}),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ezvec\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;doc_2\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evectors\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;embedding\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.1\u003c/span\u003e\u003cspan class=\"p\"\u003e]}),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 按向量相似度搜索\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eresults\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecollection\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003equery\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ezvec\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eVectorQuery\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;embedding\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.1\u003c/span\u003e\u003cspan class=\"p\"\u003e]),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003etopk\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 结果按相关性排序\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eresults\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"支持的搜索类型\"\u003e支持的搜索类型\u003c/h3\u003e\n\u003cp\u003eZvec 支持两种主要的搜索方式：\u003c/p\u003e","title":"Zvec：阿里巴巴开源的轻量级进程内向量数据库"},{"content":"最近在探索 AI 工具生态时，发现了一个很有用的工具——mcporter。这是一个专门用于 Model Context Protocol (MCP) 的 CLI 工具和生成器，可以帮助我们更方便地发现和使用各种 MCP 服务器提供的工具。\n什么是 MCP？ Model Context Protocol (MCP) 是一个开放标准，定义了 AI 助手如何与外部工具和服务进行通信。通过 MCP，我们可以将各种功能集成到 AI 助手中，比如文档查询、数据库访问、API 调用等。\nmcporter 的核心功能 mcporter 提供了几个关键功能：\n1. 服务器管理 1 2 mcporter list # 列出所有配置的 MCP 服务器 mcporter list \u0026lt;server\u0026gt; --schema # 查看特定服务器的工具定义 这个功能让我能够快速了解有哪些可用的工具，以及每个工具的输入输出格式。\n2. 工具调用 1 mcporter call \u0026lt;selector\u0026gt; [key=value ...] 可以直接调用 MCP 工具，支持通过 HTTP URL 或服务器名.工具名的选择器来定位。\n3. 配置管理 mcporter 会自动从 config/mcporter.json 加载服务器配置，也支持从编辑器（如 Cursor、Claude）导入配置。\n实际应用场景 配置好 mcporter 后，我发现它在以下几个场景特别有用：\n工具发现：在使用 MCP 工具前，先通过 mcporter list 查看可用的服务器和工具，了解每个工具的功能和输入输出格式。这是目前的工作流程：发现 → 理解 → 调用\n扩展 AI 能力：OpenClaw 可以通过 mcporter 连接任何 MCP 服务，将外部工具无缝集成到自己的工具调用能力中。这意味着不再局限于内置的工具集，而是可以根据需求动态扩展功能\n测试验证：直接调用 MCP 工具验证功能是否符合预期，快速原型和调试\n配置示例 配置文件 config/mcporter.json 示例：\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;mcpServers\u0026#34;: { \u0026#34;context7\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://mcp.context7.com/mcp\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;CONTEXT7_API_KEY\u0026#34;: \u0026#34;your-api-key\u0026#34; } } } } 使用心得 自从使用 mcporter 后，我发现管理 MCP 工具变得更加系统化。不再是零散地查找和配置，而是可以通过统一的命令行界面完成所有操作。这大大提高了工作效率，也让我更容易探索新的工具和服务。\n对于需要频繁与 MCP 服务器交互的开发者来说，mcporter 是一个值得尝试的工具。\n本文包含AI生成内容\n","permalink":"https://www.sdlinks.net/posts/2026/discovering-mcp-tools-with-mcporter/","summary":"\u003cp\u003e最近在探索 AI 工具生态时，发现了一个很有用的工具——mcporter。这是一个专门用于 Model Context Protocol (MCP) 的 CLI 工具和生成器，可以帮助我们更方便地发现和使用各种 MCP 服务器提供的工具。\u003c/p\u003e\n\u003ch2 id=\"什么是-mcp\"\u003e什么是 MCP？\u003c/h2\u003e\n\u003cp\u003eModel Context Protocol (MCP) 是一个开放标准，定义了 AI 助手如何与外部工具和服务进行通信。通过 MCP，我们可以将各种功能集成到 AI 助手中，比如文档查询、数据库访问、API 调用等。\u003c/p\u003e\n\u003ch2 id=\"mcporter-的核心功能\"\u003emcporter 的核心功能\u003c/h2\u003e\n\u003cp\u003emcporter 提供了几个关键功能：\u003c/p\u003e\n\u003ch3 id=\"1-服务器管理\"\u003e1. 服务器管理\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emcporter list                          \u003cspan class=\"c1\"\u003e# 列出所有配置的 MCP 服务器\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emcporter list \u0026lt;server\u0026gt; --schema        \u003cspan class=\"c1\"\u003e# 查看特定服务器的工具定义\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这个功能让我能够快速了解有哪些可用的工具，以及每个工具的输入输出格式。\u003c/p\u003e\n\u003ch3 id=\"2-工具调用\"\u003e2. 工具调用\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emcporter call \u0026lt;selector\u0026gt; \u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"nv\"\u003ekey\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003evalue ...\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e可以直接调用 MCP 工具，支持通过 HTTP URL 或服务器名.工具名的选择器来定位。\u003c/p\u003e\n\u003ch3 id=\"3-配置管理\"\u003e3. 配置管理\u003c/h3\u003e\n\u003cp\u003emcporter 会自动从 \u003ccode\u003econfig/mcporter.json\u003c/code\u003e 加载服务器配置，也支持从编辑器（如 Cursor、Claude）导入配置。\u003c/p\u003e\n\u003ch2 id=\"实际应用场景\"\u003e实际应用场景\u003c/h2\u003e\n\u003cp\u003e配置好 mcporter 后，我发现它在以下几个场景特别有用：\u003c/p\u003e","title":"使用 mcporter 发现和管理 MCP 工具"},{"content":"My LLM codegen workflow atm, Harper Reed在文中介绍了基于LLM的代码生成工作流。主要介绍了两种场景，开发一个新项目（Greenfield）以及老项目的持续迭代(Non-greenfield)。\n新项目基于需求细化（spec），计划制定（todo）以及代码生成三部分来开展。老项目则通过生成代码上下文（repomix）来制定测试回归和代码审查任务。这对我来说是一个巨大的启发，准备找时间试一下其中描述的工作流程。\n同时Harper Reed也给出了具体的Prompt，局限于目前LLM的特性，仍然需要通过提示工程来引导AI生成我们需要的内容。前一阵子较火的DeepSeek从入门到精通也指出掌握提示语设计是AIGC时代的必备技能，在平时使用这些LLM工具中也感受到怎么清晰的向AI表达需求非常重要，因为你的提示语完全决定了AI生成的质量，进而决定了AI是否好用或者为你带来提效。另外，由于中文的特性（高上下文依赖）以及模型的训练数据分布，可能会出现提示效果不如英文的情况。\n","permalink":"https://www.sdlinks.net/posts/2025/my-llm-codegen-workflow-atm/","summary":"\u003cp\u003e\u003ca href=\"https://harper.blog/2025/02/16/my-llm-codegen-workflow-atm/\"\u003eMy LLM codegen workflow atm\u003c/a\u003e, Harper Reed在文中介绍了基于LLM的代码生成工作流。主要介绍了两种场景，开发一个新项目（Greenfield）以及老项目的持续迭代(Non-greenfield)。\u003c/p\u003e\n\u003cp\u003e新项目基于需求细化（spec），计划制定（todo）以及代码生成三部分来开展。老项目则通过生成代码上下文（\u003ca href=\"https://github.com/yamadashy/repomix\"\u003erepomix\u003c/a\u003e）来制定测试回归和代码审查任务。这对我来说是一个巨大的启发，准备找时间试一下其中描述的工作流程。\u003c/p\u003e\n\u003cp\u003e同时Harper Reed也给出了具体的Prompt，局限于目前LLM的特性，仍然需要通过\u003ca href=\"https://www.promptingguide.ai\"\u003e提示工程\u003c/a\u003e来引导AI生成我们需要的内容。前一阵子较火的\u003ca href=\"https://mp.weixin.qq.com/s/3Igd0u3ToUmPE-od_wzRKw\"\u003eDeepSeek从入门到精通\u003c/a\u003e也指出掌握提示语设计是AIGC时代的必备技能，在平时使用这些LLM工具中也感受到怎么清晰的向AI表达需求非常重要，因为你的提示语完全决定了AI生成的质量，进而决定了AI是否好用或者为你带来提效。另外，由于中文的特性（高上下文依赖）以及模型的训练数据分布，可能会出现提示效果不如英文的情况。\u003c/p\u003e","title":"My LLM codegen workflow atm"},{"content":"Go 1.24 Release Notes， Go 1.24已经于2.11正式发布，主要语言特性为泛型类型别名和基于Swiss Tables的map实现，通过轻微的delete性能损耗来显著提升查询和插入的性能（via）。\n","permalink":"https://www.sdlinks.net/posts/2025/go1-24/","summary":"\u003cp\u003e\u003ca href=\"https://tip.golang.org/doc/go1.24\"\u003eGo 1.24 Release Notes\u003c/a\u003e， Go 1.24已经于2.11正式发布，主要语言特性为\u003ca href=\"https://github.com/golang/go/issues/46477\"\u003e泛型类型别名\u003c/a\u003e和基于\u003ca href=\"https://abseil.io/about/design/swisstables\"\u003eSwiss Tables\u003c/a\u003e的\u003ccode\u003emap\u003c/code\u003e实现，通过轻微的delete性能损耗来显著提升查询和插入的性能（\u003ca href=\"https://www.bytesizego.com/blog/go-124-swiss-table-maps\"\u003evia\u003c/a\u003e）。\u003c/p\u003e","title":"Go 1.24"},{"content":"Three Observations, 奥尔特曼提出了关于AI经济学的3个论断：\nAI模型的智能水平大致等于用于训练和运行它的资源的对数； 使用特定水平的AI的成本每12个月大约下降10倍（摩尔定律18个月才有2倍）； 线性增加的智能所带来的社会经济价值是超指数级的。 随着DeepSeek-R1的火爆，整个社会更广泛的进入了AI时代，一众大厂应用纷纷接入，普通人使用的成本进一步下降。之前一直有观点认为AI会逐步淘汰部分岗位，并且这种事情会首先发生在程序员这个职业上。目前就我个人的体验来讲，AI现在已经能做到生成不错的代码，处理较为复杂的任务。虽然在整个公司层面还没有开始大规模在开发流程中使用AI，但我认为这是未来近几年的方向，届时会出现Cursor、通义灵码这些产品的终极形态，AI变成你的同事。而作为程序员的我们，工作方式会更向需求分析、架构设计和团队协作等需要人类创造力和判断力的方向靠拢（via）。\n","permalink":"https://www.sdlinks.net/posts/2025/three-observations/","summary":"\u003cp\u003e\u003ca href=\"https://blog.samaltman.com/three-observations\"\u003eThree Observations\u003c/a\u003e, 奥尔特曼提出了关于AI经济学的3个论断：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eAI模型的智能水平大致等于用于训练和运行它的资源的对数；\u003c/li\u003e\n\u003cli\u003e使用特定水平的AI的成本每12个月大约下降10倍（摩尔定律18个月才有2倍）；\u003c/li\u003e\n\u003cli\u003e线性增加的智能所带来的社会经济价值是超指数级的。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e随着\u003ca href=\"https://github.com/deepseek-ai/DeepSeek-R1\"\u003eDeepSeek-R1\u003c/a\u003e的火爆，整个社会更广泛的进入了AI时代，一众大厂应用纷纷接入，普通人使用的成本进一步下降。之前一直有观点认为AI会逐步淘汰部分岗位，并且这种事情会首先发生在程序员这个职业上。目前就我个人的体验来讲，AI现在已经能做到生成不错的代码，处理较为复杂的任务。虽然在整个公司层面还没有开始大规模在开发流程中使用AI，但我认为这是未来近几年的方向，届时会出现Cursor、通义灵码这些产品的终极形态，AI变成你的同事。而作为程序员的我们，工作方式会更向需求分析、架构设计和团队协作等需要人类创造力和判断力的方向靠拢（\u003ca href=\"https://ghuntley.com/dothings/\"\u003evia\u003c/a\u003e）。\u003c/p\u003e","title":"Three Observations"},{"content":"Build a link blog, 最近从Simon Willison看到的想法，觉得是一个重新捡起Blog的机会。这个依托于Github Pages 的博客站点荒废了好久，最早可以追溯到2018年，彼时还未大学毕业，中间有一段时间荒废，后续迁移到博客园上重启，过来一段时间后又荒废。如今又重新捡起，说实话整体感受还是比较复杂的，之前荒废的原因无外乎以下几点：\n懒； 觉得无法输出有意思的观点，只是在拾人牙慧； 由于2，导致写blog过程中没收到什么反馈，没有反馈的事情，对人类来说还是太难坚持了。 但是近期从Simon Willison那了解到了关于blog内容的新思路：\nIt’s easy to get hung up on this. I’ve definitely felt the self-imposed pressure to only write something if it’s new, and unique, and feels like it’s never been said before. This is a mental trap that does nothing but hold you back.\n这个我深有同感，一开始其实整体内容围绕着一些常见的学习知识点、读书内容，慢慢就发现，如果说我不能输出独特的观点，这值得我写一篇文章/博客吗？进而转到如果我的博客没人看，我还要花时间在上面吗？甚至之前还觉得我应该写英文文章，这样部署在Github Pages才有更多的读者。说回来，Simon Willison认为blog的价值在于保持长期的写作习惯，同时随着时间的推移有所收获， 同时Simon Willison给出了写blog的几个内容(via)：\nTIL(Things I Learned)； DMP(Descriptions of My Projects)； TIF(Things I\u0026rsquo;ve Found)。 基于3就衍生出了本文的主题，“links”, 也就是说通过blog的形式分享记录自己阅读的内容。作为一个Link Blog, 可以包含以下内容：\n作者，可以通过tag来标识； 增加自己的观点，并非单纯的分享，最基本的，为什么分享的link值得一读； 汇总其他类似内容，包含自己的历史创作； 这里衍生出的一个问题是，如果我阅读来源就是一个link blog, 基于此产生的新的link blog应当更多的基于原始的文章，“Link to origin not link to link”。\n基于此，我又重启了这个blog, 后续大部分内容应该会基于links来更新，先培养写作习惯。\n","permalink":"https://www.sdlinks.net/posts/2025/restart-a-link-blog/","summary":"\u003cp\u003e\u003ca href=\"https://simonwillison.net/2025/Feb/4/build-a-link-blog/\"\u003eBuild a link blog\u003c/a\u003e, 最近从\u003ca href=\"https://simonwillison.net/\"\u003eSimon Willison\u003c/a\u003e看到的想法，觉得是一个重新捡起Blog的机会。这个依托于Github\nPages 的博客站点荒废了好久，最早可以追溯到2018年，彼时还未大学毕业，中间有一段时间荒废，后续迁移到博客园上重启，过来一段时间后又荒废。如今又重新捡起，说实话整体感受还是比较复杂的，之前荒废的原因无外乎以下几点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e懒；\u003c/li\u003e\n\u003cli\u003e觉得无法输出有意思的观点，只是在拾人牙慧；\u003c/li\u003e\n\u003cli\u003e由于2，导致写blog过程中没收到什么反馈，没有反馈的事情，对人类来说还是太难坚持了。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e但是近期从Simon Willison那了解到了关于blog内容的新思路：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIt’s easy to get hung up on this. I’ve definitely felt the self-imposed pressure to only write something if it’s new, and unique, and feels like it’s never been said before. This is a mental trap that does nothing but hold you back.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这个我深有同感，一开始其实整体内容围绕着一些常见的学习知识点、读书内容，慢慢就发现，如果说我不能输出独特的观点，这值得我写一篇文章/博客吗？进而转到如果我的博客没人看，我还要花时间在上面吗？甚至之前还觉得我应该写英文文章，这样部署在Github Pages才有更多的读者。说回来，Simon Willison认为blog的价值在于保持长期的写作习惯，同时随着时间的推移有所收获， 同时Simon Willison给出了写blog的几个内容(\u003ca href=\"https://simonwillison.net/2024/Dec/22/link-blog/\"\u003evia\u003c/a\u003e)：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTIL(Things I Learned)；\u003c/li\u003e\n\u003cli\u003eDMP(Descriptions of My Projects)；\u003c/li\u003e\n\u003cli\u003eTIF(Things I\u0026rsquo;ve Found)。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e基于3就衍生出了本文的主题，“links”, 也就是说通过blog的形式分享记录自己阅读的内容。作为一个Link Blog, 可以包含以下内容：\u003c/p\u003e","title":"Restart As a Link Blog"},{"content":"近期计划开这个系列的坑，内容大多都是“Purely Functional Data Structures”内容加一点自己的理解（改一张牌就是我的了:），算是打磨文笔？\n数据结构是什么 当我们在讨论数据结构的时候，我们在讨论什么。常见的介绍有“数据结构是一种数据组织、管理和存储的格式，它可以帮助我们实现对数据高效的访问和修改，更准确地说， 数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作”。然而到更具体的场景，数据结构的概念还能够细化，比如我们经常会 讨论函数栈怎么怎么样，这里的“函数栈”也是数据结构，但它是一个泛指，是一个在程序执行过程中存在的概念，或者叫标识。Okasaki在他的“Purely Functional Data Structures”里指出，数据结构这一概念通常有四种含义：\n抽象，即抽象数据类型(abstract data type，可以用Java中的interface理解)，即表示数据的类型和一组适用于该类型的函数； 实现，即对应于ADT的一个具体实现，通常是指对于该ADT做的具体设计； 实例，即在程序运行中对应于一个数据类型的具体实例； 泛指，即在程序运行中一个泛指的概念，不涉及具体的实例，例如上文提到的函数栈。 本系列将使用Haskell作为描述语言，则其中class可对应抽象的概念，data可对应实现的概念。具体到Java，可以用interface对应抽象的概念，用class对应实现 的概念。 函数式强调的是什么 抛开函数式编程本身强调的函数以外（不然就没法讲了），函数式编程通常还强调不可变（immutable）。因此，当我们说一个数据结构符合函数式的特性的时候主要在讨论不可变， 或者说持久性（persistence）。换句话说，在更新一个函数式的数据结构之后，它更新前的版本我们仍然能够访问到。这意味着所有有着破坏式更新的数据结构都不符合这一性质， 同时也表明相较于能够进行破坏式更新的数据结构，函数式数据结构的性能可能会更差，通常会有一个对数阶的更新代价在里面。实现持久性的方式非常简单，只需要将原有的数据结构 复制一遍，然后在复制后的数据结构上更新，由于没有破坏式的更，可以通过共享不变的部分来减少开销。下面讨论在函数式编程中经典的list。\nList list在任何编程语言中都是非常常见的存在，函数式编程对其讨论则更多，著名的Lisp就取自“LISt Processor”。我们首先来看广泛的list定义\n1 2 3 4 5 6 7 class List t where empty :: t a isEmpty :: t a -\u0026gt; Bool cons :: a -\u0026gt; t a -\u0026gt; t a -- error if the list is empty. head :: t a -\u0026gt; a tail :: t a -\u0026gt; t a 这里可以考虑将head和tail的结果包装一个Maybe，使之适合空的list，在这种情况下isEmpty就不再需要，因为head ls = Nothing或 tail ls = Nothing已经暗含isEmpty ls = true。本文为了偷懒就没用这种定义）。有了这些，我们就可以实现list上的各种“更高级的” 操作，例如经典的map：\n1 2 3 4 map :: List t =\u0026gt; (a -\u0026gt; b) -\u0026gt; t a -\u0026gt; t b map f ls = if isEmpty ls then emptll else cons (f $ head ls) (map f $ tail ls) 从这个定义上可以直接看出，这个List是不支持随机访问的。因此，我们额外定义支持“按下标”随机访问的class：\n1 2 3 class RandomAcess t where lookup :: Int -\u0026gt; t a -\u0026gt; a update :: Int -\u0026gt; a -\u0026gt; t a -\u0026gt; t a 将List和RandomAcess组合就得到了我们需要的RandomAcessList。虽然我们也可以直接用List的几个定义来实现lookup和update：\n1 2 3 4 5 6 7 8 9 lookup :: List t =\u0026gt; Int -\u0026gt; t a -\u0026gt; a lookup n ls = if isEmpty ls || n \u0026lt; 0 then error \u0026#34;Index out of range\u0026#34; else if n = 0 then head ls else lookup (n - 1) $ tail ls update :: List t =\u0026gt; Int -\u0026gt; a -\u0026gt; t a -\u0026gt; t a update n v ls = if isEmpty ls || n \u0026lt; 0 then error \u0026#34;Index out of range\u0026#34; else if n = 0 then cons v $ tail ls else cons (head ls) (update (n - 1) v $ tail ls) 然而这样两者的效率都是$O(n)$的。即使无法在函数式的数据结构中讨论$O(1)$的随机访问，我们仍然希望能支持更高效的随机访问。而这其实可以从实现上着手，因此这里 将RandomAcess独立出来。\n从List上的定义我们可以一窥所谓的持久性和共享不变的结构，主要考察几个返回类型为t a的函数：\nempty返回一个空的list，对于一个确定的类型a来说，empty是不变的； cons在一个已有的list上构建新的list，例如ls1 = cons e ls，此时ls1与ls共享ls的全部； tail从一个list中获取除首部元素以外的部分，显然这也是共享的。 我们再来看一下list的经典实现，也就是单向链表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 data LinkedList a = Nil | Cons a (LinkedList a) deriving(Eq, Show) emptyError :: a emptyError = error \u0026#34;Empty LinkedList\u0026#34; instance List LinkedList where empty = Nil isEmpty Nil = True isEmpty _ = False cons = Cons head Nil = emptyError head (Cons e _) = e tail Nil = emptyError tail (Cons _ ls) = ls 这个实现本身没有啥可以讨论的内容，因为和上面的定义几乎一致，好像只做了个翻译工作。\n","permalink":"https://www.sdlinks.net/posts/2021/fp-data-structure/","summary":"\u003cp\u003e近期计划开这个系列的坑，内容大多都是“Purely Functional Data Structures”内容加一点自己的理解（改一张牌就是我的了:），算是打磨文笔？\u003c/p\u003e\n\u003ch2 id=\"数据结构是什么\"\u003e数据结构是什么\u003c/h2\u003e\n\u003cp\u003e当我们在讨论数据结构的时候，我们在讨论什么。常见的介绍有“数据结构是一种数据组织、管理和存储的格式，它可以帮助我们实现对数据高效的访问和修改，更准确地说，\n数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作”。然而到更具体的场景，数据结构的概念还能够细化，比如我们经常会\n讨论函数栈怎么怎么样，这里的“函数栈”也是数据结构，但它是一个泛指，是一个在程序执行过程中存在的概念，或者叫标识。Okasaki在他的“Purely Functional\nData Structures”里指出，数据结构这一概念通常有四种含义：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e抽象，即抽象数据类型(\u003cem\u003eabstract data type\u003c/em\u003e，可以用Java中的interface理解)，即表示数据的类型和一组适用于该类型的函数；\u003c/li\u003e\n\u003cli\u003e实现，即对应于ADT的一个具体实现，通常是指对于该ADT做的具体设计；\u003c/li\u003e\n\u003cli\u003e实例，即在程序运行中对应于一个数据类型的具体实例；\u003c/li\u003e\n\u003cli\u003e泛指，即在程序运行中一个泛指的概念，不涉及具体的实例，例如上文提到的函数栈。\n本系列将使用Haskell作为描述语言，则其中\u003ccode\u003eclass\u003c/code\u003e可对应抽象的概念，\u003ccode\u003edata\u003c/code\u003e可对应实现的概念。具体到Java，可以用\u003ccode\u003einterface\u003c/code\u003e对应抽象的概念，用\u003ccode\u003eclass\u003c/code\u003e对应实现\n的概念。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"函数式强调的是什么\"\u003e函数式强调的是什么\u003c/h2\u003e\n\u003cp\u003e抛开函数式编程本身强调的函数以外（不然就没法讲了），函数式编程通常还强调不可变（\u003cem\u003eimmutable\u003c/em\u003e）。因此，当我们说一个数据结构符合函数式的特性的时候主要在讨论不可变，\n或者说持久性（\u003cem\u003epersistence\u003c/em\u003e）。换句话说，在更新一个函数式的数据结构之后，它更新前的版本我们仍然能够访问到。这意味着所有有着破坏式更新的数据结构都不符合这一性质，\n同时也表明相较于能够进行破坏式更新的数据结构，函数式数据结构的性能可能会更差，通常会有一个对数阶的更新代价在里面。实现持久性的方式非常简单，只需要将原有的数据结构\n复制一遍，然后在复制后的数据结构上更新，由于没有破坏式的更，可以通过共享不变的部分来减少开销。下面讨论在函数式编程中经典的list。\u003c/p\u003e\n\u003ch3 id=\"list\"\u003eList\u003c/h3\u003e\n\u003cp\u003elist在任何编程语言中都是非常常见的存在，函数式编程对其讨论则更多，著名的Lisp就取自“LISt Processor”。我们首先来看广泛的list定义\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003eclass\u003c/span\u003e \u003cspan class=\"kt\"\u003eList\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"kr\"\u003ewhere\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003eempty\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003eisEmpty\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"kt\"\u003eBool\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003econs\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"c1\"\u003e-- error if the list is empty.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ehead\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003etail\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这里可以考虑将head和tail的结果包装一个\u003ccode\u003eMaybe\u003c/code\u003e，使之适合空的list，在这种情况下\u003ccode\u003eisEmpty\u003c/code\u003e就不再需要，因为\u003ccode\u003ehead ls = Nothing\u003c/code\u003e或\n\u003ccode\u003etail ls = Nothing\u003c/code\u003e已经暗含\u003ccode\u003eisEmpty ls = true\u003c/code\u003e。本文为了偷懒就没用这种定义）。有了这些，我们就可以实现list上的各种“更高级的”\n操作，例如经典的\u003ccode\u003emap\u003c/code\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emap\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eList\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emap\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"n\"\u003els\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"kr\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003eisEmpty\u003c/span\u003e \u003cspan class=\"n\"\u003els\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"kr\"\u003ethen\u003c/span\u003e \u003cspan class=\"n\"\u003eemptll\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"kr\"\u003eelse\u003c/span\u003e \u003cspan class=\"n\"\u003econs\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"o\"\u003e$\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e \u003cspan class=\"n\"\u003els\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"o\"\u003e$\u003c/span\u003e \u003cspan class=\"n\"\u003etail\u003c/span\u003e \u003cspan class=\"n\"\u003els\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e从这个定义上可以直接看出，这个List是不支持随机访问的。因此，我们额外定义支持“按下标”随机访问的\u003ccode\u003eclass\u003c/code\u003e：\u003c/p\u003e","title":"函数式数据结构漫谈（一）"},{"content":"Memoization是动态规划(Dynamic Programming)中自顶向下处理问题采用的策略, 其基本想法是通过将子问题的解保存起来避免重复计算来优化算法. 这个概念本身很简单, 在其他有明显mutable语义的语言中, 实现起来也非常简单. 但是在Haskell中问题就变的复杂了不少, 对于一个原始的函数f :: a -\u0026gt; b你如果要用ref, 比如说IORef, 你必须要把它放到IO monad中, 你的memoize函数就变成了... -\u0026gt; IO (a -\u0026gt; b). 我们希望是能够找到一个memoize :: ... -\u0026gt; (a -\u0026gt; b), 这样memoize之后得到的和原函数类型是一致的. 为了讨论的方便, 我们主要关注两个例子的memoization, 一个是经典的Fibonacci数列:\n1 2 3 4 fib :: Int -\u0026gt; Integer fib 0 = 0 fib 1 = 1 fib n = fib (n - 2) + fib (n - 1) 另一个则是动态规划(自底向上)中典型的最小编辑距离的问题, 所谓的最小编辑距离就是一个字符串通过增加, 删除, 替换的操作得到另一个字符串所需要的操作次数:\n1 2 3 4 5 6 minEditDist :: String -\u0026gt; String -\u0026gt; Int minEditDist [] [] = 0 minEditDist s [] = length s minEditDist [] s = length s minEditDist (x:xs) (y:ys) | x == y = minEditDist xs ys | otherwise = 1 + minimum [minEditDist xs ys, minEditDist xs (y:ys), minEditDist (x:xs) ys] Memoizing with specific problem 首先来看fib的问题, wiki给出了一个非常elegant的解(就fib本身而言, 还有更经典的解, fib = (fibs !!) where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)):\n1 2 3 4 5 6 7 8 9 10 11 12 import Data.Function (fix) memoize :: (Int -\u0026gt; a) -\u0026gt; (Int -\u0026gt; a) memoize f = (map f [0..] !!) fib :: (Int -\u0026gt; Integer) -\u0026gt; Int -\u0026gt; Integer fib f 0 = 1 fib f 1 = 1 fib f n = f (n - 1) + f (n - 2) fibMemo :: Int -\u0026gt; Integer fibMemo = fix (memoize . fib) 虽然这个memoize和我们想要的(a -\u0026gt; b) -\u0026gt; a -\u0026gt; b有点差距, 但仍然值得分析一下. 首先来看fix, fix的定义很简单:\n1 2 fix :: (a -\u0026gt; a) -\u0026gt; a fix f = let x = f x in x 关于fix的详细解释这里略去, 简单而言, 可以将fix理解为一个构建递归的函数. 例如, fix (1:)按定义展开后就是1:(1:(1:(...))), 很容易看到是一个元素为1的无限列表. 这里的fibMemo = fix (memoize . fib)同样我们按定义展开:\n1 2 3 4 5 6 7 8 9 10 11 12 13 fibMemo = fix (memoize . fib) -- fix定义 = let x = (memoize . fib) x in x = (memoize . fib) fibMemo = memoize (fib fibMemo) -- memoize定义 = (map (fib fibMemo) [0..] !!) -- 等价于 fibMemo = (map fib [0..] !!) where fib 0 = 0 fib 1 = 1 fib n = fibMemo (n - 2) + fibMemo (n - 1) 这种memoization实现利用了Haskell的laziness, fibMemo变成了从一个无限的列表里面取值, 我们已经构建好了每一个元素的表达式, 在需要的时候计算, 这样那些已经计算过的元素就保存在列表里面. 更详细的讲, 我们在定义完fibMemo时其结构为:\n1 2 3 fibMemo = ([0, 1, fibMemo 0 + fibMemo 1, fibMemo 1 + fibMemo 2..] !!) 在调用fibMemo 3之后其结构变为:\n1 fibMemo = ([0, 1, 1, 2, fib 2 + fib 3..] !!) 可以看到fibMemo 2的结果已经被保存了, 这就实现了memoization.\n我们再来看最小编辑距离的问题, 我们显然没法把fib中的memoize直接拿过来. 因为在这个问题上, 我们希望保存的是任意两个子串的最小编辑距离, 从之前fib的memoization借鉴, 开始我们的第一次尝试:\n1 2 3 4 5 6 7 8 9 10 minEditDistMemo :: String -\u0026gt; String -\u0026gt; Int minEditDistMemo s1 s2 = lookupS s1 s2 where lookupS x1 x2 = maybe undefined id $ lookup (x1, x2) ds ds = map g [(x1, x2) | x1 \u0026lt;- tails s1, x2 \u0026lt;- tails s2] g (s1, s2) = ((s1, s2), f s1 s2) f [] [] = 0 f s [] = length s f [] s = length s f (x:xs) (y:ys) | x == y = minEditDistMemo xs ys | otherwise = 1 + minimum [minEditDistMemo xs ys, minEditDistMemo xs (y:ys), minEditDistMemo (x:xs) ys] 可以看到, 每次递归调用minEditDistMemo, 它都会构建一个新的ds, 而这是有问题的. 当然这也很容易解决, 只要把每次递归调用minEditDistMemo的地方换成lookupS就行:\n1 2 3 4 5 6 7 8 9 10 minEditDistMemo :: String -\u0026gt; String -\u0026gt; Int minEditDistMemo s1 s2 = lookupS s1 s2 where lookupS x1 x2 = maybe undefined id $ lookup (x1, x2) ds ds = map g [(x1, x2) | x1 \u0026lt;- tails s1, x2 \u0026lt;- tails s2] g (s1, s2) = ((s1, s2), f s1 s2) f [] [] = 0 f s [] = length s f [] s = length s f (x:xs) (y:ys) | x == y = lookupS xs ys | otherwise =1 + minimum [lookupS xs ys, lookupS xs (y:ys), lookupS (x:xs) ys] generic memoization 通过上面的分析, 可以看到, 我们总是可以根据特定的问题构建特定的数据结构来实现memoization. 也就是说, 对于任意的一个函数f :: a -\u0026gt; b(如果f有多个参数, 可以先uncurry), 我们希望能够用一个数据结构来保存计算结果, 也就是(a, b), 显然, Map就是最理想的数据结构. 问题是Haskell的Map是immutable, 我们没法像imperative programming那样方便的修改, 这个时候就需要用到State, State能够帮助我们解决共享状态的问题(以下实现来源于Memoizing function in Haskell):\n1 2 3 4 5 6 7 8 9 10 11 12 13 import qualified Data.Map as M import Control.Monad.State type MemoState a b = State (M.Map a b) b memorize :: Ord a =\u0026gt; ((a -\u0026gt; MemoState a b) -\u0026gt; (a -\u0026gt; MemoState a b)) -\u0026gt; a -\u0026gt; b memorize t x = evalState (f x) M.empty where f x = get \u0026gt;\u0026gt;= \\m -\u0026gt; maybe (g x) return (M.lookup x m) g x = do y \u0026lt;- t f x m \u0026lt;- get put $ M.insert x y m return y 这里t就是我们要memoized的函数, x是t的参数. memorize从一个empty的Map开始运行f x :: MemoState a b并返回它的值. 而f首先用get拿到了当前的状态(也就是Map), 随后检查是否计算过参数为x的结果, 如果是则返回包含结果的MemoState a b, 否则返回g x :: MemoState a b. g的话, 它首先计算参数为x的值, 注意到这个t的类型是(a -\u0026gt; MemoState a b) -\u0026gt; (a -\u0026gt; MemoState a b), 这和我们之前讨论利用fix的函数类似, 都不递归调用自身, 而是调用额外的函数. 随后, 用get拿到了当前的状态(Map), 再用put更新状态(Map), 最后返回了一个包含结果和新状态的MemoState a b.\n注意到这个t的类型, 意味着我们要改写原函数, 我们原先的minEditDist需要改为:\n1 2 3 4 5 6 7 -- minEditDistM :: ((String, String) -\u0026gt; MemoState (String, String) Int) -\u0026gt; (String, String) -\u0026gt; MemoState (String, String) Int minEditDistM :: Monad m =\u0026gt; ((String, String) -\u0026gt; m Int) -\u0026gt; (String, String) -\u0026gt; m Int minEditDistM f ([], []) = return 0 minEditDistM f (s, []) = return $ length s minEditDistM f ([], s) = return $ length s minEditDistM f ((x:xs), (y:ys)) | x == y = f (xs, ys) | otherwise = (+1) . minimum \u0026lt;$\u0026gt; (sequenceA $ f \u0026lt;$\u0026gt; [(xs, ys), (xs, (y:ys)), ((x:xs), ys)]) 所幸的是, 我们可以把minEditDistM, 也就是t的类型定义的更generic. 这样一来, 我们的minEditDist就可以实现为:\n1 2 3 -- memoized version minEditDist :: String -\u0026gt; String -\u0026gt; Int minEditDist s1 s2 = memorize minEditDistM (s1, s2) 至此, 我们就得到了泛用的memorize, 我们要做的仅仅是改写原先的函数, 即:\n1 2 3 4 5 6 7 8 origin :: a1 -\u0026gt; a2 ... -\u0026gt; b -- 1. uncurry所有参数, (a1, a2, ...) -\u0026gt; b -- 2. 添加额外的f, 替换调用自身的情况, ((a1, a2, ...) -\u0026gt; b) -\u0026gt; (a1, a2, ...) -\u0026gt; b -- 3. 修改返回值为monad modified :: Monad m =\u0026gt; ((a1, a2, ...) -\u0026gt; m b) -\u0026gt; (a1, a2, ...) -\u0026gt; m b -- memoized version originMemo a1 a2 ... = memorize modified (a1, a2, ...) 总结 本文讨论了Haskell中两种memoization的手段, 一种根据具体问题具体的分析, 构建需要的数据结构来保存子问题的结果; 另外一种则利用一个泛用的memoize函数, 按特定的模式修改原函数即可实现memoization. 总体而言, 两种方式各有优劣, 第一种方法需要更精致能够得到更适合问题的解, 第二种方法则提供了泛用性. 如果你有任何问题, 欢迎邮件我\n参考 Memoization Dynamic programming Memoizing function in Haskell Lazy Dynamic Programming Haskell/Understanding monads/State ","permalink":"https://www.sdlinks.net/posts/2020/memoization-in-haskell/","summary":"\u003cp\u003eMemoization是动态规划(\u003cem\u003eDynamic Programming\u003c/em\u003e)中自顶向下处理问题采用的策略, 其基本想法是通过将子问题的解保存起来避免重复计算来优化算法. 这个概念本身很简单, 在其他有明显mutable语义的语言中, 实现起来也非常简单. 但是在Haskell中问题就变的复杂了不少, 对于一个原始的函数\u003ccode\u003ef :: a -\u0026gt; b\u003c/code\u003e你如果要用ref, 比如说IORef, 你必须要把它放到IO monad中, 你的memoize函数就变成了\u003ccode\u003e... -\u0026gt; IO (a -\u0026gt; b)\u003c/code\u003e. 我们希望是能够找到一个\u003ccode\u003ememoize :: ... -\u0026gt; (a -\u0026gt; b)\u003c/code\u003e, 这样memoize之后得到的和原函数类型是一致的. 为了讨论的方便, 我们主要关注两个例子的memoization, 一个是经典的Fibonacci数列:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efib\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"kt\"\u003eInteger\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efib\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efib\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efib\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efib\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003efib\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e另一个则是动态规划(自底向上)中典型的最小编辑距离的问题, 所谓的最小编辑距离就是一个字符串通过增加, 删除, 替换的操作得到另一个字符串所需要的操作次数:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003eminEditDist\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003eminEditDist\u003c/span\u003e \u003cspan class=\"kt\"\u003e[]\u003c/span\u003e     \u003cspan class=\"kt\"\u003e[]\u003c/span\u003e     \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003eminEditDist\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e      \u003cspan class=\"kt\"\u003e[]\u003c/span\u003e     \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003elength\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003eminEditDist\u003c/span\u003e \u003cspan class=\"kt\"\u003e[]\u003c/span\u003e     \u003cspan class=\"n\"\u003es\u003c/span\u003e      \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003elength\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003eminEditDist\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"kt\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003exs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"kt\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003eys\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e    \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eminEditDist\u003c/span\u003e \u003cspan class=\"n\"\u003exs\u003c/span\u003e \u003cspan class=\"n\"\u003eys\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                           \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"n\"\u003eotherwise\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eminimum\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eminEditDist\u003c/span\u003e \u003cspan class=\"n\"\u003exs\u003c/span\u003e \u003cspan class=\"n\"\u003eys\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eminEditDist\u003c/span\u003e \u003cspan class=\"n\"\u003exs\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"kt\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003eys\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003eminEditDist\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"kt\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003exs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eys\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"memoizing-with-specific-problem\"\u003eMemoizing with specific problem\u003c/h3\u003e\n\u003cp\u003e首先来看\u003ccode\u003efib\u003c/code\u003e的问题, \u003ca href=\"https://wiki.haskell.org/Memoization\"\u003ewiki\u003c/a\u003e给出了一个非常elegant的解(就\u003ccode\u003efib\u003c/code\u003e本身而言, 还有更经典的解, \u003ccode\u003efib = (fibs !!) where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)\u003c/code\u003e):\u003c/p\u003e","title":"Memoization in Haskell"},{"content":"Pearl 2: 给定一个长度大于1的列表, 计算其元素的最大surpasser count, 要求算法复杂度 $O(n log n)$. Type: msc: Ord a =\u0026gt; [a] -\u0026gt; Int\n\u0026ldquo;Pearls of functional algorithm design\u0026quot;的第二章, 我们先来看surpasser的定义\nDefinition surpasser: 称列表中$X[j]$是$X[i]$的surpasser, 如果$X[i] \u0026lt; X[j]$且$i \u0026lt; j$.\n因此一个元素的surpasser count就是其surpasser的数目.\n同样, 一个naive的实现很容易:\n1 2 3 4 msc :: Ord a =\u0026gt; [a] -\u0026gt; Int msc xs = maximum [scount z zs | z:zs \u0026lt;- tails xs] scount :: Ord a =\u0026gt; a -\u0026gt; [a] -\u0026gt; Int scount x xs = length $ filter (\u0026gt; x) xs 同时也很容易看到, 这个实现的时间复杂度是 $O(n^2)$, 不符合要求的 $O(n log n)$. 为了达到 $O(n log n)$ 的时间复杂度, 我们希望有个函数f能够递归的处理xs = us ++ vs, 并且存在一个线性复杂度的函数join, 使得f xs = join (f us) (f vs), 这样整体的复杂度满足 $T(n)=2 T(n/2)+O(n)=O(n log n)$. 原文中, 作者利用分治的思想通过一步步地推导获得了线性时间的join, 这里也仅仅是类似于复读的\u0026quot;再解释\u0026rdquo;.\n这里我们从所有surpasser count的表开始, 即table xs = [(z, scount z zs) | z:zs \u0026lt;- tails xs], 这样的话msc = maximum . map snd . table. 如果我们能够找到一个线性复杂度的join, 使得table (xs ++ ys) = join (table xs) (table ys), 那么就能够得到满足时间复杂度条件的算法. 首先, 给出一个非常直接的性质\nTheorem: tails (xs ++ ys) == map (++ ys) (tails xs) ++ tails ys\n利用上述性质, 我们可以进行简单的推导:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 table (xs ++ ys) =\u0026gt; [(z, scount z zs) | z:zs \u0026lt;- tails (xs ++ ys)] =\u0026gt; [(z, scount z zs) | z:zs \u0026lt;- map (++ ys) (tails xs) ++ tails ys] -- ++的分配律 =\u0026gt; [(z, scount z $ zs ++ ys) | z:zs \u0026lt;- tails xs] ++ [(z, scount z zs) | z:zs \u0026lt;- tails ys] -- scount z $ zs ++ ys == scount z zs + scount z ys =\u0026gt; [(z, scount z zs + scount z ys) | z:zs \u0026lt;- tails xs] ++ [(z, scount z zs) | z:zs \u0026lt;- tails ys] =\u0026gt; [(z, c + scount z ys) | (z, c) \u0026lt;- table xs] ++ table ys -- ys == map fst $ table ys =\u0026gt; [(z, c + scount z (map fst $ table ys)) | (z, c) \u0026lt;- table xs] ++ table ys =\u0026gt; join txs tys = [(z, c + tcount z tys) | (z, c) \u0026lt;- txs] ++ tys tcount z tys = scount z $ map fst tys 这个也很容易理解, 我们合并txs = table xs和tys = table ys时, 最简单的就是对于txs的每一个(z, c), 额外增加一个z在ys中的count, 然而我们知道这并不是一个线性复杂度的join, 而是一个$O(n^2)$的算法. 从上面可以看到, 作者多此一举的引入了一个tcount, 这表明了可以优化tcount, 如果tys是一个排序好的列表, 那么\n1 2 3 4 5 6 7 8 tcount z tys =\u0026gt; length $ filter (\u0026gt; z) (map fst tys) -- filter p . map f == map f . filter (p . f) =\u0026gt; length (map fst $ filter ((\u0026gt; z) . fst) tys) -- length . map f == length =\u0026gt; length $ filter ((\u0026gt; z) . fst) tys -- tys是一个递增的列表 =\u0026gt; length $ dropWhile ((\u0026lt;= z) . fst) tys 上面的推导表明, 如果我们在构建table的时候使其保持有序, 那么可以获得更好的性能. 对于排序好的俩个列表, 我们可以用一个线性复杂度的merge合并两个有序列表, 这样join txs tys = [(z, c + tcount z tys) | (z, c) \u0026lt;- txs] `merge` tys. 这启发我们可以设计一个排序的join. 首先最基本的条件很容易得到join [] tys = tys, join txs [] = txs, 对于递归的部分, 即join txs @ ((x, c): txs') tys @ ((y, d):tys'):\n1 2 3 4 5 6 7 8 join txs @ ((x, c): txs\u0026#39;) tys @ ((y, d):tys\u0026#39;) =\u0026gt; ((x, c + tcount x tys):[(x, c + tcount x tys) | (x, c) \u0026lt;- txs]) `merge` tys -- if x \u0026lt; y then tcount x tys == length tys 1=\u0026gt; (x, c + length tys):join txs\u0026#39; tys -- if x == y then tcount x tys == tcount x tys\u0026#39; == d 2=\u0026gt; (y, d):join txs tys\u0026#39; -- if x \u0026lt; y then same as x == y 3=\u0026gt; (y, d):join txs tys\u0026#39; 至此, 我们就可以得到优化后的join:\nFinal Solution:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 msc :: Ord a =\u0026gt; [a] -\u0026gt; Int msc = maximum . map snd . table table :: Ord a =\u0026gt; [a] -\u0026gt; [(a, Int)] table [x] = [(x, 0)] table xs = join (m - n) (table ys) (table zs) where m = length xs n = m `div` 2 (ys, zs) = splitAt n xs join :: Ord a =\u0026gt; Int -\u0026gt; [(a, Int)] -\u0026gt; [(a, Int)] -\u0026gt; [(a, Int)] join _ [] tys = tys join _ txs [] = txs join n txs@((x, c):txs\u0026#39;) tys@((y, d):tys\u0026#39;) | x \u0026lt; y = (x, c + n) : join n txs\u0026#39; tys | otherwise = (y, d) : join (n - 1) txs tys\u0026#39; 注意到, 我们这里没法使用降序的join来进一步优化, 因为tcount x tys == length tys依赖于x \u0026lt; y.\n后记 这个pearl看下来, 让我更清晰的感受到了一个优化的解的实现过程. 我拿到这个$O(n log n)$的复杂度要求, 虽然能够想到要通过切分, 递归的merge. 但我的思考过程并不算很连贯, 有可能想出类似的解, 但估计耗费的时间会很长. 还是一样, 最关键是要从基础的解开始一步步优化. 值得一提的是, 这个问题的array版本存在一个使用二分查找的解, 不过由于使用的符号太奇怪了, 我就没有仔细查看.\n","permalink":"https://www.sdlinks.net/posts/2020/surpasser-count/","summary":"\u003cp\u003e\u003cstrong\u003ePearl 2\u003c/strong\u003e: 给定一个长度大于1的列表, 计算其元素的最大surpasser count, 要求算法复杂度 $O(n log n)$.\n\u003cstrong\u003eType\u003c/strong\u003e: \u003ccode\u003emsc: Ord a =\u0026gt; [a] -\u0026gt; Int\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;Pearls of functional algorithm design\u0026quot;的第二章, 我们先来看surpasser的定义\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDefinition surpasser\u003c/strong\u003e: 称列表中$X[j]$是$X[i]$的surpasser, 如果$X[i] \u0026lt; X[j]$且$i \u0026lt; j$.\u003c/p\u003e\n\u003cp\u003e因此一个元素的surpasser count就是其surpasser的数目.\u003c/p\u003e\n\u003cp\u003e同样, 一个naive的实现很容易:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emsc\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eOrd\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emsc\u003c/span\u003e \u003cspan class=\"n\"\u003exs\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emaximum\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003escount\u003c/span\u003e \u003cspan class=\"n\"\u003ez\u003c/span\u003e \u003cspan class=\"n\"\u003ezs\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"n\"\u003ez\u003c/span\u003e\u003cspan class=\"kt\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003ezs\u003c/span\u003e \u003cspan class=\"ow\"\u003e\u0026lt;-\u003c/span\u003e \u003cspan class=\"n\"\u003etails\u003c/span\u003e \u003cspan class=\"n\"\u003exs\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003escount\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eOrd\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003escount\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"n\"\u003exs\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003elength\u003c/span\u003e \u003cspan class=\"o\"\u003e$\u003c/span\u003e \u003cspan class=\"n\"\u003efilter\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003exs\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e同时也很容易看到, 这个实现的时间复杂度是 $O(n^2)$, 不符合要求的 $O(n log n)$. 为了达到 $O(n log n)$ 的时间复杂度, 我们希望有个函数\u003ccode\u003ef\u003c/code\u003e能够递归的处理\u003ccode\u003exs = us ++ vs\u003c/code\u003e, 并且存在一个线性复杂度的函数\u003ccode\u003ejoin\u003c/code\u003e, 使得\u003ccode\u003ef xs = join (f us) (f vs)\u003c/code\u003e, 这样整体的复杂度满足 $T(n)=2 T(n/2)+O(n)=O(n log n)$. 原文中, 作者利用分治的思想通过一步步地推导获得了线性时间的\u003ccode\u003ejoin\u003c/code\u003e, 这里也仅仅是类似于复读的\u0026quot;再解释\u0026rdquo;.\u003c/p\u003e","title":"Surpasser Count"},{"content":"Pearl 1: 给定一个自然数的有限集X, 计算不属于X的最小自然数. X表示为不包含重复元素的无序列表. 时间复杂度要求$O(n)$.\nType: minfree :: [Int] -\u0026gt; Int(也可以额外的定义自然数类型, 不过这不是我们的重点)\n\u0026ldquo;Pearls of Functional Algorithm Design\u0026quot;的第一章, 其描述了一个分治的算法和一个基于array的算法, 这里按个人的思路讲解一下基于分治的算法, 基于array的算法具体可以查阅原文. 首先拿到这个问题, 我觉得最直接的想法就是\nBase Solution: minfree xs = head $ [0..] \\\\ xs 然而这和要求的线性时间复杂度不符. 第二个想法就是设计一个fold的函数遍历一遍列表, 这样时间复杂度符合要求. 但是越来越多的边界条件让我意识到思路不对. 看了原文才发现忽略了解题的一个重要条件.\nFact: [0..n]中的所有自然数不可能都在X(xs)中, 其中n = length xs.\n这也很容易证明, 因为$ n + 1 = length\\ [0..n] \u0026gt; n $, 因此不属于集合X的最小自然数就是[0..n]中不属于X的最小自然数. 至此,该问题很容易解决, 只需要一个marked的array来表示[0,,n]中的自然数是否在X中即可. 下面描述基于分治的算法, 首先给出一个基本的结论.\nTheorem: (as ++ bs) \\\\ (us ++ vs) == (as \\\\ us) ++ (bs \\\\ vs), 如果as \\\\ vs == as \u0026amp;\u0026amp; bs \\\\ us == bs.\n这显然是符合集合论的. 显然, [0..n]可以拆分为两个不想交的集合[0..b-1]以及[b..n], 因此[0..b]可以拆分为\n1 2 ([0..b-1] \\\\ us) ++ ([b..] \\\\ vs) where (us, vs) = partition (\u0026lt; b) xs 而minfree则可以改写为\n1 2 3 4 5 minfree xs = if null $ [0..b-1] \\\\ us then head $ [b..] \\\\ vs else head $ [0..b-1] \\\\ us where (us, vs) = partition (\u0026lt; b) xs b = 很容易发现null $ [0..b-1] \\\\ us等价于length us == b, 后者更加高效. 同时, 我们也可以进一步的抽象minfree, 因为我们在上面限制了从0开始:\n1 2 minfrom :: Int -\u0026gt; [Int] -\u0026gt; Int minfrom a xs = head $ [a..] \\\\ xs 至此, 我们的minfree可以改为:\n1 2 3 4 5 6 7 8 minfree = minfrom 0 minfrom :: Int -\u0026gt; [Int] -\u0026gt; Int minfrom a xs | null xs = a | length us == b - a = minfrom b vs | otherwise = minfrom a us where (us, vs) = partition (\u0026lt; b) xs b = 接下来的问题是b应该是多少, 显然b可以是$(a, n=length\\ xs)$中的任意一个自然数, 不过b的选择应该使得us和vs的长度尽可能的小, 否则的会导致算法在最坏情况下开销的增加. 因此比较理想的取值是b = a + 1 + n `div` 2, 这样如果length us \u0026lt; b - a的, 那么length us \u0026lt; b - a \u0026lt; n `div` 2 + 1 \u0026lt;= n `div` 2, 而如果length us == b - a, 那么length vs = n - b + a = n - n `div` 2 - 1 \u0026lt;= n `div` 2. 此时可以看到算法的复杂度是$O(n)$的. 在minfree的最终版本, 为了避免重复计算, 我们可以传入(length xs, xs).\nFinal Solution:\n1 2 3 4 5 6 7 8 9 10 minfree :: [Int] -\u0026gt; Int minfree xs = minfrom 0 (length xs, xs) minfrom :: Int -\u0026gt; (Int, [Int]) -\u0026gt; Int minfrom a (n, xs) | n == 0 = a | m == b - a = minfrom b (n - m, vs) | otherwise = minfrom a (m, us) where (us, vs) = partition (\u0026lt; b) xs b = a + 1 + n `div` 2 m = length us 后记 整个pearl看下来给我最大的感受就是首先给出一个比较naive的解, 然后利用分治的思想一步步的分解问题并优化解. 同时, 虽然函数式的算法总是会比相应的命令式的算法差一个对数阶(因为函数式的算法中无法保证array的更新是常数级的, 通常是一个对数级的), 但是在这个pearl上, 作者通过不断的迭代算法缩小了这个差距.\n","permalink":"https://www.sdlinks.net/posts/2020/the-smallest-free-number/","summary":"\u003cp\u003e\u003cstrong\u003ePearl 1\u003c/strong\u003e: 给定一个自然数的有限集X, 计算不属于X的最小自然数. X表示为不包含重复元素的无序列表. 时间复杂度要求$O(n)$.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eType\u003c/strong\u003e: \u003ccode\u003eminfree :: [Int] -\u0026gt; Int\u003c/code\u003e(也可以额外的定义自然数类型, 不过这不是我们的重点)\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;Pearls of Functional Algorithm Design\u0026quot;的第一章, 其描述了一个分治的算法和一个基于array的算法, 这里按个人的思路讲解一下基于分治的算法, 基于array的算法具体可以查阅原文. 首先拿到这个问题, 我觉得最直接的想法就是\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eBase Solution\u003c/em\u003e: \u003ccode\u003eminfree xs = head $ [0..] \\\\ xs \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e然而这和要求的线性时间复杂度不符. 第二个想法就是设计一个fold的函数遍历一遍列表, 这样时间复杂度符合要求. 但是越来越多的边界条件让我意识到思路不对. 看了原文才发现忽略了解题的一个重要条件.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFact\u003c/strong\u003e: \u003ccode\u003e[0..n]\u003c/code\u003e中的所有自然数不可能都在X(\u003ccode\u003exs\u003c/code\u003e)中, 其中\u003ccode\u003en = length xs\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e这也很容易证明, 因为$ n + 1 = length\\ [0..n] \u0026gt; n $, 因此不属于集合X的最小自然数就是\u003ccode\u003e[0..n]\u003c/code\u003e中不属于X的最小自然数. 至此,该问题很容易解决, 只需要一个marked的array来表示\u003ccode\u003e[0,,n]\u003c/code\u003e中的自然数是否在X中即可. 下面描述基于分治的算法, 首先给出一个基本的结论.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTheorem\u003c/strong\u003e: \u003ccode\u003e(as ++ bs) \\\\ (us ++ vs) == (as \\\\ us) ++ (bs \\\\ vs)\u003c/code\u003e, 如果\u003ccode\u003eas \\\\ vs == as \u0026amp;\u0026amp; bs \\\\ us == bs\u003c/code\u003e.\u003c/p\u003e","title":"The Smallest Free Number"},{"content":"之前在\u0026quot;Essentials of Programming Languages\u0026quot;中学习过CPS(Continuation Passing Style), 而笔记在blog改版后被丢弃, 故在这篇文章中重新详细的探讨下CPS以及尾递归, 就当是温故而知新.\nContinuation 在理解什么是\u0026quot;Continuation Passing Style\u0026quot;之前, 我们首先需要定义Continuation(惭愧的是我都不知道中文叫啥, 查了下好像是\u0026quot;续延\u0026quot;). Continuation是计算机程序控制状态的抽象表示, 换言之, 其就是一种表示程序执行中间某一计算步骤的控制上下文的数据结构, 即表示某一计算的未来. 一个形象的例子是阶乘函数:\n1 2 3 4 let rec fact n = if n = 0 then 1 else n * (fact (n - 1)) 当我们计算(fact 4)时, 其执行过程为(用lisp的形式是因为更加形象):\n1 2 3 4 5 6 7 8 9 10 (fact 4) =\u0026gt; (* 4 (fact 3)) =\u0026gt; (* 4 (* 3 (fact 2))) =\u0026gt; (* 4 (* 3 (* 2 (fact 1)))) =\u0026gt; (* 4 (* 3 (* 2 (* 1 (fact 0))))) =\u0026gt; (* 4 (* 3 (* 2 (* 1 1)))) =\u0026gt; (* 4 (* 3 (* 2 1))) =\u0026gt; (* 4 (* 3 2)) =\u0026gt; (* 4 6) =\u0026gt; 24 这过程中, (* 4 #)就是一个continuation, 是(fact 3)的控制上下文, 等待着(fact 3)的计算结果传入我们的\u0026quot;#\u0026quot;, (* 4 (* 3 #))也是一个continuation. 容易看到的是在这样一个计算过程中, continuation在不断增长, 因为调用栈在不断增长, 程序不得不保存*的左操作数, 计算右操作数. 接下来, 我们来看fact的尾递归版本, 所谓的尾递归(tail recursion)指的是递归函数的递归调用部分只有函数调用, 即:\n1 2 3 4 5 6 let fact n = let rec aux n acc = if n = 0 then acc else aux (n - 1) (acc * n) aux n 1 这里, aux是尾递归的, 其递归调用部分是一个函数调用. 这时候我们再来看(fact 4)的执行过程:\n1 2 3 4 5 6 7 (fact 4) =\u0026gt; (aux 4 1) =\u0026gt; (aux 3 4) =\u0026gt; (aux 2 12) =\u0026gt; (aux 1 24) =\u0026gt; (aux 0 24) =\u0026gt; 24 这过程中, 我们的continuation始终是#, 程序不需要保存额外的信息, 每次只需要调用函数aux就行.因此, 一个直接的结论是尾递归不增长控制上下文, 也就是说如果表达式e1返回的是表达式e2的值, 那么e1和e2应该在同一个continuation中. 因此, 如果一个递归函数是尾递归的, 那么它的调用栈可以不增长, 具体取决于语言是否有尾递归优化.\nContinuation Passing Style(CPS) CPS指得是将continuation作为显示参数传递的风格, 例如, 阶乘函数fact的CPS版本为:\n1 2 3 4 5 let rec factCPS n k = if n = 0 then k 1 else fact (n - 1) (fun x -\u0026gt; k (n * x)) let fact n = factCPS n id 这里我们用单参数函数来表示continuation, 因为函数本身就是接受输入在执行后续的计算, 和continuation表示未来的计算不谋而合, 通常用id来表示一个终止的continuation. 在CPS中, 我们总是把下一步需要的计算作为函数的显示参数传入. 再来看一个fold的例子:\n1 2 3 4 5 6 let rec foldCPS f z = function | [] -\u0026gt; z | x :: xs -\u0026gt; f x z (fun y -\u0026gt; foldCPS f y xs) let foldl f z ls = foldCPS (fun x z g -\u0026gt; g (f z x)) z ls let foldr f z ls = foldCPS (fun x z g -\u0026gt; f x (g z)) z ls 这里foldCPS的f是CPS的, 其第一个参数是列表头部的元素, 第二个参数是累加的值, 第三个参数是一个continuation. 我们还通过foldCPS定义了foldl和foldr, foldl f z [1; 2; 3; 4]的逻辑是(f (f (f (f z 1) 2) 3) 4), 即我们先计算头部元素和累加值的运算结果再将其传入continuation(接下来的计算); 而foldr f z [1; 2; 3; 4]的逻辑是(f 1 (f 2 (f 3 (f 4 z)))), 即我们先将累加值传入continuation(接下来的计算)得到结果后再计算其与头部元素的计算结果. 这和我们正常版本的foldl和foldr的逻辑是一致的:\n1 2 3 4 5 6 7 let rec foldl f z = function | [] -\u0026gt; z | x :: xs -\u0026gt; foldl f (f z x) xs let rec foldr f z = function | [] -\u0026gt; z | x :: xs -\u0026gt; f x (foldr f z xs) CPS的一个重要特征就是所有函数都是尾递归的. 因此, 不难想到, 如果我们所有函数都能够写成CPS的形式, 那么就可以在具有尾递归优化的语言中受益. 下面就描述如何将普通的函数转化为CPS风格的函数:\n增加一个额外的参数表示我们的continuation(通常用k或cont)\n如果函数返回一个常量c, 就将其传入continuation返回, 即改为k c\n如果是一个尾调用, 即返回的是一个函数调用, 就改成在相同的continuation下调用该函数\n如果返回的一个表达式, 函数调用作为操作数, 就改为在一个新的continuation下调用该函数,\n具体而讲就是构造一个新的函数, 其参数是函数调用的结果, 函数体是在旧的continuation下完成计算, 例如上文factCPS中的else fact (n - 1) (fun x -\u0026gt; k (n * x)).\n我们来看一个斐波那契数列的例子:\n1 2 3 4 let rec fib n = if n \u0026lt; 2 then 1 else fib (n - 1) + fib (n - 2) 我们首先添加一个额外的参数k. 随后, 该函数总共有俩处返回, then分支返回的是常量, 则改为k 2; else分支返回了一个表达式, 而且俩个操作数都是函数调用, 我们首先改写左边的操作数, 即fib (n - 1) (fun v1 -\u0026gt; v1 + fib (n - 2)), 随后改写第二个操作数, 并将结果传入continuation中, 即fib (n - 2) (fun v2 -\u0026gt; v1 + v2 |\u0026gt; k), 将这些整合就得到了CPS版本的fib:\n1 2 3 4 5 let rec fibCPS n k = if n \u0026lt; 2 then k 1 else fibCPS (n - 1) \u0026lt;| fun v1 -\u0026gt; fibCPS (n - 2) \u0026lt;| fun v2 -\u0026gt; v1 + v2 |\u0026gt; k let fib n = fibCPS n id 可以看到, fib的CPS版本相较于原始版本显得更加不直观, 而这确实是CPS的缺点, 由于显示的传递控制上下文, 我们的代码变得不够直观.\nCPS与尾递归优化 所谓的尾递归优化(tail call optimization, TCO)指的是对于一个尾递归的函数, 例如我们有函数f, 其尾递归调用了g, 由于不需要额外的信息, 我们可以直接传递f的返回地址. 这样当g返回时, 其可以直接返回到f的调用者. 从上文我们知道, CPS总是尾递归的, 因此CPS可以和TCO同时使用来消除递归函数的调用栈的增长. 因此CPS可以用于那些具有尾递归优化的语言来使避免我们的递归函数栈溢出, 但由于CPS使得代码变得不够直观, 因此其效果可能并不如使用accumulator, 同时CPS也可以作为编译器的IR(intermediate representation), SML/NJ就是一个例子, 具体可以参考Andrew的\u0026quot;Compiling with Continuations\u0026quot;.\n.NET中的tail call .NET的CIL中存在着tail.的opcode, 不过C#的编译器本身不会做TCO, 而F#的编译器则会处理TCO, 对于简单的尾递归, 例如递归调用自身, F#编译器通常将其优化为循环, 对于其他的情况才会使用tail., 具体可以参考\u0026quot;Tail calls in F#\u0026quot;.\n总结 以上就是关于CPS与尾递归的介绍, 然而这仅仅是关于continuation的一点皮毛而已, 也没有涉及到call/cc的内容, 如果你对continuation有兴趣, 可以参考Haskell中的\u0026quot;Continuation monad\u0026quot;. 另外, 如果你关于本文有任何问题, 欢迎邮件我\n","permalink":"https://www.sdlinks.net/posts/2020/cps/","summary":"\u003cp\u003e之前在\u0026quot;Essentials of Programming Languages\u0026quot;中学习过CPS(\u003cem\u003eContinuation Passing Style\u003c/em\u003e), 而笔记在blog改版后被丢弃, 故在这篇文章中重新详细的探讨下CPS以及尾递归, 就当是温故而知新.\u003c/p\u003e\n\u003ch2 id=\"continuation\"\u003eContinuation\u003c/h2\u003e\n\u003cp\u003e在理解什么是\u0026quot;Continuation Passing Style\u0026quot;之前, 我们首先需要定义\u003cem\u003eContinuation\u003c/em\u003e(惭愧的是我都不知道中文叫啥, 查了下好像是\u0026quot;续延\u0026quot;). \u003cem\u003eContinuation\u003c/em\u003e是计算机程序控制状态的抽象表示, 换言之, 其就是一种表示程序执行中间某一计算步骤的控制上下文的数据结构, 即表示某一计算的未来. 一个形象的例子是阶乘函数:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fsharp\" data-lang=\"fsharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"nv\"\u003erec\u003c/span\u003e \u003cspan class=\"n\"\u003efact\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ethen\u003c/span\u003e \u003cspan class=\"n\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efact\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e当我们计算\u003ccode\u003e(fact 4)\u003c/code\u003e时, 其执行过程为(用lisp的形式是因为更加形象):\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scheme\" data-lang=\"scheme\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003efact\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e=\u0026gt; \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003efact\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e=\u0026gt; \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003efact\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e)))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e=\u0026gt; \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003efact\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e))))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e=\u0026gt; \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003efact\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)))))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e=\u0026gt; \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e))))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e=\u0026gt; \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e=\u0026gt; \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e=\u0026gt; \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003e* \u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e \u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e=\u0026gt; \u003c/span\u003e\u003cspan class=\"mi\"\u003e24\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这过程中, \u003ccode\u003e(* 4 #)\u003c/code\u003e就是一个\u003cem\u003econtinuation\u003c/em\u003e, 是\u003ccode\u003e(fact 3)\u003c/code\u003e的控制上下文, 等待着\u003ccode\u003e(fact 3)\u003c/code\u003e的计算结果传入我们的\u0026quot;#\u0026quot;, \u003ccode\u003e(* 4 (* 3 #))\u003c/code\u003e也是一个\u003cem\u003econtinuation\u003c/em\u003e. 容易看到的是在这样一个计算过程中, \u003cem\u003econtinuation\u003c/em\u003e在不断增长, 因为调用栈在不断增长, 程序不得不保存\u003ccode\u003e*\u003c/code\u003e的左操作数, 计算右操作数. 接下来, 我们来看\u003ccode\u003efact\u003c/code\u003e的尾递归版本, 所谓的\u003cstrong\u003e尾递归\u003c/strong\u003e(\u003cem\u003etail recursion\u003c/em\u003e)指的是递归函数的递归调用部分只有函数调用, 即:\u003c/p\u003e","title":"Continuation Passing Style and Tail Recursion"},{"content":"近来想于函数式编程中寻找类似与双向链表的数据结构, 结果找到了Zipper. Zipper中文为拉链, 泛指一类常在函数式编程中使用的聚合数据结构, 其加强了原有的数据结构, 使得能够遍历或更新原有数据结构的任意部分. zipper的关键思想是将目前需要处理的部分和不需要处理的部分分开, 同时保存目前不需要的部分, 也可以将其形象的理解为光标. 本文首先介绍了如何在list的基础上构建zipper, 随后将其扩展到二叉树上.\nlist的例子 定义zipper list或者说是单向链表, 是函数式编程中最负盛名的结构, 其既简单又实用. 当我们需要修改list中的一部分时, 例如将[1 2 3 4 5]中的[3 4 5]替换为[5 6], list就带来了问题. 这时候一个简单的做法是:\n1 2 3 4 5 6 let rec changeTailOfList l1 idx l2 = match l1 with | [] -\u0026gt; l2 // 忽略了idx大于0的情况 | x::xs -\u0026gt; if idx = 0 then l2 else x :: (changeTailOfList xs (idx - 1) l2) changeTailOfList [1; 2; 3; 4; 5] 2 [5; 6] // [1; 2; 5; 6] 看起来好像挺不错, 而这时候如果我们想要修改刚刚添加的内容, 例如在上面的例子中, 我们把5替换为[7 8], 这时候同样可以采取和changeTailOfList一样的做法, 从头开始遍历列表, 在目标位置进行更改. 显而易见, 在需要频繁修改某一部分的场合下, list是不适用的(虽然list本身就不是为了频繁修改某一部分而设计的). 然而, 这种需求是确实存在的, 在可变的条件下, 我们很容易想到双向链表, 设定一个指针指向我们当前操作的位置便可以方便的进行前向或后向修改. 那我们要如何在不可变的条件下满足这一需求呢? zipper正是为了解决这一类问题. 首先我们来定义list上的zipper:\n1 2 3 type \u0026#39;a ListZipper = ListZipper of \u0026#39;a list * \u0026#39;a list let zipper l1 = ListZipper (l1, []) 对于list而言, 我们需要处理的部分总是位于某个子列表的头部, 而需要保存的部分则是目标位置前面的部分, 因此我们可以用俩个列表, 一个表示目前正在处理的部分, 另一个表示之前的部分.\n移动光标 在一开始, 我曾提到可以将zipper理解为光标, 初始化时光标的位置位于开头. 当光标在一个列表中时, 容易看到其只能向前或向后移动:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let goForward (ListZipper (cur, back)) = match cur with | [] -\u0026gt; failwith \u0026#34;Out of range\u0026#34; // 也可以用Maybe monad来处理 | x :: xs -\u0026gt; ListZipper (xs, x :: back) let goBack (ListZipper (cur, back)) = match back with | [] -\u0026gt; failwith \u0026#34;At the beginning of list\u0026#34; | x :: xs -\u0026gt; ListZipper (x :: cur, xs) let rec goEnd = function | ListZipper ([], _) as lz -\u0026gt; lz | lz -\u0026gt; lz |\u0026gt; goForward |\u0026gt; goEnd let rec goStart = function | ListZipper (_, []) as lz -\u0026gt; lz | lz -\u0026gt; lz |\u0026gt; goBack |\u0026gt; goStart 现在我们可以移动光标了:\n1 2 3 4 5 6 7 8 9 let origin = [1; 2; 3; 4; 5; 6] let start = zipper origin \u0026gt; let pos1 = goForward start;; val pos1 : int ListZipper = ListZipper ([2; 3; 4; 5; 6],[1]) \u0026gt; let pos2 = goForward pos1;; val pos2 : int ListZipper = ListZipper ([3; 4; 5; 6],[2; 1]) \u0026gt; let endP = goEnd start;; val endP : int ListZipper = ListZipper ([],[6; 5; 4; 3; 2; 1]) 修改操作 由于我们最终的目的是希望能够方便的修改列表, 因此需要在zipper上定义修改的函数:\n1 2 3 4 5 6 7 let add x (ListZipper (cur, back)) = ListZipper (cur, x :: back) let delete = function | ListZipper (_, []) as lz -\u0026gt; lz | ListZipper (cur, x :: xs) -\u0026gt; ListZipper (cur, xs) let replace (ListZipper (_, back)) ls = ListZipper (ls, back) 同时, 我们也可能需要得到修改后的整个列表:\n1 2 3 let rec extract = function | ListZipper (ls, []) -\u0026gt; ls | lz -\u0026gt; lz |\u0026gt; goStart |\u0026gt; extract 至此, 我们就完成了list zipper, 使用zipper就像在使用一个拉链或者说是光标. 一个直观的应用场景是缓冲区的使用, 或者更具体而言就是我们打字的输入缓冲, 我们可以通过前后移动光标来改变我们的输入. 即:\n1 2 3 4 5 6 7 type Buffer = char list let empty: Buffer = [] let init = zipper empty // 和我们正常输入的体验是一致的 \u0026gt; let afterInut = init |\u0026gt; add \u0026#39;c\u0026#39; |\u0026gt; add \u0026#39;d\u0026#39; |\u0026gt; delete;; val afterInut : char ListZipper = ListZipper ([],[\u0026#39;c\u0026#39;]) 基于树的zipper 定义zipper 首先我们定义简单的二叉树类型:\n1 type \u0026#39;a Tree = Empty | Tree of \u0026#39;a Tree * \u0026#39;a * \u0026#39;a Tree 和list类似的, 我们首先要明确的是正在处理的部分和需要保存的部分. 显然对于树而言, 需要处理的是某一子树, 剩下的部分即根的值以及另一子树则需要保存起来. 另外和list中光标只能前向和后向移动不同, 在树中我们的光标可以向左, 向右, 以及向上移动. 首先能够想到的是:\n1 type \u0026#39;a TreeZipper = TreeZipper of \u0026#39;a Tree * (\u0026#39;a * \u0026#39;a Tree) list 这样, 我们可以轻松的定义goLeft和goRight:\n1 2 3 4 let goLeft = function | TreeZipper (Empty, _) -\u0026gt; failwith \u0026#34;cannot go left\u0026#34; | TreeZipper (Tree (l, x, r), back) -\u0026gt; TreeZipper (l, (x, r) :: back) // goRight是类似的 但我们发现无法定义goUp, 因为我们无法判断目前处理的是左子树还是右子树, 因此我们需要修改TreeZipper使得其能够明确我们目前处理的是左子树还是右子树:\n1 2 3 4 type \u0026#39;a Loc = Left of \u0026#39;a * \u0026#39;a Tree | Right of \u0026#39;a * \u0026#39;a Tree type \u0026#39;a TreeZipper = TreeZipper of \u0026#39;a Tree * \u0026#39;a Loc list let zipper t = TreeZipper (t, []) 移动光标 现在, 我们可以轻松的定义移动函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let goLeft = function | TreeZipper (Empty, _) -\u0026gt; failwith \u0026#34;cannot go left\u0026#34; | TreeZipper (Tree (l, x, r), back) -\u0026gt; TreeZipper (l, Left (x, r) :: back) let goRight = function | TreeZipper (Empty, _) -\u0026gt; failwith \u0026#34;cannot go right\u0026#34; | TreeZipper (Tree (l, x, r), back) -\u0026gt; TreeZipper (r, Right (x, l) :: back) let goUp = function | TreeZipper (_, []) -\u0026gt; failwith \u0026#34;cannot go up, at the root of tree\u0026#34; | TreeZipper (l, Left (x, r) :: tail) | TreeZipper (r, Right (x, l) :: tail) -\u0026gt; TreeZipper (Tree (l, x, r), tail) let rec goRoot = function | TreeZipper (_, []) as tz -\u0026gt; tz | tz -\u0026gt; tz |\u0026gt; goUp |\u0026gt; goRoot 可以简单的测试一下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026gt; let a = Tree (Tree (Tree (Empty, 4, Empty), 2, Tree (Empty, 5, Empty)), 1, Tree (Tree (Empty, 6, Empty), 3, Tree (Empty, 7, Empty)));; \u0026gt; val a : int Tree = Tree (Tree (Tree (Empty,4,Empty),2,Tree (Empty,5,Empty)),1, Tree (Tree (Empty,6,Empty),3,Tree (Empty,7,Empty))) \u0026gt; let init = zipper a;; val init : int TreeZipper = TreeZipper (Tree (Tree (Tree (Empty,4,Empty),2,Tree (Empty,5,Empty)),1, Tree (Tree (Empty,6,Empty),3,Tree (Empty,7,Empty))),[]) \u0026gt; init |\u0026gt; goLeft |\u0026gt; goRight;; val it : int TreeZipper = TreeZipper (Tree (Empty,5,Empty), [Right (2,Tree (Empty,4,Empty)); Left (1,Tree (Tree (Empty,6,Empty),3,Tree (Empty,7,Empty)))]) \u0026gt; init |\u0026gt; goLeft |\u0026gt; goRight |\u0026gt; goUp;; val it : int TreeZipper = TreeZipper (Tree (Tree (Empty,4,Empty),2,Tree (Empty,5,Empty)), [Left (1,Tree (Tree (Empty,6,Empty),3,Tree (Empty,7,Empty)))]) 修改操作 同样的, 和list一样, 我们还需要修改的函数, 以及能够得到修改后的树的函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 一种简单的处理 let add x (TreeZipper (cur, back)) = TreeZipper (Tree (cur, x, Empty), back) let replace t (TreeZipper (_, back)) = TreeZipper (t, back) let rec extract = function | TreeZipper (t, []) -\u0026gt; t | tz -\u0026gt; tz |\u0026gt; goRoot |\u0026gt; extract // 删除值后将子树的左子树放到右子树最近的空节点处 let delete = function | TreeZipper (Empty, _) -\u0026gt; failwith \u0026#34;cannot delete empty\u0026#34; | TreeZipper (Tree (l, _, r), back) -\u0026gt; let rec nearestEmpty = function | TreeZipper (Empty, _) as tz -\u0026gt; tz | TreeZipper (Tree (Empty, x, r), back) -\u0026gt; TreeZipper (Empty, Left (x, r) :: back) | TreeZipper (Tree (l, x, Empty), back) -\u0026gt; TreeZipper (Empty, Right (x, l) :: back) | tz -\u0026gt; tz |\u0026gt; goLeft |\u0026gt; nearestEmpty let rz = zipper r let t = rz |\u0026gt; nearestEmpty |\u0026gt; replace l |\u0026gt; extract TreeZipper (t, back) 对于树而言, replace与list逻辑是相同的, 但add和delete的逻辑有所不同且存在着多种处理方式. 例如delete函数中, 这边采用的逻辑是将值删除后, 把左子树放到了右子树最近的空节点处, 还可以将其置于最右边或者最左边的空节点处.\n至此, 我们就完成了基于树的zipper, 可以看到基于树的zipper总体思想和基于list的zipper是一致的, 同样像是一个光标, 将其分成了需要处理的部分与不需要处理的部分.\n结语 如果你看到了这里, 我想你对于zipper应该有了一个较为清晰的认识. 只要能够明白zipper的基本思想: 将需要处理的部分与不需要处理的部分分离, 就能够正确的将其应用与其他数据结构. 最后, 如果你有任何问题, 欢迎邮件我\n参考文献 [1] Zippers\n[2] Huet, G. (1997). The zipper. Journal of functional programming, 7(5), 549-554.\n","permalink":"https://www.sdlinks.net/posts/2020/zipper/","summary":"\u003cp\u003e近来想于函数式编程中寻找类似与双向链表的数据结构, 结果找到了Zipper. Zipper中文为拉链, 泛指一类常在函数式编程中使用的聚合数据结构, \u003cstrong\u003e其加强了原有的数据结构, 使得能够遍历或更新原有数据结构的任意部分\u003c/strong\u003e. zipper的关键思想是将目前需要处理的部分和不需要处理的部分分开, 同时保存目前不需要的部分, 也可以将其形象的理解为光标. 本文首先介绍了如何在list的基础上构建zipper, 随后将其扩展到二叉树上.\u003c/p\u003e\n\u003ch2 id=\"list的例子\"\u003elist的例子\u003c/h2\u003e\n\u003ch3 id=\"定义zipper\"\u003e定义zipper\u003c/h3\u003e\n\u003cp\u003elist或者说是单向链表, 是函数式编程中最负盛名的结构, 其既简单又实用. 当我们需要修改list中的一部分时, 例如将\u003ccode\u003e[1 2 3 4 5]\u003c/code\u003e中的\u003ccode\u003e[3 4 5]\u003c/code\u003e替换为\u003ccode\u003e[5 6]\u003c/code\u003e, list就带来了问题. 这时候一个简单的做法是:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fsharp\" data-lang=\"fsharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"nv\"\u003erec\u003c/span\u003e \u003cspan class=\"n\"\u003echangeTailOfList\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"n\"\u003eidx\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ematch\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"k\"\u003ewith\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"bp\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 忽略了idx大于0的情况\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003exs\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003eidx\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003e0\u003c/span\u003e \u003cspan class=\"k\"\u003ethen\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e::\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echangeTailOfList\u003c/span\u003e \u003cspan class=\"n\"\u003exs\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eidx\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003echangeTailOfList\u003c/span\u003e \u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003e5\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"n\"\u003e2\u003c/span\u003e \u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e5\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003e6\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [1; 2; 5; 6]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e看起来好像挺不错, 而这时候如果我们想要修改刚刚添加的内容, 例如在上面的例子中, 我们把\u003ccode\u003e5\u003c/code\u003e替换为\u003ccode\u003e[7 8]\u003c/code\u003e, 这时候同样可以采取和\u003ccode\u003echangeTailOfList\u003c/code\u003e一样的做法, 从头开始遍历列表, 在目标位置进行更改. 显而易见, 在需要频繁修改某一部分的场合下, list是不适用的(虽然list本身就不是为了频繁修改某一部分而设计的). 然而, 这种需求是确实存在的, 在可变的条件下, 我们很容易想到双向链表, 设定一个指针指向我们当前操作的位置便可以方便的进行前向或后向修改. 那我们要如何在不可变的条件下满足这一需求呢? zipper正是为了解决这一类问题. 首先我们来定义list上的zipper:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fsharp\" data-lang=\"fsharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003etype\u003c/span\u003e \u003cspan class=\"k\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"n\"\u003eListZipper\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eListZipper\u003c/span\u003e \u003cspan class=\"k\"\u003eof\u003c/span\u003e \u003cspan class=\"k\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"kt\"\u003elist\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"k\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"kt\"\u003elist\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"nv\"\u003ezipper\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eListZipper\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"bp\"\u003e[]\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e对于list而言, 我们需要处理的部分总是位于某个子列表的头部, 而需要保存的部分则是目标位置前面的部分, 因此我们可以用俩个列表, 一个表示目前正在处理的部分, 另一个表示之前的部分.\u003c/p\u003e","title":"Zipper"},{"content":"Bitwise tricks 近来翻到一本\u0026quot;Hackers Delight\u0026quot;的书, 其主要介绍基于二进制运算的算法. 初读来大感震撼, 其结果之巧妙,过程之精简, 于仅仅是了解计算机数是用补码所表示, 并未深入了解过二进制运算的人而言不可谓不精美. 正如Dijkstra所言, 计算机程序是集逻辑美感与机械实现的矛盾体. 本文姑且将其中的一些皮毛摘录如下, 以便日后之使用, 目前倒是难以得到应用.\n使最右位的1变成0\n1 2 3 // 01011000 -\u0026gt; 01010000 // if no one then return 0 x \u0026amp; (x - 1) 上式也可以用来判断一个无符号的整数是否是$ 2^n $的形式.\n使最右位的0变成1\n1 2 3 // 10100111 -\u0026gt; 10101111 // if no zero then return -1 x | (x + 1) 使尾部的1变成0\n1 2 3 // 10100111 -\u0026gt; 10100000 // if no trailing 1s then identity x \u0026amp; (x + 1) 上式也可以用来判断一个无符号的整数是否是$ 2^n - 1 $的形式.\n使尾部的0变成1\n1 2 3 // 10101000 -\u0026gt; 10101111 // if no trailing 1s then identity x | (x - 1) 使最右位的0变成1, 同时其余位变成0\n1 2 3 // 10100111 -\u0026gt; 00001000 // if no rightmost 0 then return 0 ~x \u0026amp; (x + 1) 使最右位的1变成0, 同时其余位变成1\n1 2 3 // 10101000 -\u0026gt; 11110111 // if no rightmost 1 then return -1 ~x | (x - 1) 使尾部的0变成1, 同时其余位变成0\n1 2 3 // 01011000 -\u0026gt; 00000111 // if no trailling 0s then return 0 ~x \u0026amp; (x - 1) 使尾部的1变成0, 同时其余位变成1\n1 2 3 // 10100111 -\u0026gt; 11111000 // if no trailing 1s then return -1 ~x | (x + 1) 只保留最右位的1, 其余位变成0\n1 2 3 // 01011000 -\u0026gt; 00001000 // if no rightmost 1 then return 0 x ^ (x - 1) 使得从右往左到最右位的0都变成1, 其余位变成0\n1 2 3 4 // 01010111 -\u0026gt; 00001111 // if no rightmost 0 then return -1 // else if no trailing 1s then return 1 x ^ (x + 1) 使得最右边连续的1变成0\n1 ((x | (x - 1)) + 1) \u0026amp; x 上式也可以用来判断一个无符号的整数是否是$ 2 ^ n - 2 ^ m (n \u0026gt; m) $的形式.\n","permalink":"https://www.sdlinks.net/posts/2020/some-bitwise-tricks/","summary":"\u003ch2 id=\"bitwise-tricks\"\u003eBitwise tricks\u003c/h2\u003e\n\u003cp\u003e近来翻到一本\u0026quot;Hackers Delight\u0026quot;的书, 其主要介绍基于二进制运算的算法. 初读来大感震撼, 其结果之巧妙,过程之精简, 于仅仅是了解计算机数是用补码所表示, 并未深入了解过二进制运算的人而言不可谓不精美. 正如Dijkstra所言, 计算机程序是集逻辑美感与机械实现的矛盾体. 本文姑且将其中的一些皮毛摘录如下, 以便日后之使用, 目前倒是难以得到应用.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e使最右位的1变成0\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c#\" data-lang=\"c#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 01011000 -\u0026gt; 01010000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// if no one then return 0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e-\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e上式也可以用来判断一个无符号的整数是否是$ 2^n $的形式.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使最右位的0变成1\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c#\" data-lang=\"c#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 10100111 -\u0026gt; 10101111\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// if no zero then return -1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使尾部的1变成0\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c#\" data-lang=\"c#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 10100111 -\u0026gt; 10100000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// if no trailing 1s then identity\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e上式也可以用来判断一个无符号的整数是否是$ 2^n - 1 $的形式.\u003c/p\u003e","title":"Some Bitwise Tricks"},{"content":"Value Restriction是什么？ Value restriction是用于控制类型推断能否对值声明进行多态泛化的规则（MLton原文：“The value restriction is a rule that governs when type inference is allowed to polymorphically generalize a value declaration.”）。常出现在ML系的语言中，如SML，OCaml，F#中，其实value restriction产生的本质原因是为了保证类型系统在结合参数多态与命令式特性（imperative feature，如ref）时候的可靠性（soundness）。一个典型的例子就是：\n1 2 3 4 5 6 // 如果没有value restriction let x = ref None // \u0026#39;a option ref let y: int option ref = x // type checked let z: string option ref = x // type checked let () = y := Some 2 // type checked let v: string = !z // 破坏了类型安全 限制了什么？ 简单来讲，value restriction限制了类型泛化只能发生在表达式的右边是句法意义上的值。那么什么是句法意义上的值呢，SML的语言规范上明确给出了什么样的表达式是句法意义上的值（准确来说是non-expansive）:\n常量，如13，\u0026quot;string\u0026quot; 变量，如x,y 函数，如fn x =\u0026gt; e 除了ref以外的构造函数在值上的调用，如Foo v 类型上受约束的值，如v: t 每一个元素都是值的tuple, 如(v1, v2, v3) 每一个字段都是值的record, 如{l1 = v1, l2 = v2} 每一个元素都是值的list, 如[v1, v2, v3] 确切的来讲，只要是协变（covariant）的类型并且不和可变的特性相结合，那么它总是可以类型安全的泛化（OCaml manual原文：“As a corollary, covariant variables will never denote mutable locations and can be safely generalized.”）。即：\n是没有副作用的 表达式的结果是一个不可变对象 在完备性上的问题 从上述规则来看，let x = ref None显然是非法的表达式，然而在引入value restriction的同时，类型系统损失了一定的完备性（completeness），因为以下代码同样违反了value restriction：\n1 2 let id x = x // \u0026#39;a -\u0026gt; \u0026#39;a let listId = List.map id // 违反了value restriction 即使我们只使用不可变特性，上述代码依然无法通过类型检查。因为函数调用不是句法意义上的值(因为编译器无法判断函数调用是否是pure的)。当然上述问题可以通过eta-expansion来避免，即：\n1 let listId = fun x -\u0026gt; List.map id x // \u0026#39;a list -\u0026gt; \u0026#39;a list lambda表达式是句法意义上的值，因此上述代码是可以通过类型检查的。\n如何避免value restriction 为了能够使得我们本身soundness的代码通过类型检查，在value restriction的限制下我们不得不做一些额外的工作。\neta-expansion\n向上一个例子那样，我们可以引入一个自由变量，使得函数调用变成了一个函数声明，从而通过了类型检查。\n1 let lsitId = fun x -\u0026gt; List.map id x 在这种情况下，每一次listId被调用时，List.map id都会被调用。而不是像原来那样只在声明listId时调用一次，当然在有些情况下这可能会造成一个性能问题。\n引入局部变量，例如以下代码同样无法通过类型检查\n1 2 type \u0026#39;a T = A of string | B of \u0026#39;a let a = A (if true then \u0026#34;yes\u0026#34; else \u0026#34;no\u0026#34;) // failed 但是可以修改为\n1 2 let s = if true then \u0026#34;yes\u0026#34; else \u0026#34;no\u0026#34; in let a = A s 使得其符合value restriction的规则。\nOCaml和F#中的value restriction OCaml和F#同样存在着value restriction的完备性的问题，俩者通过不同的方式对其进行了relax。\nOCaml的relaxed value restriction OCaml通过引入一个弱类型变量来放宽value restriction. 所谓弱类型变量是指编译器未知的变量，而一旦这个弱类型变量被编译器推断为一个具体的变量时，该弱类型变量就被具体的变量所替代，并且不在可变。例如：\n1 2 3 4 5 6 # let a = ref None;; val a : \u0026#39;_a option ref = {contents = None} # let () = a := Some 2;; # a;;let v\u0026lt;\u0026#39;T\u0026gt; : \u0026#39;T option ref = ref None;; val v\u0026lt;\u0026#39;T\u0026gt; : \u0026#39;T option ref - : int option ref = {contents = Some 2} 这和我们第一个例子是类似的，同意违反了value restriction。但是OCaml将a的类型推断为'_a option ref，这里的弱类型变量'_a指代的是未知的类型变量，在let () = a := Some 2中，编译器将'_a推断为int并且将a的类型固定为int option ref，通过这样的处理解决了第一个例子所展示的类型不安全的问题。换一种角度来看，所谓的弱类型变量是推迟了推断的具体的变量，即具体变量的占位符。这样确实解决了原有value restriction的完备性的问题，但同样导致了某些程序不在足够的泛化。例如\n1 2 3 4 # let id x = x;; val id : \u0026#39;a -\u0026gt; \u0026#39;a = \u0026lt;fun\u0026gt; # let listId = List.map id;; val listId : \u0026#39;_a list -\u0026gt; \u0026#39;_a list = \u0026lt;fun\u0026gt; 和前面一样，这同样是一个违反了value restriction的例子，于是OCaml使用了弱类型变量来处理，这意味着一旦我们在int list类型上调用完listId，例如listId [1; 2; 3]，之后listId就被固定为int list -\u0026gt; int list，这意味着我们无法再在string list上调用listId，而这同样不符合我们泛化的初衷，即'a list -\u0026gt; 'a list。当然我觉得OCaml的relaxed value restriction算是处理的非常优雅，有兴趣的可以阅读相关论文[6]。\nF#的处理 虽说F#参照了OCaml, 但还是存在着相当多的不同之处，在value restriction的处理上俩者也存在着区别。在F#中，上述违反了value restriction的例子依然是非法的。F#语言规范中同样明确给出了可以泛化的情况（generalizable）:\n函数表达式 实现接口的对象表达式 委托表达式 右边同样是可泛化的let表达式 右边同样是可泛化的let rec表达式 所有元素都是可泛化的tuple表达式 所有字段都是可泛化且不包含可变字段的record表达式 所有参数都是可泛化的union case表达式（即union类型表达式） 所有参数都是可泛化的exception表达式 空的array表达式 常量表达式 带有GeneralizableValue标签的类型函数的调用 因此在F#中listId同样是非法的。但是F#允许你引入一个显示的泛型参数来解决这个问题，即：\n1 2 \u0026gt; let listId\u0026lt;\u0026#39;T\u0026gt; : \u0026#39;T list -\u0026gt; \u0026#39;T list = List.map id;; val listId\u0026lt;\u0026#39;T\u0026gt; : (\u0026#39;T list -\u0026gt; \u0026#39;T list) 这样的处理虽然不够优雅，但似乎是完美解决了这个问题，因为这里不会出现OCaml那样泛化不够的问题。但我们在看ref的问题：\n1 2 3 4 5 6 \u0026gt; let v\u0026lt;\u0026#39;T\u0026gt; : \u0026#39;T option ref = ref None;; val v\u0026lt;\u0026#39;T\u0026gt; : \u0026#39;T option ref \u0026gt; v := Some 2;; val it : unit = () \u0026gt; let x: int option = !v;; val x : int option = None // Oops 我们看到，这里x的值居然是None，而不是预期的Some 2。实际上这里的v并不是一个ref对象，而是一个泛型类，其接收一个泛型参数，产生一个具体的类，当我们对v赋值时，真正调用的是(v\u0026lt;int\u0026gt;) := Some 2，而此时会生成一个新的ref对象。即使我们使用let x: int option = !v\u0026lt;int\u0026gt;得到的依然是None，因为此时又生成了一个新的ref对象，这个行为是由IL所决定的（有兴趣可以参考[4]）。因此我们不得不声明类型变量:\n1 2 3 4 5 \u0026gt; let v1 : int option ref = v\u0026lt;int\u0026gt;;; val v1 : int option ref = { contents = None } \u0026gt; let () = v1 := Some 2;; \u0026gt; let x = !v1;; val x : int option = Some 2 而这就又回到了OCaml的relaxed value restriction，并且比F#更加优雅：\n1 2 3 4 5 # let v1 = ref None;; val v1 : \u0026#39;_a option ref = {contents = None} # let () = v1 := Some 2;; # let x = !v1;; val x : int option = Some 2 可见俩者在一定程度上是等价的。对于lsitId而言F#更有优势，因为泛型方法能够自动推断参数类型。而对于\nref对象而言，OCaml的处理更优雅，因为F#中，v变成了一个泛型类，而不是普通的值，而这是比较令人困惑的。在F#中，为了避免这样的问题，可以使用[\u0026lt;RequiresExplicitTypeArguments\u0026gt;]，即：\n1 2 [\u0026lt;RequiresExplicitTypeArguments\u0026gt;] let v\u0026lt;\u0026#39;T\u0026gt; : \u0026#39;T option ref = ref None 在这样的情况下，你将无法使用v := Some 2，而必须使用v\u0026lt;int\u0026gt; := Some 2，这样就能清晰的表示v是一个泛型类而不再是一个普通的值。另外，值得一提的是F#还提供了[\u0026lt;GeneralizableValue\u0026gt;]（即上述可泛化对象的最后一条），来告诉编译器这是一个可泛化的值：\n1 2 3 4 5 \u0026gt; [\u0026lt;GeneralizableValue\u0026gt;] - let v\u0026lt;\u0026#39;T\u0026gt; : \u0026#39;T option ref = ref None;; val v\u0026lt;\u0026#39;T\u0026gt; : \u0026#39;T option ref \u0026gt; let a = v;; val a : \u0026#39;a option ref 如果没有[\u0026lt;GeneralizableValue\u0026gt;]，let a = v将违反value restriction.\n结语 如果你看到了这里，我想你对value restriction应该有了一个清晰的认识，并且对OCaml和F#如何放宽value restriction有了充分的了解。而如果你使用F#编程，那么我的建议是除非你清楚的知道自己在做什么(即添加额外的泛型参数)，否则就按照MSDN的建议，我这边稍微扩展了一下：\n添加一个显示的参数，使得其变为具体的类型\n1 2 3 let counter = ref None // Adding a type annotation fixes the problem: let counter : int option ref = ref None 使用eta-expansion将函数组合与部分调用展成一个lambda表达式或常规的函数\n1 2 3 4 5 6 let maxhash = max \u0026lt;\u0026lt; hash // The following is acceptable because the argument // for maxhash is explicit: let maxhash obj = (max \u0026lt;\u0026lt; hash) obj // or let maxhash = fun obj -\u0026gt; (max \u0026lt;\u0026lt; hash) obj 引入局部变量来重写表达式\n1 2 3 4 5 type \u0026#39;a T = A of string | B of \u0026#39;a let a = A (if true then \u0026#34;yes\u0026#34; else \u0026#34;no\u0026#34;) // introducing a local variable fixs the problem let s = if true then \u0026#34;yes\u0026#34; else \u0026#34;no\u0026#34; in let a = A s 通过添加一个额外的，无用的参数将表达式变成一个thunk\n1 2 3 4 let emptyList10 = Array.create 10 [] // Adding an extra (unused) parameter makes it a function, // which is generalizable. let emptyList10 () = Array.create 10 [] 最后，如果你有任何问题或者关于该文章的任何建议，欢迎邮件我。\n参考文献 [1] ValueRestriction\n[2] Polymorphism and its limitations\n[3] Relaxed value restriction\n[4] Finer Points of F# Value Restriction\n[5] Wright, A. K. (1995). Simple imperative polymorphism. Lisp and symbolic computation, 8(4), 343-355.\n[6] Garrigue, J. (2004, April). Relaxing the value restriction. In International Symposium on Functional and Logic Programming (pp. 196-213). Springer, Berlin, Heidelberg.\n","permalink":"https://www.sdlinks.net/posts/2018/value-restriction/","summary":"\u003ch2 id=\"value-restriction是什么\"\u003eValue Restriction是什么？\u003c/h2\u003e\n\u003cp\u003eValue restriction是用于控制类型推断能否对值声明进行多态泛化的规则（\u003ca href=\"http://mlton.org/ValueRestriction\"\u003eMLton原文\u003c/a\u003e：“\u003cem\u003eThe value restriction is a rule that governs when type inference is allowed to polymorphically generalize a value declaration.\u003c/em\u003e”）。常出现在ML系的语言中，如\u003ca href=\"https://www.smlnj.org/\"\u003eSML\u003c/a\u003e，\u003ca href=\"https://ocaml.org/\"\u003eOCaml\u003c/a\u003e，\u003ca href=\"https://fsharp.org/\"\u003eF#\u003c/a\u003e中，其实value restriction产生的本质原因是为了保证类型系统在结合参数多态与命令式特性（\u003cem\u003eimperative feature\u003c/em\u003e，如\u003ccode\u003eref\u003c/code\u003e）时候的可靠性（\u003cem\u003esoundness\u003c/em\u003e）。一个典型的例子就是：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fsharp\" data-lang=\"fsharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 如果没有value restriction\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"nv\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eref\u003c/span\u003e \u003cspan class=\"n\"\u003eNone\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// \u0026#39;a option ref\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"nv\"\u003ey\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eoption\u003c/span\u003e \u003cspan class=\"n\"\u003eref\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"c1\"\u003e// type checked\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"nv\"\u003ez\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eoption\u003c/span\u003e \u003cspan class=\"n\"\u003eref\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"c1\"\u003e// type checked\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"bp\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"n\"\u003eSome\u003c/span\u003e \u003cspan class=\"n\"\u003e2\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// type checked\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003elet\u003c/span\u003e  \u003cspan class=\"nv\"\u003ev\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003ez\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 破坏了类型安全\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"限制了什么\"\u003e限制了什么？\u003c/h2\u003e\n\u003cp\u003e简单来讲，value restriction限制了类型泛化只能发生在表达式的右边是句法意义上的值。那么什么是句法意义上的值呢，SML的\u003ca href=\"http://sml-family.org/sml97-defn.pdf\"\u003e语言规范\u003c/a\u003e上明确给出了什么样的表达式是句法意义上的值（准确来说是\u003cem\u003enon-expansive\u003c/em\u003e）:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e常量，如\u003ccode\u003e13，\u0026quot;string\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e变量，如\u003ccode\u003ex,y\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e函数，如\u003ccode\u003efn x =\u0026gt; e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e除了\u003ccode\u003eref\u003c/code\u003e以外的构造函数在值上的调用，如\u003ccode\u003eFoo v\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e类型上受约束的值，如\u003ccode\u003ev: t\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e每一个元素都是值的\u003cstrong\u003etuple\u003c/strong\u003e, 如\u003ccode\u003e(v1, v2, v3)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e每一个字段都是值的\u003cstrong\u003erecord\u003c/strong\u003e, 如\u003ccode\u003e{l1 = v1, l2 = v2}\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e每一个元素都是值的\u003cstrong\u003elist\u003c/strong\u003e, 如\u003ccode\u003e[v1, v2, v3]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e确切的来讲，只要是协变（covariant）的类型并且不和可变的特性相结合，那么它总是可以类型安全的泛化（\u003ca href=\"https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html\"\u003eOCaml manual\u003c/a\u003e原文：“\u003cem\u003eAs a corollary, covariant variables will never denote mutable locations and can be safely generalized.\u003c/em\u003e”）。即：\u003c/p\u003e","title":"Value restriction，从OCaml到F#"},{"content":"之前一直有使用Hexo来生成静态博客，如今将博客迁移到了Hugo下。两种工具总体而言各有优势，个人此次转移到hugo的主要原因大概是希望能够重拾写博客的习惯，本文主要介绍了使用Hugo的大致流程。首先给出个人博客的文件结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Root # blog根目录 | +-- archetypes +-- content |-- posts # 博客目录 |-- _index.md # 主页 +-- data +-- layouts +-- ox-hugo # org文件位置 |-- messy.org # category为Others的org文件 +-- public # submodule +-- resource +-- static +-- themes |-- xxx # 主题文件夹, submodule +-- .git +-- config.toml +-- .dir-locals.el # 自动将org文件转为markdown配置文件 +-- .gitmodules 其中只有 ox-hugo 为自定义文件夹, .dir-locals 为ox-hugo自动转换的配置文件，其他都是自动生成的。接下来个人就hugo生成博客关键部分展开介绍下。\n主题的选择 首先搭建博客面对的问题就是主题，如果你非常擅长网页设计可以自己DIY一款主题。大多数还是会选择已有的主题，我们在选择主题时，除了最重要的UI外，还应当考虑以下的因素：\n是否支持写作的基本功能，如公式的显示（通常是MathJax）； 是否支持博客网站的基本功能，如分类，标签，分享，评论等。 尤其是评论这块，个人之前用的disqus, 但好像在国内的访问存在一些问题，目前比较推荐的方案是使用git issues来实现评论功能，如gitment。像我这样的懒人当然是选择不支持评论功能啦：）\n博客的托管 比较推荐的方案是将整个blog作为一个git项目，并且将 public 和 themes/xxx 作为该项目的submodule。其中 public 对应于你的要作为Github pages的 git项目地址，通常建议是 \u0026lt;username\u0026gt;.github.io 这个项目，这样Github会自动将该项目作为 http://\u0026lt;username\u0026gt;.github.io 页面的文件，完整的将博客自动托管到Github的流程可以参考hugo上的教程；而 themes/xxx 则是对应于主题的项目地址。这样使用submodule的一个好处是可以保证主题的同步以及public的自动托管与发布。\n使用org-mode写作 如果你对于emacs的org-mode向往已久并且希望使用其来写博客的话，一个推荐的方案是使用ox-hugo自动地将你用org-mode写的内容转为markdown，虽然hugo本身也有org-mode 的引擎，但好像支持的不是很好。在这样的工作模式下建议的方案是将所有相同category的且不是很长的博客都集中到一个org文件中，文件的开头配置大致如下：\n1 2 3 4 5 6 #+STARTUP: content #+hugo_base_dir: ../ # blog根目录 #+hugo_section: ../content/posts # ox-hugo生成md文件的目录 #+filetags: @\u0026lt;category\u0026gt; # 该org文件中所有文章的分类 #+hugo_auto_set_lastmod: t #+hugo_locale: zh-cn 每次新建一个博客时就在该文件中加入一个todo事项，如本博客的开头为：\n1 2 3 4 ** TODO 使用hugo生成博客 :PROPERTIES: :EXPORT_FILE_NAME: 使用hugo生成博客 :END: 这些可以利用org-capture自动生成的，具体可以参考ox-hugo上的文档。另外建议将文件加入到org-agenda文件列表中，这样可以快速定位未完成的博客（即TODO状态下的博客）。完成一篇博客时只需要将博客标记为DOWN即可。ox-hugo还会将org的tag转为相应的分类和标签，其中 @ 开头的为分类, ox-hugo的自动生成可以参考相应的文档。\n以上就是我在使用hugo生成博客时遇到的一些主要问题。如果你有什么问题，欢迎邮件我。\n","permalink":"https://www.sdlinks.net/posts/2019/%E4%BD%BF%E7%94%A8hugo%E7%94%9F%E6%88%90%E5%8D%9A%E5%AE%A2/","summary":"\u003cp\u003e之前一直有使用\u003ca href=\"https://hexo.io/zh-cn/index.html\"\u003eHexo\u003c/a\u003e来生成静态博客，如今将博客迁移到了\u003ca href=\"https://gohugo.io/\"\u003eHugo\u003c/a\u003e下。两种工具总体而言各有优势，个人此次转移到hugo的主要原因大概是希望能够重拾写博客的习惯，本文主要介绍了使用Hugo的大致流程。首先给出个人博客的文件结构：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eRoot               # blog根目录\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e|\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- archetypes\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- content\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e |-- posts         # 博客目录\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e |-- _index.md     # 主页\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- data\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- layouts\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- ox-hugo        # org文件位置\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e |-- messy.org     # category为Others的org文件\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- public         # submodule\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- resource\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- static\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- themes\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e |-- xxx           # 主题文件夹, submodule\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- .git\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- config.toml\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- .dir-locals.el # 自动将org文件转为markdown配置文件\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-- .gitmodules\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e其中只有 \u003ccode\u003eox-hugo\u003c/code\u003e 为自定义文件夹, \u003ccode\u003e.dir-locals\u003c/code\u003e 为ox-hugo自动转换的配置文件，其他都是自动生成的。接下来个人就hugo生成博客关键部分展开介绍下。\u003c/p\u003e","title":"使用hugo生成博客"},{"content":"Monad是Haskell中讨论最多的结构, 需要更详细的探讨其相关内容, 即使它对于Haskell而言不是必须的:(.\n参考: All about Monads\nMonad Support 除了之前介绍过的一些基本函数, Haskell本身定义了一些辅助函数配合Monad一起使用:\nsequence\n1 2 3 4 -- 任意一个fail会导致整个fail sequence :: Monad m =\u0026gt; [m a] -\u0026gt; m [a] sequence = foldr mcons (return []) where mcons p q = p \u0026gt;\u0026gt;= \\x -\u0026gt; q \u0026gt;\u0026gt;= \\y -\u0026gt; return (x : y) sequence_和sequence类似但其不返回值, 在只关心序列的副作用时其非常有用.\n1 2 sequence_ :: Monad m =\u0026gt; [m a] -\u0026gt; m () sequence_ = flodr (\u0026gt;\u0026gt;) (return ()) mapM其由sequence和map定义\n1 2 mapM :: Monad m =\u0026gt; (a -\u0026gt; m b) -\u0026gt; [a] -\u0026gt; m [b] mapM f as = sequence $ map f as mapM_, 类似的使用sequence_定义\n1 2 mapM_ :: Monad m =\u0026gt; (a -\u0026gt; m b) -\u0026gt; [a] -\u0026gt; m () mapM_ f as = sequence_ $ map f as =\u0026lt;\u0026lt;是\u0026gt;\u0026gt;=调换参数位置的版本\n1 2 (=\u0026lt;\u0026lt;) :: Monad m =\u0026gt; (a -\u0026gt; m b) -\u0026gt; m a -\u0026gt; m b f =\u0026lt;\u0026lt; x = x \u0026gt;\u0026gt;= f 上面提到的函数都是standard prelude中定义的, Haskell在Control.Monad模块中定义了更多函数.\n下面是一些列表函数的Monad版本:\nfoldM\n1 2 3 foldM :: (Monad m) =\u0026gt; (a -\u0026gt; b -\u0026gt; m a) -\u0026gt; a -\u0026gt; [b] -\u0026gt; m a foldM f a [] = return a foldM f a (x:xs) = f a x \u0026gt;\u0026gt;= \\y -\u0026gt; foldM f y xs filterM\n1 2 3 4 5 filterM :: Monad m =\u0026gt; (a -\u0026gt; m Bool) -\u0026gt; [a] -\u0026gt; m [a] filterM p [] = return [] filterM p (x:xs) = do b \u0026lt;- p x ys \u0026lt;- filterM p xs return (if b then (x:ys) else ys) zipWithM和zipWithM_\n1 2 3 4 5 zipWithM :: (Monad m) =\u0026gt; (a -\u0026gt; b -\u0026gt; m c) -\u0026gt; [a] -\u0026gt; [b] -\u0026gt; m [c] zipWithM f xs ys = sequence (zipWith f xs ys) zipWithM_ :: (Monad m) =\u0026gt; (a -\u0026gt; b -\u0026gt; m c) -\u0026gt; [a] -\u0026gt; [b] -\u0026gt; m () zipWithM_ f xs ys = sequence_ (zipWith f xs ys) Monad模块中还包含了一些流程控制函数, when和unless:\n1 2 3 4 5 when :: (Monad m) =\u0026gt; Bool -\u0026gt; m () -\u0026gt; m () when p s = if p then s else return () unless :: (Monad m) =\u0026gt; Bool -\u0026gt; m () -\u0026gt; m () unless p s = when (not p) s _Lifting_将一个non-monadic函数转换为在Monad上操作的等价函数. 最简单的lift函数是liftM:\n1 2 liftM :: (Monad m) =\u0026gt; (a -\u0026gt; b) -\u0026gt; (m a -\u0026gt; m b) liftM f = \\a -\u0026gt; do {a\u0026#39; \u0026lt;- a; return (f a\u0026#39;)} Control.Monad模块中定义了liftM, liftM2到liftM5分别将不同参数个数的函数lift成monadic. 另外还定义了$的monadic版本:\n1 2 ap :: (Monad m) =\u0026gt; m (a -\u0026gt; b) -\u0026gt; m a -\u0026gt; m b ap = liftM2 ($) Monads The Identity Monad Identity Monad(Data.Functor.Identity)不包含任何计算:\n1 2 3 4 5 newtype Identity a = Identity {runIdentity :: a} instance Monad Identity where return a = Identity a (Identity x) \u0026gt;\u0026gt;= f = f x Identity Monad是Monad转换的基石, 任意一个Monad transformer作用在Identity Monad上返回一个非转换器版本的Monad.\nThe Maybe Monad Maybe Monad表示有可能不返回值(Nothing)的计算:\n1 2 3 4 5 6 7 8 9 10 11 12 data Maybe a = Nothing | Just a instance Monad Maybe where return = Just fail = Nothing Nothing \u0026gt;\u0026gt;= f = Nothing (Just x) \u0026gt;\u0026gt;= f = f x instance MonadPlus Maybe where mzero = Nothing Nothing `mplus` x = x x `mplus` _ = x The Error Monad Error Monad(或Exception Monad)表示可能出错或抛出异常的计算, 例如Either Monad. Haskell中的MonadError是由错误的类型和相应Monad构造器参数化的:\n1 2 3 4 5 6 7 class Error a where noMsg :: a strMsg :: String -\u0026gt; a class (Monad m) =\u0026gt; MonadError e m | m -\u0026gt; e where throwError :: e -\u0026gt; m a catchError :: m a -\u0026gt; (e -\u0026gt; m a) -\u0026gt; m a catchError一种常见的使用是do {action1; action2; action3} `catchError` handler , 其中action可以调用throwError, 且handler和do-block必须有相同的返回类型. Either e则实例化了MonadError:\n1 2 3 4 instance MonadError (Either e) where throwError = Left (Left e) `catchError` handler = handler e a `catchError` _ = a The List Monad List monad表示可能返回0, 1, 或多个值的计算:\n1 2 3 4 5 6 7 8 9 10 data [] a = [] | a : [a] instance Monad [] where m \u0026gt;\u0026gt;= f = concatMap f m return x = [x] fail s = [] instance MonadPlus [] where mzero = [] mplus = (++) The IO Monad The IO Monad is just an instance of the ST monad, where the state is the real world.\nThe wonderful feature of a one-way monad is that it can support side-effects in its monadic operations but prevent them from destroying the functional properties of the non-monadic portions of the program.*\n需要注意的是, IO Monad并不是IO, 而仅仅是IO类型的Monad实例.GHC经常会为了提升性能而优化代码, 诸如调整运算顺序, 共享变量, 内联函数. IO类型的最主要工作就是禁止其中的大部分工作. 显然调整运算顺序就在IO(以及ST)中被禁止, IO操作被包含在嵌套的lambdas中以保证运算顺序的不变. 之所以需要IO Monad是因为这是一种将嵌套lambdas的噪声剥离的抽象. IO Monad是一种One-way Monad, One-way Monad意味着你无法设计一个函数在IO Monad中完成计算并返回一个没有IO Monad类型的值. IO monad的定义是平台相关的, 且没有任何构造器可以使用, 也没有任何函数能够从IO Monad中获得值.\nThe State Monad State Monad表示带有状态的计算:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 newtype State s a = State {runState :: s -\u0026gt; (a, s)} instance Monad (State s) where return a = State $ \\s -\u0026gt; (a, s) (State x) \u0026gt;\u0026gt;= f = State $ \\s -\u0026gt; let (v, s\u0026#39;) = x s in runState (f v) s\u0026#39; -- 提供了State Monad的一些接口 class MonadState m s | m -\u0026gt; s where get :: m s put :: s -\u0026gt; m () instance MonadState (State s) s where get = State $ \\s -\u0026gt; (s, s) -- 通过将值设置为状态来获取状态 put s = State $ \\_ -\u0026gt; ((), s) -- 设置状态且没有值 The Reader Monad Reader Monad表示从共享环境中读取值的计算:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- Monad instance of `(-\u0026gt;) r` newtype Reader e a = Reader {runReader :: (e -\u0026gt; a)} instance Monad (Reader e) where return a = Reader $ \\e -\u0026gt; a (Reader r) \u0026gt;\u0026gt;= f = Reader $ \\e -\u0026gt; runReader (f $ r e) e class MonadReader e m | m -\u0026gt; e where ask :: m e local :: (e -\u0026gt; e) -\u0026gt; m a -\u0026gt; m a instance MonadReader (Reader e) where ask = Reader id local f c = Reader $ \\e -\u0026gt; runReader c (f e) asks :: (MonadReader e m) =\u0026gt; (e -\u0026gt; a) -\u0026gt; m asks sel = ask \u0026gt;\u0026gt;= return . sel The Writer Monad Write Monad表示除了计算值以外还产生数据流的计算:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 newtype Writer w a = Writer { runWriter :: (a,w) } instance (Monoid w) =\u0026gt; Monad (Writer w) where return a = Writer (a,mempty) (Writer (a,w)) \u0026gt;\u0026gt;= f = let (a\u0026#39;,w\u0026#39;) = runWriter $ f a in Writer (a\u0026#39;,w `mappend` w\u0026#39;) class (Monoid w, Monad m) =\u0026gt; MonadWriter w m | m -\u0026gt; w where pass :: m (a,w -\u0026gt; w) -\u0026gt; m a listen :: m a -\u0026gt; m (a,w) tell :: w -\u0026gt; m () instance (Monoid w) =\u0026gt; MonadWriter w (Writer w) where pass (Writer ((a,f),w)) = Writer (a,f w) listen (Writer (a,w)) = Writer ((a,w),w) tell s = Writer ((),s) listens :: (MonadWriter w m) =\u0026gt; (w -\u0026gt; b) -\u0026gt; m a -\u0026gt; m (a,b) listens f m = do (a,w) \u0026lt;- listen m; return (a,f w) censor :: (MonadWriter w m) =\u0026gt; (w -\u0026gt; w) -\u0026gt; m a -\u0026gt; m a censor f m = pass $ do a \u0026lt;- m; return (a,f) The Continuation monad Continuation Monad表示可以被打断和恢复的计算(没错, 就是continuation):\n1 2 3 4 5 6 7 8 9 10 11 12 -- r is the final result type of the whole computation newtype Cont r a = Cont { runCont :: ((a -\u0026gt; r) -\u0026gt; r) } instance Monad (Cont r) where return a = Cont $ \\k -\u0026gt; k a (Cont c) \u0026gt;\u0026gt;= f = Cont $ \\k -\u0026gt; c (\\a -\u0026gt; runCont (f a) k) class (Monad m) =\u0026gt; MonadCont m where callCC :: ((a -\u0026gt; m b) -\u0026gt; m a) -\u0026gt; m a instance MonadCont (Cont r) where callCC f = Cont $ \\k -\u0026gt; runCont (f (\\a -\u0026gt; Cont $ \\_ -\u0026gt; k a)) k Combining monads Functors和applicatives对于composition都是封闭的, 但两个monad结合却不一定是另一个monad. 一个monad transformer是一个接受monad作为monad作为参数的类型构造器, 类似与一个wrapper(因此很多都是用newtype定义的).\nCompose Compose类型代表着函数结合:\n1 newtype Compose f g a = Compose {getCompose :: f (g a)} deriving (Eq, Show) 这里的f, g不在是普遍意义上的函数, 而是类型构造器. 我们很容易实现Compose的Functor实例:\n1 2 instance (Functor f, Functor g) =\u0026gt; Functor (Compose f g) where fmap f (Compose fga) = Compose $ (fmap . fmap) f fga 容易看到两个Functor结合之后依然可以是一个Functor. 同样的, 我们也可以定义Applicative实例:\n1 2 3 instance (Applicative f, Applicative g) =\u0026gt; Applicative (Compose f g) where pure = Compose . pure . pure Compose fgf \u0026lt;*\u0026gt; Compose fga = Compose $ (\u0026lt;*\u0026gt;) \u0026lt;$\u0026gt; fgf \u0026lt;*\u0026gt; fga 如果我们要定义Compose的Monad实例, 就需要实现(\u0026gt;\u0026gt;=)或:\n1 2 3 (\u0026gt;\u0026gt;=) :: Compose f g a -\u0026gt; (a -\u0026gt; Compose f g b) -\u0026gt; Compose f g b -- 或者通过join来实现\u0026gt;\u0026gt;= join :: Compose f g (Compose f g a) -\u0026gt; Compose f g a 我们总是可以忽略掉外层的Compose, 此时对于join而言, 我们就得打了f g (f g a) -\u0026gt; f g a, 如果存在一个函数aux :: (Monad f, Monad g) =\u0026gt; f (g a) -\u0026gt; g (f a), 那么我们就可以从f g (f g a)中获得f g a, 因为对于f和g而言都有各自的join, 使得 f (f a) -\u0026gt; f a. 然而并不是对于每个monad都存在这样的aux, 例如IO (Maybe a) -\u0026gt; Maybe (IO a)就不存在这样的aux. 因而\u0026quot;Monad do not compose\u0026quot;, 此时我们就需要monad transformer.\nIdentityT 我们已经看到对于任意的两个monad的compose, join并不总是可以的. 因此我们需要限制其中一个monad, 希望它对于另外一个任意的monad的compose总是可行的. 我们从IdentityT开始介绍monad transformer:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 newtype Identity a = Identity {runIdentity :: a} deriving (Eq, Show) instance Functor Identity where fmap f (Identity) = Identity $ f a instance Applicative Identity where pure = Identity Identity f \u0026lt;*\u0026gt; Identity a = Identity $ f a instance Monad Identity where Identity a \u0026gt;\u0026gt;= f = f a newtype IdentityT m a = IdentityT {runIdentityT :: m a} deriving (Eq, Show) instance Functor (IdentityT m) where fmap f (IdentityT ma) = IdentityT $ fmap f ma instance Applicative (IdentityT m) where pure a = IdentityT $ pure a IdentityT mab \u0026lt;*\u0026gt; IdentityT ma = IdentityT $ mab \u0026lt;*\u0026gt; fa instance Monad (IdentityT m) where IdentityT ma \u0026gt;\u0026gt;= f = IdentityT $ ma \u0026gt;\u0026gt;= runIdentityT . f 在这里我们限制了其中一个monad为Identity, 此时可以实现Monad实例, 因为我们有runIdentityT来获取额外的信息. 更一般的, 对于两个有Monad实例的类型f, g, 组合它们最终会止步与f(g (f b)), 而transformer的作用就是限制了g, 使得能够得到f (f b).\nMaybeT 1 newtype MaybeT m a = MaybeT {runMaybeT :: m (Maybe a)} Functor实例和Applicative实例都可以直接从之前的Compose拿过来\n1 2 3 4 5 6 instance (Functor m) =\u0026gt; Functor (MaybeT m) where fmap f (Maybe ma) = MaybeT $ (fmap . fmap) f ma instance (Applicative m) =\u0026gt; Applicative (MaybeT m) where pure = MaybeT . pure . pure MaybeT fab \u0026lt;*\u0026gt; MaybeT mma = MaybeT $ (\u0026lt;*\u0026gt;) \u0026lt;$\u0026gt; fab \u0026lt;*\u0026gt; mma 终于到了Monad实例:\n1 2 3 4 5 6 instance (Monad m) =\u0026gt; Monad (MaybeT m) where (MaybeT ma) \u0026gt;\u0026gt;= f = MaybeT $ do v \u0026lt;- ma case v of Nothing -\u0026gt; return Nothing Just y -\u0026gt; runMaybeT (f y) EitherT EitherT和MaybeT的处理是类似的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 newtype EitherT e m a = EitherT {runEitherT :: m (Either e a)} instance Functor m =\u0026gt; Functor (EitherT e m) where fmap f (EitherT ema) = EitherT $ (fmap . fmap) f ema instance Applicative m =\u0026gt; Applicative (EitherT e m) where pure = EitherT . pure . pure EitherT emab \u0026lt;*\u0026gt; EitherT ema = EitherT $ (\u0026lt;*\u0026gt;) \u0026lt;$\u0026gt; emab \u0026lt;*\u0026gt; ema instance Monad m =\u0026gt; Monad (EitherT e m) where EitherT ema \u0026gt;\u0026gt;= f = EitherT $ do v \u0026lt;- ema case v of Right y -\u0026gt; runEitherT $ f y Left x -\u0026gt; return $ Left x ReaderT ReaderT是常规的Haskell应用中用到最多的transformer\n1 newtype ReaderT r m a = ReaderT {runReaderT :: r -\u0026gt; m a} 不过其处理和MaybeT以及EitherT处理依然是类似的, 注意ReaderT的参数是一个函数.\n1 2 3 4 5 6 7 8 9 10 11 instance Functor m =\u0026gt; Functor (ReaderT r m) where fmap f (ReaderT rma) = ReaderT $ (fmap . fmap) f rma instance Applicative m =\u0026gt; Applicative (ReaderT r m) where pure = ReaderT . pure . pure ReaderT fmab \u0026lt;*\u0026gt; ReaderT rma = ReaderT $ (\u0026lt;*\u0026gt;) \u0026lt;$\u0026gt; fmab \u0026lt;*\u0026gt; rma instance Monad m =\u0026gt; Monad (ReaderT r m) where ReaderT rma \u0026gt;\u0026gt;= f = ReaderT $ \\r -\u0026gt; do a \u0026lt;- rma r runReaderT (f a) r StateT StateT和ReaderT是类似的不过StateT还需要额外处理状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 newtype StateT s m a = StateT {runStateT :: s -\u0026gt; m (a, s)} instance Functor m =\u0026gt; Functor (StateT s m) where fmap f (StateT sma) = StateT $ fmap (\\(a, s1) -\u0026gt; (f a, s1)) . sma -- http://stackoverflow.com/questions/18673525/ instance Monad m =\u0026gt; Applicative (StateT s m) where pure x = StateT $ \\s -\u0026gt; return (x, s) StateT smab \u0026lt;*\u0026gt; StateT sma = StateT $ \\s -\u0026gt; do (fab, s1) \u0026lt;- smab s (a, s2) \u0026lt;- sma s1 return (fab a, s2) instance Monad m =\u0026gt; Monad (StateT s m) where StateT sma \u0026gt;\u0026gt;= f = StateT $ \\s -\u0026gt; do (a, s1) \u0026lt;- sma s runStateT (f a) s1 WriterT和ListT 关于WriterT, 由于State总是能够代替Writer(State既能读又能写), 因此我们并不总是需要Writer. 实际上还有一个RWST将Reader, Writer, State结合起来的更大的类型.\n1 newtype RWST r w s m a = RWST {runRWST :: r -\u0026gt; s -\u0026gt; m (a, s, w)} It’s a bit too easy to get into a situation where Writer is either too lazy or too strict for the problem you’re solving, and then it’ll use more memory than you’d like. Writer can accumulate unevaluated thunks, causing memory leaks. It’s also inappropriate for logging long-running or ongoing programs due to the fact that you can’t retrieve any of the logged values until the computation is complete.\nListT也并不是总需要的, 其实现并不是很快. 而且Streaming库中的pipes和conduit总是能够很好的胜任大部分情况.\n对于任何一个transformer, 我们总是能够从中恢复对应的monad类型, 只需要传入一个Identity类型,例如type Maybe a = MaybeT Indentity a\nLifting 1 2 3 fmap :: Functor f =\u0026gt; (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b liftA :: Applicative f =\u0026gt; (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b liftM :: Monad m =\u0026gt; (a -\u0026gt; b) -\u0026gt; m a -\u0026gt; m b Monad transformer也同样有lift, 其将一个monadic计算放到一个combined monad中.\n1 2 3 4 5 class MonadTrans t where lift :: (Monad m) =\u0026gt; m a -\u0026gt; t m a class (Monad m) =\u0026gt; MonadIO m where liftIO :: IO a -\u0026gt; m a ","permalink":"https://www.sdlinks.net/posts/2019/monad-and-transformers/","summary":"\u003cp\u003eMonad是Haskell中讨论最多的结构, 需要更详细的探讨其相关内容, 即使它对于Haskell而言不是必须的:(.\u003c/p\u003e\n\u003cp\u003e参考: \u003ca href=\"https://wiki.haskell.org/All_About_Monads\"\u003eAll about Monads\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"monad-support\"\u003eMonad Support\u003c/h2\u003e\n\u003cp\u003e除了之前介绍过的一些基本函数, Haskell本身定义了一些辅助函数配合Monad一起使用:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003esequence\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e-- 任意一个fail会导致整个fail\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003esequence\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eMonad\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003esequence\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efoldr\u003c/span\u003e \u003cspan class=\"n\"\u003emcons\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ereturn\u003c/span\u003e \u003cspan class=\"kt\"\u003e[]\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\t\u003cspan class=\"kr\"\u003ewhere\u003c/span\u003e \u003cspan class=\"n\"\u003emcons\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"n\"\u003eq\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;=\u003c/span\u003e \u003cspan class=\"nf\"\u003e\\\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eq\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;=\u003c/span\u003e \u003cspan class=\"nf\"\u003e\\\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"kt\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003esequence_\u003c/code\u003e和\u003ccode\u003esequence\u003c/code\u003e类似但其不返回值, 在只关心序列的副作用时其非常有用.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003esequence_\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eMonad\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"nb\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003esequence_\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eflodr\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nb\"\u003e()\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003emapM\u003c/code\u003e其由\u003ccode\u003esequence\u003c/code\u003e和\u003ccode\u003emap\u003c/code\u003e定义\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emapM\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eMonad\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emapM\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"n\"\u003eas\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esequence\u003c/span\u003e \u003cspan class=\"o\"\u003e$\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"n\"\u003eas\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003emapM_\u003c/code\u003e, 类似的使用\u003ccode\u003esequence_\u003c/code\u003e定义\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emapM_\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eMonad\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"nb\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emapM_\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"n\"\u003eas\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esequence_\u003c/span\u003e \u003cspan class=\"o\"\u003e$\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"n\"\u003eas\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e=\u0026lt;\u0026lt;\u003c/code\u003e是\u003ccode\u003e\u0026gt;\u0026gt;=\u003c/code\u003e调换参数位置的版本\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eMonad\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003ef\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e上面提到的函数都是standard prelude中定义的, Haskell在Control.Monad模块中定义了更多函数.\u003c/p\u003e\n\u003cp\u003e下面是一些列表函数的Monad版本:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efoldM\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efoldM\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eMonad\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efoldM\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"kt\"\u003e[]\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efoldM\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"kt\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003exs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;=\u003c/span\u003e \u003cspan class=\"nf\"\u003e\\\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003efoldM\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"n\"\u003exs\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efilterM\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efilterM\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"kt\"\u003eMonad\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"kt\"\u003eBool\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efilterM\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"kt\"\u003e[]\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ereturn\u003c/span\u003e \u003cspan class=\"kt\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efilterM\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"kt\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003exs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"kr\"\u003edo\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e  \u003cspan class=\"ow\"\u003e\u0026lt;-\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\t\t\t\t\t \u003cspan class=\"n\"\u003eys\u003c/span\u003e \u003cspan class=\"ow\"\u003e\u0026lt;-\u003c/span\u003e \u003cspan class=\"n\"\u003efilterM\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"n\"\u003exs\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                      \u003cspan class=\"n\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kr\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"kr\"\u003ethen\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"kt\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003eys\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"kr\"\u003eelse\u003c/span\u003e \u003cspan class=\"n\"\u003eys\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ezipWithM\u003c/code\u003e和\u003ccode\u003ezipWithM_\u003c/code\u003e\u003c/p\u003e","title":"Monad and Transformers"},{"content":"Semigroup 半群即一个集合以及在之上定义的一个满足结合律的二元运算, 在Haskell中定义为(部分):\n1 2 3 class Semigroup where (\u0026lt;\u0026gt;) :: a -\u0026gt; a -\u0026gt; a {-# MINIMAL (\u0026lt;\u0026gt;) #-} Laws 1 2 -- associativity a \u0026lt;\u0026gt; (b \u0026lt;\u0026gt; c) = (a \u0026lt;\u0026gt; b) \u0026lt;\u0026gt; c Monoid \u0026ldquo;A monoid is a binary associative operation with an identity\u0026rdquo;, 在Haskell中定义为(部分):\n1 2 3 4 5 6 class Monoid m where mempty :: m mappend :: m -\u0026gt; m -\u0026gt; m mconcat :: [m] -\u0026gt; m mconcat = foldr mappend mempty {-# MINIMAL mempty #-} Laws 1 2 3 4 5 6 7 8 -- left identity mappend menpty x = x -- right identity mappend x mempty = x -- associativity mappend x (mappend y z) = mappend (mappend x y) z 这和数学上带幺半群所满足的性质是一致的, 带幺半群即一个包含单位元的半群.\nFunctor Functor最初由逻辑学家Rudolf Carnap在1930s引入, 其接受一个sentence(phrase)作为输入, 并生成一个sentence(phrase)作为输出. Functor在Haskell中定义为(部分):\n1 2 3 4 -- 易见一个Functor的kind必为`* -\u0026gt; *` class Functor f where fmap :: (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b {-# MINIMAL fmap #-} 其中fmap的中缀运算符为\u0026lt;$\u0026gt;.\nLaws 1 2 3 4 5 -- identity fmap id = id -- Composition fmap (f . g) == fmap f . fmap g Functor是可堆叠的(stacked), 对于多个Functor嵌套的类型，可以通过多次复合fmap来获得对应不同层级的fmap:\n1 2 3 4 5 6 7 8 Prelude\u0026gt; :t (fmap . fmap) (fmap . fmap) :: (Functor f1, Functor f2) =\u0026gt; (a -\u0026gt; b) -\u0026gt; f1 (f2 a) -\u0026gt; f1 (f2 b) Prelude\u0026gt; :t (fmap . fmap . fmap) (fmap . fmap . fmap) :: (Functor f1, Functor f2, Functor f3) =\u0026gt; (a -\u0026gt; b) -\u0026gt; f1 (f2 (f3 a)) -\u0026gt; f1 (f2 (f3 b)) 简单的推导:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (.) :: (b -\u0026gt; c) -\u0026gt; (a -\u0026gt; b) -\u0026gt; a -\u0026gt; c fmap :: (m -\u0026gt; n) -\u0026gt; f m -\u0026gt; f n fmap :: (x -\u0026gt; y) -\u0026gt; g x -\u0026gt; g y =\u0026gt; (m -\u0026gt; n) \u0026lt;=\u0026gt; b (f m -\u0026gt; f n) \u0026lt;=\u0026gt; c (x -\u0026gt; y) \u0026lt;=\u0026gt; a (g x -\u0026gt; g y) \u0026lt;=\u0026gt; b =\u0026gt; (m -\u0026gt; n) \u0026lt;=\u0026gt; (g x -\u0026gt; g y) =\u0026gt; m \u0026lt;=\u0026gt; g x and n \u0026lt;=\u0026gt; g y =\u0026gt; (fmap . fmap) \u0026lt;=\u0026gt; a -\u0026gt; c \u0026lt;=\u0026gt; (x -\u0026gt; y) -\u0026gt; (f m -\u0026gt; f n) \u0026lt;=\u0026gt; (x -\u0026gt; y) -\u0026gt; (f g x -\u0026gt; f g y IO Functor Haskell的IO是Haskell关键设计之一, 由于其没有构造器, 因此只能使用IO typeclass所提供的来处理IO a, 其中最简单的处理之一是Functor. 例如:\n1 2 3 4 -- read :: Read a =\u0026gt; String -\u0026gt; a -- getLine :: IO String getInt :: IO Int getInt = fmap read getLine getLine应当看成是获取String的方法(a way to obtain a string), IO不确保副作用会被执行, 而是确保副作用可以被执行. 我们可以用fmap对输入做任何处理:\n1 2 3 Prelude\u0026gt; fmap (+1) getInt 1 2 这和do notation是一致的:\n1 2 3 4 incIt :: IO int incIt = do input \u0026lt;- getInt return (input + 1) Applicative Applicative是monoidal functor, 其在Haskell中定义为(部分):\n1 2 3 4 5 6 7 class Functor f =\u0026gt; Applicative f where pure :: a -\u0026gt; f a (\u0026lt;*\u0026gt;) :: f (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b -- apply {-# MINIMAL pure, ((\u0026lt;*\u0026gt;) | liftA2) #-} -- 定义fmap fmap f x = pure f \u0026lt;*\u0026gt; x Laws 1 2 3 4 5 6 7 8 9 10 11 -- idenitity pure id \u0026lt;*\u0026gt; v = v -- Composition pure (.) \u0026lt;*\u0026gt; u \u0026lt;*\u0026gt; v \u0026lt;*\u0026gt; w = u \u0026lt;*\u0026gt; (v \u0026lt;*\u0026gt; w) -- Homomorphism pure f \u0026lt;*\u0026gt; pure x = pure (f x) -- Interchange u \u0026lt;*\u0026gt; pure y = pure ($ y) \u0026lt;*\u0026gt; u Monad Monad是Haskell中讨论最多的结构, 但严格来讲Monad对于Haskell并不是必须的(Haskell Programming From First Principle p745). 当前的Haskell确实使用Monad来构成和转换IO动作, 但更早的Haskell并不是.\nMonad是applicative functor, 但有一些唯一的特性使得其比applicative或functor更强大, 其在haskell中定义为(部分):\n1 2 3 4 5 6 7 8 class Applicative m =\u0026gt; Monad m where (\u0026gt;\u0026gt;=) :: m a -\u0026gt; (a -\u0026gt; m b) -\u0026gt; m b -- bind (\u0026gt;\u0026gt;) :: m a -\u0026gt; m b -\u0026gt; m b return :: a -\u0026gt; m a {-# MINIMAL (\u0026gt;\u0026gt;=) #-} -- 定义fmap fmap f xs = xs \u0026gt;\u0026gt;= return . f 因此, 任何Monad的实例都必须是Applicative和Functor的实例.\nLaws 1 2 3 4 5 6 7 8 -- left identity return x \u0026gt;\u0026gt;= f = f x -- right identity m \u0026gt;\u0026gt;= return = m -- associativity (m \u0026gt;\u0026gt;= f) \u0026gt;\u0026gt;= g = m \u0026gt;\u0026gt;= (\\x -\u0026gt; f x \u0026gt;\u0026gt;= g) Monad与计算 一种Monad定义了一种计算类型, return用来构造该计算类型的值, bind用来组合这些计算以构建更为复杂的计算. 例如, MaybeMonad定义了可能不返回任何值的计算, 而ListMonad则定义了模糊计算, 即返回结果包含多个值的计算.\nHaskell的do-notation允许使用命令式的风格来写monadic计算, Monad计算的值可以通过\u0026lt;-来\u0026quot;绑定\u0026quot;(do-notation中才能使用), 例如x:xs \u0026lt;- Just [1, 2, 3], x:xs会匹配[1, 2, 3]. 一个do-notation的块也可以使用分号和大括号, 例如do {a \u0026lt;- Just 2; b \u0026lt;- Just 3; ...}. 因此, do-notation很像命令式编程, 虽然其只是语法糖, 例如你可以将x \u0026lt;- expr1写成expr1 \u0026gt;\u0026gt;= \\x -\u0026gt;, 没有绑定的expr2写成expr2 \u0026gt;\u0026gt;= \\_ -\u0026gt;, 可见相比与不使用do-notation, 其要方便很多, 可以说是很甜了.\nHaskell的Monad的定义中还包含了两个函数, fail和\u0026gt;\u0026gt;:\n1 2 3 4 5 fail :: String -\u0026gt; m a fail s = error s (\u0026gt;\u0026gt;) :: m a -\u0026gt; m b -\u0026gt; m b m \u0026gt;\u0026gt; k = m \u0026gt;\u0026gt;= \\_ -\u0026gt; k fail函数在do-block中模式匹配失败时被调用:\n1 2 3 4 5 6 -- fn 1会调用fail直接返回Nothing -- fail _ = Nothing fn :: Int -\u0026gt; Maybe [Int] fn idx = do let l = [Just [1,2,3], Nothing] (x:xs) \u0026lt;- l!!idx -- a pattern match failure will call \u0026#34;fail\u0026#34; return xs MonadPlus 除了上述三条基本的规则以外, 一些Monad还符合额外的规则, 这些Monad有一个mzero和mplus:\n1 2 3 4 5 6 7 -- mzero类似0 -- mplus类似加法 -- \u0026gt;\u0026gt;=类似乘法 mzero \u0026gt;\u0026gt;= f == mzero m \u0026gt;\u0026gt;= \\x -\u0026gt; mzero == mzero mzero `mplus` m == m m `mplus` mzero == m Haskell中这样的Monad可以实例化MonadPlus:\n1 2 3 4 -- 构成了一个加法群 class (Monad m) =\u0026gt; MonadPlus m where mzero :: m a mplus :: m a -\u0026gt; m a -\u0026gt; m a Foldable 对Foldable最恰当的描述应该是其官方文档的描述: \u0026ldquo;class of data structures that can be folded to a summary value\u0026rdquo;, 其在Haskell中定义为(部分):\n1 2 3 4 5 6 class Foldable (t :: * -\u0026gt; *) where fold :: Monoid m =\u0026gt; t m -\u0026gt; m -- Data.Foldable.fold foldMap :: Monoid m =\u0026gt; (a -\u0026gt; m) -\u0026gt; t a -\u0026gt; m foldr :: (a -\u0026gt; b -\u0026gt; b) -\u0026gt; b -\u0026gt; t a -\u0026gt; b foldl :: (b -\u0026gt; a -\u0026gt; b) -\u0026gt; b -\u0026gt; t a -\u0026gt; b {-# MINIMAL foldMap | foldr #-} 另外还有一些基本的操作:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -- List element of a structure from left to right -- import Data.Foldable toList :: Foldable t =\u0026gt; t a -\u0026gt; [a] -- Test whether the structure is empty null :: Foldable t =\u0026gt; t a -\u0026gt; Bool -- Return the size of a finite structure length :: Foldable t =\u0026gt; t a -\u0026gt; Int -- Does the element occur in the structure elem :: (Foldable t, Eq a) =\u0026gt; a -\u0026gt; t a -\u0026gt; Bool -- The lagest element of a non-empty structure maximum :: (Foldable t, Ord a) =\u0026gt; t a -\u0026gt; a -- The least element of a non-empty structure minimum :: (Foldable t, Ord a) =\u0026gt; t a -\u0026gt; a sum :: (Foldable t, Num a) =\u0026gt; t a -\u0026gt; a product :: (Foldable t, Num a) =\u0026gt; t a -\u0026gt; a 一个不明显的例子:\n1 2 Prelude\u0026gt; fmap length Just [1, 2, 4] 1 此处fmap作用在Just :: a -\u0026gt; Maybe a上, 即作用在(-\u0026gt;) a Maybe a上, 而(-\u0026gt;)的fmap = (.)(source), 因此fmap length Just == (length . Just).\nTraversable Traversable依赖于Applicative, 因此也依赖与Functor, 并且是Foldable的升级版:\n1 2 3 4 5 6 7 8 9 10 11 class (Functor t, Foldable t) =\u0026gt; Traversable t where -- mapM is traverse traverse :: Applicative f =\u0026gt; (a -\u0026gt; f b) -\u0026gt; t a -\u0026gt; f (t b) traverse f = sequenceA . fmap f -- Evaluate each action in the structure from left to right -- and collect the results -- sequence is sequenceA sequenceA :: Applicative f =\u0026gt; t (f a) -\u0026gt; f (t a) sequenceA = traverse id {-# MINIMAL traverse | sequenceA #-} Traversable可以用来翻转两个类型构造器, 或者先map在翻转.\nLaws 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- traverse function -- Naturality t . traverse f = traverse (t . f) -- Identity traverse Identity = Identity -- Composition traverse (Compose . fmap g . f) = Compose . fmap (traverse g) . traverse f -- sequenceA function -- Naturality t . sequenceA = sequenceA . fmap t -- Identity sequenceA . fmap Identity = Identity -- Composition sequence . fmap Compose = Compose . fmap sequenceA . sequenceA (-\u0026gt;) r as Functor, Applicative and Monad (-\u0026gt;)通常称为函数箭头或者函数类型构造器, 因此(-\u0026gt;) r的kind为* -\u0026gt; *, 于是其也可以实例化Functor, Applicative以及Monad(Reader):\n1 2 3 4 5 6 7 8 9 10 11 instance Functor ((-\u0026gt;) r) where fmap = (.) instance Applicative ((-\u0026gt;) a) where pure = const (\u0026lt;*\u0026gt;) f g x = f x (g x) liftA2 q f g c = q (f x) (g x) -- Reader also instance Monad ((-\u0026gt;) r) where f \u0026gt;\u0026gt;= k = \\r -\u0026gt; k (f r) r ","permalink":"https://www.sdlinks.net/posts/2019/haskell-algebra/","summary":"\u003ch2 id=\"semigroup\"\u003eSemigroup\u003c/h2\u003e\n\u003cp\u003e半群即一个集合以及在之上定义的一个满足结合律的二元运算, 在Haskell中定义为(部分):\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003eclass\u003c/span\u003e \u003cspan class=\"kt\"\u003eSemigroup\u003c/span\u003e \u003cspan class=\"kr\"\u003ewhere\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"cm\"\u003e{-# MINIMAL (\u0026lt;\u0026gt;) #-}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"laws\"\u003eLaws\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e-- associativity\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"monoid\"\u003eMonoid\u003c/h2\u003e\n\u003cp\u003e\u0026ldquo;A monoid is a binary associative operation with an identity\u0026rdquo;, 在Haskell中定义为(部分):\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003eclass\u003c/span\u003e \u003cspan class=\"kt\"\u003eMonoid\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"kr\"\u003ewhere\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003emempty\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003emappend\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003emconcat\u003c/span\u003e \u003cspan class=\"ow\"\u003e::\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"ow\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003emconcat\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efoldr\u003c/span\u003e \u003cspan class=\"n\"\u003emappend\u003c/span\u003e \u003cspan class=\"n\"\u003emempty\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"cm\"\u003e{-# MINIMAL mempty #-}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"laws-1\"\u003eLaws\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-haskell\" data-lang=\"haskell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e-- left identity\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emappend\u003c/span\u003e \u003cspan class=\"n\"\u003emenpty\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e-- right identity\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emappend\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"n\"\u003emempty\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e-- associativity\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emappend\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emappend\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"n\"\u003ez\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"ow\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emappend\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emappend\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003ez\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这和数学上带幺半群所满足的性质是一致的, 带幺半群即一个包含单位元的半群.\u003c/p\u003e","title":"Haskell Algebra"},{"content":" 多态(polymorphic)最早从19世纪希腊语中引入, 其中poly代表很多(many), morph代表形式(form), 而-ic的后缀表示由\u0026hellip;制成(made of). 因此, 多态意味着\u0026quot;made of many form\u0026quot;, 即有许多形式构成. 因此单态(monomorphic)很容易猜到是\u0026quot;made of one form\u0026quot;. 2019.03.04\n-ary的后缀表示属于或关于(of or pertaining to), 在讨论数学上的元数(arity)时, -ary是公共的后缀, 诸如nullary(零元), unary(一元), binary(二元)等. 2019.03.07\n我发现gnome-terminal下C-;会映射成;,导致我在terminal的emacs中使用快捷键C-x C-;注释行失败.\n网上查阅后发现, 由于gnome-terminal没有C-;的转义序列(escape sequence), 而默认的将其识别为;. 2019.04.13\n紧接3, 我发现在gnome-terminal下emacs无法使用C-;, 又懒的配置term. 于是就重新编译了带有GUI的emacs(./configure --with-gnutls=no --without-pop --with-x), 之后发现其默认会使用Anacnoda的lib, 一开始会报一些libxml2.so: undefined reference to `ucnv_close_58', 之后我将LD_LIBRARY_PATH设置为~/anaconda3/lib之后, 上述错误没有了, 但又报了新的错误libSM.so: undefined reference to `uuid_unparse_lower@UUID_1.0'. 解决方法是不使用Anaconda的lib, 而使用系统的lib(export不包含~/anaconda/bin的PATH, 随后重新configure和make), 具体原因未查明. 2019.04.13\ni3-wm的layout-restore的问题. i3-save-tree生成的json文件无法直接使用, 需要手工修改layout文件, 首先需要包含一个顶层的container, 随后每一个swallows都需要声明class和instance, i3-save-tree会生成class和instance信息, 当然也可以通过xprop获取. 2019.05.01\n硬件之上最重要的两种软件是操作系统和编译器, 操作系统提供处理用户应用和硬件的接口, 编译器负责将高级语言编写的程序翻译成低级语言(相对于硬件而言). 2019.05.20\nTypora is the best markdown editor. 2019.05.24\nc function without a return statement sometimes can return a value, depending on the exact platform. For x86, the vaule should be in eax register, while the correct value will be left in eax.\nregular expression could use to find integer solution of a linear equation, e.g. ^(.*)\\1{A-1}(.*)\\2{B-1} could find an integer solution of equation in the formalization of Ax + By = Z.\nA module allows a collections of objects-subroutines, variables, types, and so on-to be encapsulated in such a way that (1) object inside are visible to each other but (2) objects on the inside may not be visible on the outside unless they are exported, and (3) object on the outside may not be visible on the inside unless they are imported.\n","permalink":"https://www.sdlinks.net/posts/2019/%E6%9D%82%E8%AE%B0/","summary":"\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e多态(\u003cem\u003epolymorphic\u003c/em\u003e)最早从19世纪希腊语中引入, 其中poly代表很多(\u003cem\u003emany\u003c/em\u003e), morph代表形式(\u003cem\u003eform\u003c/em\u003e), 而-ic的后缀表示由\u0026hellip;制成(\u003cem\u003emade of\u003c/em\u003e). 因此, 多态意味着\u0026quot;made of many form\u0026quot;, 即有许多形式构成. 因此单态(\u003cem\u003emonomorphic\u003c/em\u003e)很容易猜到是\u0026quot;made of one form\u0026quot;. 2019.03.04\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e-ary的后缀表示属于或关于(\u003cem\u003eof or pertaining to\u003c/em\u003e), 在讨论数学上的元数(\u003cem\u003earity\u003c/em\u003e)时, -ary是公共的后缀, 诸如nullary(零元), unary(一元), binary(二元)等. 2019.03.07\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e我发现gnome-terminal下\u003ccode\u003eC-;\u003c/code\u003e会映射成\u003ccode\u003e;\u003c/code\u003e,导致我在terminal的emacs中使用快捷键\u003ccode\u003eC-x C-;\u003c/code\u003e注释行失败.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://unix.stackexchange.com/questions/116629/how-do-keyboard-input-and-text-output-work/116630#116630\"\u003e网上\u003c/a\u003e查阅后发现, 由于gnome-terminal没有\u003ccode\u003eC-;\u003c/code\u003e的转义序列(\u003cem\u003eescape sequence\u003c/em\u003e), 而默认的将其识别为\u003ccode\u003e;\u003c/code\u003e. 2019.04.13\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e紧接3, 我发现在gnome-terminal下emacs无法使用\u003ccode\u003eC-;\u003c/code\u003e, 又懒的配置term. 于是就重新编译了带有GUI的emacs(\u003ccode\u003e./configure --with-gnutls=no --without-pop --with-x\u003c/code\u003e), 之后发现其默认会使用Anacnoda的lib, 一开始会报一些\u003ccode\u003elibxml2.so: undefined reference to `ucnv_close_58'\u003c/code\u003e, 之后我将\u003ccode\u003eLD_LIBRARY_PATH\u003c/code\u003e设置为\u003ccode\u003e~/anaconda3/lib\u003c/code\u003e之后, 上述错误没有了, 但又报了新的错误\u003ccode\u003elibSM.so: undefined reference to `uuid_unparse_lower@UUID_1.0'\u003c/code\u003e. 解决方法是不使用Anaconda的lib, 而使用系统的lib(export不包含\u003ccode\u003e~/anaconda/bin\u003c/code\u003e的\u003ccode\u003ePATH\u003c/code\u003e, 随后重新configure和make), 具体原因未查明. 2019.04.13\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ei3-wm的layout-restore的问题. \u003ccode\u003ei3-save-tree\u003c/code\u003e生成的json文件无法直接使用, 需要手工修改layout文件, 首先需要包含一个顶层的container, 随后每一个\u003ccode\u003eswallows\u003c/code\u003e都需要声明\u003ccode\u003eclass\u003c/code\u003e和\u003ccode\u003einstance\u003c/code\u003e, \u003ccode\u003ei3-save-tree\u003c/code\u003e会生成class和instance信息, 当然也可以通过xprop获取. 2019.05.01\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e硬件之上最重要的两种软件是操作系统和编译器, 操作系统提供处理用户应用和硬件的接口, 编译器负责将高级语言编写的程序翻译成低级语言(相对于硬件而言). 2019.05.20\u003c/p\u003e","title":"杂记"},{"content":"在考虑标识符和绑定(bindings)的时候, 关键在于区分标识符和它们所引用的对象, 以及以下事件:\n对象的创建 绑定的创建 所有使用绑定的情况, 诸如引用变量, 子程序, 类型等 停用和重用那些暂时没有用的绑定 绑定的析构(destruction) 对象的析构 绑定的生命周期指的是这个绑定从创建到析构的整个过程, 类似的可以定义对象的生命周期. 通常情况下, 一个对象的生命周期可能会大于对应的绑定的生命周期, 即当 标识符不再引用该对象时, 该对象依然存在(例如在子程序中传入某个对象的引用, 如C++中的\u0026amp;参数). 当然, 一个绑定的生命周期也有可能大于对应对象的生命周期, 虽然这通常被认为是一个BUG.\n对象的生命周期通常与以下内存分配(storage allocation)机制有关:\n静态(static)对象会在程序的整个运行过程中被分配一个绝对地址. 栈(stack)对象随着子程序的调用和返回而被创建以及按照LIFO的顺序析构. 堆(heap)对象可以在任何时候创建和析构, 其额外要求更加通用和昂贵的内存分配算法. 静态分配(static allocation) 静态分配最明显的例子就是全局对象, 当然全局对象不是唯一的例子. 构成程序机器语言翻译的指令也可以认为是静态分配的变量; 数字和字符串的常量当然也是静态分配 的; 另外很多编译器会产生一系列的表用于支持运行时的debug, 动态类型检查, 垃圾回收, 异常处理等, 这些表也都是静态分配的. 静态分配的对象通常希望它们的值 不在变化, 因此经常被分配在被保护的只读的内存中以方便在试图修改其值产生中断并抛出运行时错误.\n在很多语言中,一个具名常量通常要求有一个能够在编译期确定的初始值. 通常这些初始值都被限制在那些已知的常量以及内置的函数. 这些具名常量加上字面常量通常被 叫做表现常量(manifest constants)或者编译期常量(compile-time constants). 在某些语言中(C, Ada), 常量仅仅只是那些无法在elaboration time之后改变的值, 这些值可能依赖与其他在运行时才能确定的值. 这些elaboration-time的常量在作为递归函数的局部变量时必须要分配在栈上. C#显示提供了 声明两种常量的方法, 即const和readonly关键字.\n另外编译器通常对于子程序的某些值采用特定的分配策略:\n参数和返回值, 编译器通常会尽可能的将这些值存在寄存器中. 临时变量, 通常是那些复杂计算过程的中间值, 一个优秀的编译器也会将它们保存在寄存器内. bookkeeping information, 这些通常包含子程序的返回地址. 基于栈的分配(stack-based allocation) 一门语言如果想要支持递归, 那么在局部变量上采用静态分配的策略将不再适用(Fortran90之前不支持递归), 因为需要变量的个数是未知的. 所幸的是递归天然地适用 于栈结构的分配策略. 每一个子程序在运行时都有一个栈帧(frame, 或者称为活动记录, activation record), 包含了传入参数, 局部变量, 临时变量, 以及 bookkeeping信息. 通常传入参数位于帧的顶部, 方便被调用者定位参数, 而其他的布局则依赖于实现. 栈的维护是子程序调用序列的责任, 即调用者在调用前(序言, prologue)和调用后(尾声, epilogue)执行的代码. 通常有一个帧指针(frame pointer)来保存当前帧的地址, 在大多数语言的实现中, 栈都是往地址减 小的方向增长的. 在这样的实现方式下, 局部变量, 临时变量, bookkeeping信息对于帧指针有一个负的偏移, 而传入参数和返回对于帧指针则有一个正的偏移, 因为 这些都保存在调用者的帧上.\n即时没有递归的语言也可以从基于栈的分配中获益, 因为大多数语言的子程序都无法在同一个时间内运行, 如果采用静态分配意味着需要预先分配所有局部变量(运行的与 不运行的), 而基于栈的分配则可以节省很大的空间开销.\n基于堆的分配(heap-based allocation) 堆上的子块(subblock)可以在任何时候分配和释放. 堆对于那些链式数据结构, 以及在运行时会改变大小的对象, 诸如列表, 集合, 通用的字符串等是必须的. 堆上的空间管理策略众多, 主要的原则是在速度和空间上进行权衡. 空间上又可以细分为内部错误(internal fragmentation)与外部错误(external fragmentation), 内部错误发生在一个内存分配算法分配的块比实际对象需要的空间更大, 而外部错误发生在未被使用的空间过于碎片化, 虽然有空间但无法满足实际 对象的需要. 许多内存管理算法都管理一个单链表, 即有堆内未被使用的块组成的可用链表(free list), 初始状态下这个链表只包含一个块即整个堆. first fit 算法会选择满足要求的第一个块, best fit 算法则会遍历整个链表寻找最小的且满足要求的块. 无论采用哪种策略, 如果被选择的块大小比实际需要的更大, 会将块分 成两部分, 返回满足要求的部分而将剩下的部分放回可用链表(如果剩余部分比最小的限制更小的话, 则会产生一个内部错误即不放回而返回一个更大的块). 当某个块 被释放而返回可用链表时, 将检查地址上与其相邻的一边或两边是否也有空闲的块, 如果有的话则将其合并. 直观上来讲, 希望能够有一个的 best fit 的算法能够 尽可能的将更大的块分给更大的对象. 与此同时, 该算法将花费更多的时间, 因为其必须遍历以寻找最合适的块. 并且该算法更倾向于产生更多的碎片. first fit 与 best fit 哪一种能够产生更少的外部错误取决于要求分配大小的分布.\n在管理单个链表的内存算法中, 分配空间所花费的时间与可用块的数量成正比. 为了将这个开销降到常数级, 一些内存管理算法管理包含不同大小的多条链表, 每一个分 配请求都会选择一个合适的标准大小的链表. 实际上, 堆被划分为许多池(pools), 每一个对应一个标准大小, 且划分可以是静态的也可以是动态的. 两种广泛使用 的动态池调整机制包括伙伴系统(buddy system)和斐波那契堆(Fibonacci heap). 在伙伴系统中, 标准大小是2的幂次方序列, 如果请求一个大小为 $2^k$ 的块但不满足时会将一个大小为 $2^{k+1}$的块平分, 其中一个返回而将剩下的放入第k条链表中(标准大小为$2^k$). 当块被释放时, 其将于其可用的\u0026quot;伙伴\u0026quot;(平分 时出现的另一半)合并. 类似的, 斐波那契堆将标准大小序列分成斐波那契数列, 该算法产生内部错误比伙伴系统更少, 因为斐波那契数列增长比2的指数序列更为缓慢.\n外部错误出现的问题在于堆的分配能力总是随着时间下降的. 总存在一个分配序列使得总大小小于堆的大小而堆无法完成所有分配, 为了减少外部错误, 必须要压紧(compact) 堆.\n垃圾回收(garbage collection) 使用堆分配的对象, 在某些语言中(C, C++, Pascal)可以显示释放, 而更多的语言则规定分配的对象将在不再被使用时隐式地释放. 对于这种语言的运行时库(run-time library)必须要提供垃圾回收(garbage collection)机制来识别和回收不可达的对象. 许多函数式语言和脚本语言以及最近的命令式(imprerative, 指广泛意义上的)语言, 如Java, Modula-3和C#都提供了垃圾回收. 支持显示释放的传统观点包括实现更简单以及执行更高效, 即使是一个简单(naive)的自动垃圾 收集对于一个类型系统丰富的语言来说也会增加不小的复杂度, 另外即时是一个复杂的(sophisticated)的垃圾收集器也需要一个非常数的开销. 因此, 如果程序员 能够正确的界定一个对象的生命周期, 那么就不需要额外的运行时负担且能达到更高的效率. 而支持自动垃圾收集的观点则更为引人注目(compelling): 人为的释放 错误在现实世界中广泛存在并常常导致BUG, 如果一个对象释放的太早则会导致一个悬挂引用(dangling reference), 访问一个被另外对象所使用的空间; 相反 如果释放的过迟则可能会导致内存泄露问题, 最终甚至耗尽堆内存. 臭名昭著的释放内存错误难以定位和修复, 随着前沿程序的复杂性以及体积与日俱增, 能够从自动垃圾 收集中收获更大的益处.\n","permalink":"https://www.sdlinks.net/posts/2018/object-lifetime-and-storage-management/","summary":"\u003cp\u003e在考虑标识符和绑定(\u003cem\u003ebindings\u003c/em\u003e)的时候, 关键在于区分标识符和它们所引用的对象, 以及以下事件:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e对象的创建\u003c/li\u003e\n\u003cli\u003e绑定的创建\u003c/li\u003e\n\u003cli\u003e所有使用绑定的情况, 诸如引用变量, 子程序, 类型等\u003c/li\u003e\n\u003cli\u003e停用和重用那些暂时没有用的绑定\u003c/li\u003e\n\u003cli\u003e绑定的析构(\u003cem\u003edestruction\u003c/em\u003e)\u003c/li\u003e\n\u003cli\u003e对象的析构\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e绑定的生命周期指的是这个绑定从创建到析构的整个过程, 类似的可以定义对象的生命周期. 通常情况下, 一个对象的生命周期可能会大于对应的绑定的生命周期, 即当\n标识符不再引用该对象时, 该对象依然存在(例如在子程序中传入某个对象的引用, 如C++中的\u003ccode\u003e\u0026amp;\u003c/code\u003e参数). 当然, 一个绑定的生命周期也有可能大于对应对象的生命周期,\n虽然这通常被认为是一个BUG.\u003c/p\u003e\n\u003cp\u003e对象的生命周期通常与以下内存分配(\u003cem\u003estorage allocation\u003c/em\u003e)机制有关:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e静态(\u003cem\u003estatic\u003c/em\u003e)对象会在程序的整个运行过程中被分配一个绝对地址.\u003c/li\u003e\n\u003cli\u003e栈(\u003cem\u003estack\u003c/em\u003e)对象随着子程序的调用和返回而被创建以及按照LIFO的顺序析构.\u003c/li\u003e\n\u003cli\u003e堆(\u003cem\u003eheap\u003c/em\u003e)对象可以在任何时候创建和析构, 其额外要求更加通用和昂贵的内存分配算法.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"静态分配static-allocation\"\u003e静态分配(\u003cem\u003estatic allocation\u003c/em\u003e)\u003c/h2\u003e\n\u003cp\u003e静态分配最明显的例子就是全局对象, 当然全局对象不是唯一的例子. 构成程序机器语言翻译的指令也可以认为是静态分配的变量; 数字和字符串的常量当然也是静态分配\n的; 另外很多编译器会产生一系列的表用于支持运行时的debug, 动态类型检查, 垃圾回收, 异常处理等, 这些表也都是静态分配的. 静态分配的对象通常希望它们的值\n不在变化, 因此经常被分配在被保护的只读的内存中以方便在试图修改其值产生中断并抛出运行时错误.\u003c/p\u003e\n\u003cp\u003e在很多语言中,一个具名常量通常要求有一个能够在编译期确定的初始值. 通常这些初始值都被限制在那些已知的常量以及内置的函数. 这些具名常量加上字面常量通常被\n叫做表现常量(\u003cem\u003emanifest constants\u003c/em\u003e)或者编译期常量(\u003cem\u003ecompile-time constants\u003c/em\u003e). 在某些语言中(C, Ada), 常量仅仅只是那些无法在elaboration\ntime之后改变的值, 这些值可能依赖与其他在运行时才能确定的值. 这些elaboration-time的常量在作为递归函数的局部变量时必须要分配在栈上. C#显示提供了\n声明两种常量的方法, 即\u003ccode\u003econst\u003c/code\u003e和\u003ccode\u003ereadonly\u003c/code\u003e关键字.\u003c/p\u003e\n\u003cp\u003e另外编译器通常对于子程序的某些值采用特定的分配策略:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e参数和返回值, 编译器通常会尽可能的将这些值存在寄存器中.\u003c/li\u003e\n\u003cli\u003e临时变量, 通常是那些复杂计算过程的中间值, 一个优秀的编译器也会将它们保存在寄存器内.\u003c/li\u003e\n\u003cli\u003e\u003cem\u003ebookkeeping information\u003c/em\u003e, 这些通常包含子程序的返回地址.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"基于栈的分配stack-based-allocation\"\u003e基于栈的分配(\u003cem\u003estack-based allocation\u003c/em\u003e)\u003c/h2\u003e\n\u003cp\u003e一门语言如果想要支持递归, 那么在局部变量上采用静态分配的策略将不再适用(Fortran90之前不支持递归), 因为需要变量的个数是未知的. 所幸的是递归天然地适用\n于栈结构的分配策略. 每一个子程序在运行时都有一个栈帧(\u003cem\u003eframe\u003c/em\u003e, 或者称为活动记录, \u003cem\u003eactivation record\u003c/em\u003e), 包含了传入参数, 局部变量, 临时变量, 以及\nbookkeeping信息. 通常传入参数位于帧的顶部, 方便被调用者定位参数, 而其他的布局则依赖于实现. 栈的维护是子程序调用序列的责任, 即调用者在调用前(序言,\n\u003cem\u003eprologue\u003c/em\u003e)和调用后(尾声, \u003cem\u003eepilogue\u003c/em\u003e)执行的代码. 通常有一个帧指针(\u003cem\u003eframe pointer\u003c/em\u003e)来保存当前帧的地址, 在大多数语言的实现中, 栈都是往地址减\n小的方向增长的. 在这样的实现方式下, 局部变量, 临时变量, bookkeeping信息对于帧指针有一个负的偏移, 而传入参数和返回对于帧指针则有一个正的偏移, 因为\n这些都保存在调用者的帧上.\u003c/p\u003e","title":"Object Lifetime and Storage Management"},{"content":"The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be included in any interface of an operating system:\ncreate destroy wait miscellaneous control, most OS provide some kind of method to suspend a process and resume it. status, there are usually interfaces to get some status information about a process. The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address space of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to do before running the process. Some memory must be allocated for the program\u0026rsquo;s run-time stack, and the OS may also allocate smoe memory for the program\u0026rsquo;s heap. Also, the os will do some other intialization tasks, particularly as related to I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error.\nAt any time a process may be running, ready or blocked. Being moved from ready to running means the process has been scheduled and descheduled in contrast. Once a process has become blocked, the OS will keep it as such until some event occurs; at that point, the process moves to the ready state again.\nThe OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. For example, the tracked information about each process in xv6 kernel is shown below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // the registers xv6 will save and restore to stop and subsequently restart a process struct context { int eip; int esp; int ebx; int ecx; int edx; int esi; int edi; int ebp; }; // the different states a process can be in enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; // the information xv6 tracks about each process including its register context and state struct proc { char *mem; // Start of process memory uint sz; // Size of process memory char *kstack; // Bottom of kernel stack for this process enum proc_state state; // Process state int pid; // Process ID struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory struct context context; // Switch here to run process struct trapframe *tf; // Trap frame for the current interrupt }; Process API Unix presents one of the most intriguing ways to create a new process with a pair of system calls: fork() and exec(). wait() can be used by a process wishing to wait for a process it has created to complete.\nThe fork() creates a process as an(almost) exact copy of the calling process, that means that to the OS, it now looks like there are two copies of the program(the caller) running, and both are about to return from the fork() system call. The newly-created process doesn\u0026rsquo;t run the main() again, instead it just comes into life as if it had called fork() itself. To distinguish parent and child, the fork() return non-negative PID in parent process, and return 0 in child process, and if it return a negative number, that means it failed. Now there are now two active processes in the system after calling fork, and it\u0026rsquo;s non-determinism to know which runs first.\nSometimes, it\u0026rsquo;s useful for a parent to wait a child process to finish what it has been doing, this is accomplished with the wait() system call. the process calls wait() to delay its execution, most until the child has run and exited. When wait() return into parent, returns the PID of child.\nBy giving a name of an executable to exec()(i.e. execvp), it loads code from that executable and overwrites its current code segment with it. The heap and stack and other parts of the memory space of the program are re-initialized. Then the OS simply runs that program, passing in any arguments as the argv of that process. Thus it does not create a new process, rather, it transforms the currently running program into a different running program. A successful call to exec never returns.\nThe spearation of fork() and exec() is essential in building a Unix shell, because it lets the shell run code after the call to fork() but before the call to exec(). For example, shell can redirect the output from stdout to a new file. The way the shell accomplishes this task is quite simple: when the child is created, before calling exec(), the shell closes standard output and open the file, thus any output from the soon-to-be-running program are sent to the file instead of the screen. This works because Unix system start looking for free file descriptors at zero, in this case, STDOUT_FILENO will be the first available one and thus get assigned when open() is called. Subsequent writes by the child process to the standard output file descriptor(i.e. printf) will then be routed transparently to the newly-opened file.\nLimited Direct Execution In order to virtualize the CPU, the operating system needs to somehow share the physical CPU among many jobs running seemingly at the same time. The basic idea is simple: run one process for a little while, then run another one, and so forth.\nTo make a program run as fast as one might expect, not surprisingly OS developers came up with a technique, which we call limited direct execution. The direct execution means run the program directly on the CPU, but only \u0026ldquo;direct execution\u0026rdquo; is not enough, the OS need to prevent what we don\u0026rsquo;t want it to do, thus we need \u0026ldquo;limited\u0026rdquo;.\nThere are two phases in the limited direct execution protocol. In the first(at boot time), the kernel initializes the trap table, and the CPU remembers its location for subsequent use. The kernel does so via a privileged instruction. In the second(when running a process), the kernel sets up a few things before using a return-from-trap instruction to start the execution of the process; this switches the CPU to user mode and begins running the process. When the process wishes to issue a system call, it traps back into the OS, which handles it and once again returns control via a return-from-trap to the process. The process then completes its work, and returns from main(); this usually will return into some stub code which will properly exit the program. At this point, the OS cleans up and we are done.\nIf a process is running on the CPU, this means the OS is not running. So there is a problem that how can OS regain control of the CPU so that it can switch between processes. One old way is waiting system call but the OS can not do much at all if the process refuses to make system call. Another way is to add a timer interrupt, a timer device can be programmed to raise an interrupt every so many milliseconds; when the interrupt is raised, the currently running process is halted, and a pre-configured interrupt handler in the OS runs. At this point, the OS has regained control of the CPU.\nScheduling Policies There are many scheduling algorithms, such as FIFO(first in first out), STCF(shortest time-to-completion first). Choosing which algorithm dependent on which metrics are used. One most well-known approaches to scheduling, known as the Multi-level feedback queue. The MLFQ has a number of distinct queues, each assigned a different priority level. At any given time, a job that is ready to run is on a single queue. And a job with higher priority is chosen to run first. If two jobs have the same priority, we can use round-robin scheduling. The key to MLFQ scheduling therefore lies in how scheduler sets priorities. Rather than giving a fixed priority to each job, MLFQ varies the priority of a job based on its observed behavior. If, for example, a job repeatedly relinquishes the CPU while waiting for input from the keyboard, MLFQ will keep its priority high, as this is how an interactive process might behave.\nMLFQ first assumes the arrived job as a short job, thus giving the job high priority. If it actually is a short job, then it runs quickly and complete, if not, MLFQ slowly move down its priority. And a simple MLFQ rules may be:\nIf Priority(A) \u0026gt; Priority(B), A runs. If Priority(A) = Priority(B), A\u0026amp;B run in round-robin. when a job enters the system, it is placed at the highest priority. Once a job uses up its time allotment at a given level, its priority is reduced. after some time period S, move all the jobs in the system to the topmost queue. Another scheduling policy is lottery scheduling as a proporitional-share scheduling, the basic idea is simple: every so often, hold a lottery to determine which process should get to run next; process that should run more often should be given more chances to win the lottery(to be continued).\n","permalink":"https://www.sdlinks.net/posts/2018/process/","summary":"\u003cp\u003eThe abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be\nincluded in any interface of an operating system:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ecreate\u003c/li\u003e\n\u003cli\u003edestroy\u003c/li\u003e\n\u003cli\u003ewait\u003c/li\u003e\n\u003cli\u003emiscellaneous control, most OS provide some kind of method to suspend a process and resume it.\u003c/li\u003e\n\u003cli\u003estatus, there are usually interfaces to get some status information about a process.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe first thing that the OS must do to run a program is to load its code and any static data into memory, into the address\nspace of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to\ndo before running the process. Some memory must be allocated for the program\u0026rsquo;s \u003cem\u003erun-time stack\u003c/em\u003e, and the OS may also\nallocate smoe memory for the program\u0026rsquo;s heap. Also, the os will do some other intialization tasks, particularly as related\nto I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error.\u003c/p\u003e","title":"进程"},{"content":"Amortization Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about the running time of any individual operation.\nFor instance, given a sequence of n operations, we may wish to bound the total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might be satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n). This freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and faster than worst-case solutions with equivalent bounds.\nTo provide an amortized bound, one defines the amortized cost of each operation and then proves that, for any sequence of operations, the total amortized cost of the operations in an upper bound on the total actual cost, $$ \\sum_{i=1}^m a_i \\geq \\sum_{i=1}^m t_i $$ where $ a_i $ is the amortized cost of operation i, $t_i$ is the actual cost of operation i, and m is the total number of operations. Usually, in fact, one proves a slightly strong result: that at any intermediate stage in a sequence of operations, the accumulated amortized cost is an upper bound on the accumulated actual cost, $$ \\sum_{i=1}^j a_i \\geq \\sum_{i=1}^j t_i $$ for any j. The difference between the accumulated amortized costs and the accumulated actual costs is called the accumulated savings. Thus, the accumulated amortized costs are an upper bound on the accumulated actual costs whenever the accumulated saving is non-negative.\nAmortization allows for occasional operations to have actual costs that exceed their amortized costs, such operations are called expensive, while the operations whose actual costs are less than their amortized costs are called cheap. It\u0026rsquo;s easy to see that expensive operations decrease the accumulated saving and cheap operations increase it. The key to proving amortized bounds is to show that expensive operations occur only when the accumulated saving are sufficient to cover the remaining cost.\nThere are two techniques for analyzing amortized data structures: the banker\u0026rsquo;s method and the physicist\u0026rsquo;s method. In the banker\u0026rsquo;s method, the accumulated saving are represented as credits that are associated with individual locations in the data structure. These credits are used to pay for future accesses to these locations. The amortized cost of any operation is defined to be the actual cost of the operation plus the credits allocated by the operation minus the credits spent by the operation: $$ a_i = t_i + c_i - \\bar{c_i} $$ where $ c_i $ is the number of credits allocated by operation i and $\\bar{c_i}$ is the number of credits spent by operation i. Every credit must be allocated before it is spent, and no credit may be spent more than once. Therefore, $\\sum c_i \\geq \\sum \\bar{c_i}$ which in turn guarantees that $\\sum a_i \\geq \\sum t_i$, as desired. Proofs using the banker\u0026rsquo;s method typically define a credit invariant that regulates the distribution of credits in such a way that, whenever an expensive operation might occur, sufficient credits have been allocated in the right locations to cover its cost.\nIn the physicist\u0026rsquo;s method, one describes a function $\\Phi$ that maps each object d to a real number called the potential of d. The function $\\Phi$ is typically chosen so that the potential is initially zero and is always non-negative. Then the potential represents a lower bound on the accumulated savings.\nLet d_i be the output of operation i and input of operation i + 1. Then the amortized cost of operation i is defined to be the actual cost plus the change in potential between $d_{i-1}$ and $d_i$: $$ a_i = t_i + \\Phi(d_i) + \\Phi(d_{i-1}) $$ so, the accumulated actual costs of the sequence of operations are: $$ \\sum_{i=1}^j t_i = \\sum_{i=1}^j a_i + \\Phi(d_0) - \\Phi(d_j) $$ Provided $\\Phi$ is chosen in such a way that $\\Phi(d_0)$ is zero and $\\Phi(d_j)$ is non-negative, then we conclude that the accumulated amoritized costs are an upper bound on the accumulated actual costs.\nQueue We illustrate the banker\u0026rsquo;s and physicist\u0026rsquo;s methods by analyzing a simple functional implementation of the FIFO queue abstraction as:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 module type Queue = sig type \u0026#39;a t val empty : \u0026#39;a t val isEmpty : \u0026#39;a t -\u0026gt; bool (** snoc means \u0026#34;cons on the right\u0026#34; *) val snoc : \u0026#39;a -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;a t val head : \u0026#39;a t -\u0026gt; \u0026#39;a val tail : \u0026#39;a t -\u0026gt; \u0026#39;a t end The most common implementation of queues in a purely functional setting is a pair of lists, front contains the front elements of the queue in the correct order and rear contains the rear elements of the queue in reverse order:\ntype \u0026#39;a t = \u0026#39;a list * \u0026#39;a list in this representation, the head of the queue is the first element of front, and the last element of the queue is the first element of rear, so the remains can implement straightforward:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let head = function | [], _ -\u0026gt; raise Empty | x :: tl, _ -\u0026gt; x let checkf = function | [], rear -\u0026gt; (List.rev rear, []) | queue -\u0026gt; queue let tail = function | [], _ -\u0026gt; raise Empty | x :: tl, rear -\u0026gt; checkf (tl, rear) let snoc x = function | (front, rear) -\u0026gt; checkf (front, x :: rear) Here we use the auxiliary function checkf so that we check if the front is empty and then reverse the rear as the new front. Notice that, if front were empty when rear was not, then the first element of the queue would be the last element of rear, which would take O(n) time to access. By maintaining this invariant, we guarantee that head can always find the first element in O(1) time, and we also know that if the front is empty, then so is rear.\nNow we show that snoc and tail both take O(1) amortized time using either the banker\u0026rsquo;s method or the physicist\u0026rsquo;s method, though tail takes O(n) time in the worse-case. Using the banker\u0026rsquo;s method, we maintain a credit invariant that every element in the real list is assiciated with a single credit. Every snoc into a non-empty queue takes one actual step and allocates a credit to the new element of the rear list, for an amortized cost of two. Every tail that does not reverse the rear list, takes one actual step and neither allocates nor spends any credits, for an amortized cost of one. Finally, every tail that does reverse the rear list takes $ m+1 $ actual steps, where m is the length of the rear list, and spends the m credits contained by that list, for an amortized cost of $ m + 1 - m = 1 $.\nUsing the physicist\u0026rsquo;s method, we define the potential function $\\Phi$ to be the length of the rear list. Then every snoc into a non-empty queue takes one actual step and increases the potential by one, for an amortized cost of two. Every tail that does not reverse the rear list takes one actual step and leaves the potential unchanged, for an amortized cost of one. Finally, every tail that does reverse the rear list takes $m + 1$ actual steps and sets the new rear list to [], decreasing the potential by m, for an amortized cost of $ m+1-m = 1 $\nSplay heaps Splay trees are perhaps the most famous and successful of all amortized data structure. Splay trees are a close relative of balanced binary search trees, but they maintain no explicit balance information. Instead, every operation blindly restructures the tree using some simple transformations that tend to increase balance. Although any individual operation can take as much as O(n) time, but every operation runs in O(log n) amortized time. A major difference between splay trees and balanced binary search trees such as the red-black trees is that splay trees are restructured even during queries instead of only during updates. This property makes it awkward to use splay trees to implement abstractions such as sets or finite maps in a purely functional setting, because the query would have to return the new tree along with the answer. For some abstractions, however, the queries are limited enough to avoid these problems. A good example is the heap abstraction, where the only interesting query is findMin. In fact, splay tree make an excellent implementation of heaps.\nThe representation of splay tree in identical to that of unbalanced binary search trees:\n1 type t = Leaf | Node of t * elem * t unlike the unbalanced binary search trees, we allow duplicate elements within a single tree. Unlike the insertion into ordinary binary search trees, we just partition the existing tree into two subtrees, one containing all the elements smaller than or equal to the new element and one in contrast, and then construct a new tree where the root is the new element and other two as its children:\n1 let insert x t = Node (smaller x t, x, bigger x t) and bigger implement as bellow(smaller implement same way):\n1 2 3 4 5 6 7 8 9 10 11 let bigger pivot = function | Leaf -\u0026gt; Leaf | Node (left, v, right) -\u0026gt; if Elem.compare v pivot \u0026lt;= 0 then bigger pivot right else match left with | Leaf -\u0026gt; Node (Leaf, v, right) | Node (left1, v1, right1) -\u0026gt; if Elem.compare v1 pivot \u0026lt;= 0 then Node (bigger pivot right1, v, right) else Node (bigger pivot left1, v1, Node (right1, v, right)) Notice that we restructure the tree to make in more balanced: every time we follow two left branches in a row, we rotate those two nodes. Although, the tree may be still not balance in the usual sense, the new tree will be much more balanced than the original tree. In fact, this is the guiding principle of splay trees: search paths should be restructured to reduce the depth of every node in the path by about half.\nAlso we can combine bigger and smaller as one function partition, which return a pair:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 let rec partition pivot = function | Leaf -\u0026gt; Leaf, Leaf | Node (left, v, right) as tree -\u0026gt; if Elem.compare v pivot \u0026lt;= 0 then match right with | Leaf -\u0026gt; tree, Leaf | Node (left1, v1, right1) -\u0026gt; if Elem.compare v1 pivot \u0026lt;= 0 then let small, big = partition pivot right1 in Node (Node (left, v, left1), v1, small), big else let small, big = partition pivot left1 in Node (left, v, small), Node (big, v1, right1) else match left with | Leaf -\u0026gt; Leaf, tree | Node (left1, v1, right1) -\u0026gt; if Elem.compare v1 pivot \u0026lt;= 0 then let small, big = partition pivot right1 in Node (left1, v1, small), Node (big, v, right) else let small, big = partition pivot left1 in small, Node (big, v1, Node (right1, v, right)) The remains are straightforward:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 (** splayHeap.ml *) open Core module type Heap = sig type t type elem exception Empty val empty : t val isEmpty : t -\u0026gt; bool val insert : elem -\u0026gt; t -\u0026gt; t val merge : t -\u0026gt; t -\u0026gt; t val findMin : t -\u0026gt; elem val deleteMin : t -\u0026gt; t end module Make (Elem : Comparable) : (Heap with type elem = Elem.t) = struct type elem = Elem.t type t = Leaf | Node of t * elem * t exception Empty let empty = Leaf let isEmpty = function | Leaf -\u0026gt; true | _ -\u0026gt; false let rec partition pivot = function | Leaf -\u0026gt; Leaf, Leaf | Node (left, v, right) as tree -\u0026gt; if Elem.compare v pivot \u0026lt;= 0 then match right with | Leaf -\u0026gt; tree, Leaf | Node (left1, v1, right1) -\u0026gt; if Elem.compare v1 pivot \u0026lt;= 0 then let small, big = partition pivot right1 in Node (Node (left, v, left1), v1, small), big else let small, big = partition pivot left1 in Node (left, v, small), Node (big, v1, right1) else match left with | Leaf -\u0026gt; Leaf, tree | Node (left1, v1, right1) -\u0026gt; if Elem.compare v1 pivot \u0026lt;= 0 then let small, big = partition pivot right1 in Node (left1, v1, small), Node (big, v, right) else let small, big = partition pivot left1 in small, Node (big, v1, Node (right1, v, right)) let insert x t = let left, right = partition x t in Node (left, x, right) let rec merge t1 t2 = match t1, t2 with | Leaf, _ -\u0026gt; t2 | Node (left, v, right), _ -\u0026gt; let small, big = partition v t2 in Node (merge small left, v, merge big right) let rec findMin = function | Leaf -\u0026gt; raise Empty | Node (Leaf, v, _) -\u0026gt; v | Node (left, v, _) -\u0026gt; findMin left let rec deleteMin = function | Leaf -\u0026gt; raise Empty | Node (Leaf, v, right) -\u0026gt; right | Node (Node (Leaf, v1, right1), v2, right2) -\u0026gt; Node (right1, v2, right2) | Node (Node (left1, v1, right1), v2, right2) -\u0026gt; Node (deleteMin left1, v1, Node (right1, v2, right2)) end And the amortized cost of insert and deleteMin run in O(log n) time, proofs are omited.\nA particularly pleasant feature of splay trees is that they naturally adapt to any order that happens to be present in the input data. For example, using splay heaps to sort an already sorted list takes only O(n) time rather than O(nlog n) time. Leftist heaps also share this property, but only for decreasing sequences. Splay heaps excel on both increasing and decreasing sequences, as well as on sequence that are only partially sorted.\nPairing heaps Pairing heaps are simple to implement and perform extremely well in parctice, but they have resisted analysis for over ten years. Pairing heaps are heap-ordered multiway trees, as defined:\n1 type t = Leaf | Node of elem * t list We allow only well-formed trees, in which Leaf never occurs in the child list of Node. Pairing heaps get their name from deleteMin operation. deleteMin discards the root and then merges the children in two passes. The first pass merges children in pairs from left to right. The second pass merges the resulting trees from right to left:\n1 2 3 4 5 6 7 8 let mergePairs = function | [] -\u0026gt; Leaf | [h] -\u0026gt; h | h1 :: h2 :: hs -\u0026gt; merge (merge h1 h2) (mergePairs hs) let deleteMin = function | Leaf -\u0026gt; raise Empty | Node (x, hs) -\u0026gt; mergePairs hs and others are straightforward:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 (** pairing heaps *) open Core module type Heap = sig type t type elem exception Empty val empty : t val isEmpty : t -\u0026gt; bool val insert : elem -\u0026gt; t -\u0026gt; t val merge : t -\u0026gt; t -\u0026gt; t val findMin : t -\u0026gt; elem val deleteMin : t -\u0026gt; t val fromList : elem list -\u0026gt; t end module Make (Elem : Comparable) : (Heap with type elem = Elem.t) = struct type elem = Elem.t type t = Leaf | Node of elem * t list exception Empty let empty = Leaf let isEmpty = function | Leaf -\u0026gt; true | _ -\u0026gt; false let merge h1 h2 = match h1, h2 with | Leaf, _ as h | _ as h, Leaf -\u0026gt; h | Node (v1, hs1), Node (v2, hs2) -\u0026gt; if Elem.compare v1 v2 \u0026lt;= 0 then Node (v1, h2 :: hs1) else Node (v2, h1 :: hs2) let insert x h = merge (Node (x, [])) h let mergePairs = function | [] -\u0026gt; Leaf | [h] -\u0026gt; h | h1 :: h2 :: hs -\u0026gt; merge (merge h1 h2) (mergePairs hs) let findMin = function | Leaf -\u0026gt; raise Empty | Node (x, hs) -\u0026gt; x let deleteMin = function | Leaf -\u0026gt; raise Empty | Node (x, hs) -\u0026gt; mergePairs hs end Notice that findMin, insert and merge all run in O(1) worst-case time, however, deleteMin can take up to O(n) time in the worst case. And deleteMin run in O(log n) amortized time.\nAll amortized data structures we have discussed are tremendously effective in pratice. Unfortunately, they perform a bad in persistence. Let q be the result of inserting n elements into an initially empty queue, so that the front list of q contains only a single element and the rear list contains n - 1 elements. So if we use q persistently by taking tail n times, each call takes n actual steps. And the total actual cost, including the time to build q, is $ n^2 + n $, Thus the operation can not take O(1) amortized time, and this can be solved via lazy evaluation.\nNumerical Representations Consider the usual representations of lists and natural numbers, along with several typical functions on each type:\n1 2 3 4 5 6 7 8 9 type \u0026#39;a list = Nil | Cons of \u0026#39;a * \u0026#39;a list let tail = function | Cons (x, xs) -\u0026gt; xs | _ -\u0026gt; raise Empty let rec append xs ys = match xs with | Nil -\u0026gt; ys | hd :: tl -\u0026gt; Cons (hd, append tl ys) 1 2 3 4 5 6 7 8 9 type nat = Zero | Succ of nat let pred = function | Succ n -\u0026gt; n | Zero -\u0026gt; raise PredZero let rec plus n1 n2 = match n1 with | Zero -\u0026gt; n2 | Succ n -\u0026gt; Succ (plus n n2) Other than the fact that list contain elements and natural numbers do not, these implementations are virtually identical. Binomial heaps exhibit a similar relationship with binary numbers. These examples suggest a strong anology between representations of the number n and representations container objects of size n. Functions on the container strongly resemble arithmetic functions on the number. This analogy can be exploited to design new implementations of container abstractions \u0026ndash; simply choose a representation of natural numbers with certain desired properties and define the function on the container objects accordingly. This design fashion is called numerical representation.\nGiven a positional number system, we can implement a numerical representation based on than number system as a sequence of trees. For example, the binary representation of 73 is 1001001, so a collection of size 73 in a binary numberical representation would contain three trees, of size 1, 8 and 64. Trees in numerical representations typically exhibit a very regular structure, for example, in binary numerical representations, all trees have size that are powers of 2. And there are three common kinds of trees that exhibit this structure are complete binary leaf trees, binomial trees, and pennants. Each tree with rank r has $ 2^r $ element.\nBinary random-access lists A random-access list, also called a one-sided flexible array, is a data structure that supports array-like lookup and update functions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 module type RandomAccessList = sig type \u0026#39;a t val empty : \u0026#39;a t val isEmpty : \u0026#39;a t -\u0026gt; bool val cons : \u0026#39;a -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;a t val head : \u0026#39;a t -\u0026gt; \u0026#39;a val tail : \u0026#39;a t -\u0026gt; \u0026#39;a t val lookup : int -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;a val update : int -\u0026gt; \u0026#39;a -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;a t end We implement random-access lists using a binary numerical representation. A binary random-access list of size n contains a tree for each one in the binary representation of n. We choose the simplest combination of features: complete binary leaf trees and a dense representation:\n1 2 3 type \u0026#39;a tree = Leaf of \u0026#39;a | Node of int * \u0026#39;a tree * \u0026#39;a tree type \u0026#39;a digit = Zero | One of \u0026#39;a tree type \u0026#39;a t = \u0026#39;a digit list The integer in each Node is the size of the tree, this number is redundant. Trees are sorted in increasing order of size, and the order of elements is left-to-right both within and between trees. The maximum number of trees in a list of size n is log(n+1)(all position are one), and the maximum depth of any tree is logn. Inserting an element into a binary random-acess list is analogous to increasing a binary number. The increment function on dense binary numbers like:\n1 2 3 4 let rec inc = function | [] -\u0026gt; One | Zero :: ds -\u0026gt; One :: ds | One :: ds -\u0026gt; Zero :: inc ds Similarly, we first convert the element into a leaf, and then insert the leaf into the list follow the rule of inc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 let size = function | Leaf _ -\u0026gt; 1 | Node (n, _, _) -\u0026gt; n let link t1 t2 = Node (size t1 + size t2, t1, t2) let cons x ts = let rec consTree t = function | [] -\u0026gt; [One t] | Zero :: tl -\u0026gt; One t :: tl | One t1 :: tl -\u0026gt; Zero :: consTree (link t t1) tl in consTree (Leaf x) ts Deleting an element from a binary random-access list is analogous to decrementing a binary number:\n1 2 3 4 let rec dec = function | [One] -\u0026gt; [] | One :: ds -\u0026gt; Zero :: ds | Zero :: ds -\u0026gt; One :: dec ds So the implementation also follow the dec rule:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let rec unconsTree = function | [] -\u0026gt; raise Empty | [One t] -\u0026gt; t, [] | One t :: tl -\u0026gt; t, Zero :: tl | Zero :: tl -\u0026gt; match (unconsTree tl) with | Node (_, t1, t2), ts -\u0026gt; t1, One t2 :: ts | _ -\u0026gt; assert false let head ts = match (unconsTree ts) with | Leaf x, _ -\u0026gt; x | _ -\u0026gt; assert false let tail ts = match (unconsTree ts) with | _, tl -\u0026gt; tl The lookup and update functions do not have analogous arithmetic operations. Rather, they take advantage of the organization of binary random-access lists as logarthmic-length lists of logarthmic-depth trees. Looking up or updating an element is a two stage process, we first search the list for the correct tree, and then search the tree for the correct element. To sum up we have:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 (** randomAccessList.ml *) type \u0026#39;a t = \u0026#39;a digit list and \u0026#39;a digit = Zero | One of \u0026#39;a tree and \u0026#39;a tree = Leaf of \u0026#39;a | Node of int * \u0026#39;a tree * \u0026#39;a tree exception Empty let empty = [] let isEmpty = function | [] -\u0026gt; true | _ -\u0026gt; false let size = function | Leaf _ -\u0026gt; 1 | Node (n, _, _) -\u0026gt; n let link t1 t2 = Node (size t1 + size t2, t1, t2) let cons x ts = let rec consTree t = function | [] -\u0026gt; [One t] | Zero :: tl -\u0026gt; One t :: tl | One t1 :: tl -\u0026gt; Zero :: consTree (link t t1) tl in consTree (Leaf x) ts let rec unconsTree = function | [] -\u0026gt; raise Empty | [One t] -\u0026gt; t, [] | One t :: tl -\u0026gt; t, Zero :: tl | Zero :: tl -\u0026gt; match (unconsTree tl) with | Node (_, t1, t2), ts -\u0026gt; t1, One t2 :: ts | _ -\u0026gt; assert false let head ts = match (unconsTree ts) with | Leaf x, _ -\u0026gt; x | _ -\u0026gt; assert false let tail ts = match (unconsTree ts) with | _, tl -\u0026gt; tl let rec lookupTree i t = match i, t with | 0, Leaf x -\u0026gt; x | i, Node (n, left, right) -\u0026gt; if i \u0026lt; n / 2 then lookupTree i left else lookupTree (i - n / 2) right let rec updateTree i x t =match i, t with | 0, Leaf _ -\u0026gt; Leaf x | i, Leaf _ -\u0026gt; raise Empty | i, Node (n, left, right) -\u0026gt; if i \u0026lt; n / 2 then Node (n, updateTree i x left, right) else Node (n, left, updateTree (i - n / 2) x right) let rec lookup i = function | [] -\u0026gt; raise Empty | Zero :: tl -\u0026gt; lookup i tl | One t :: tl -\u0026gt; if i \u0026lt; size t then lookupTree i t else lookup (i - size t) tl let rec update i x = function | [] -\u0026gt; raise Empty | Zero :: tl -\u0026gt; Zero :: update i x tl | One t :: tl -\u0026gt; if i \u0026lt; size t then One (updateTree i x t) :: tl else One t :: update (i - size t) x tl All operations run in O(logn) worst-case time. But cons, head and tail run in O(logn) not O(1) is one disappointing aspect.\nZeroless representation Currently, head is implemented via a call to unconsTree, this approach yields compact code unconsTree supports both head and tail, but wastes time building lists that are immediately discard by head. For greater efficiency, we should implement head directly. As a special case, head can easily be made to run in O(1) time whenever the first digit is non-zero. So we seek to arrange that the first digit is always non-zero, one more principled solution is to use a zeroless representation, in which binary numbers are constructed from ones and twos instead of zeros and ones:\n1 2 3 4 5 6 7 type nat = digit list and digit = One | Two let inc = function | [] -\u0026gt; [One] | One :: ds -\u0026gt; Two :: ds | Two :: ds -\u0026gt; One :: inc ds And the implementation of random-access list is:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 (** randomAccessListZeroless.ml * the interface is same as RandomAccessList *) type \u0026#39;a t = \u0026#39;a digit list and \u0026#39;a digit = One of \u0026#39;a tree | Two of \u0026#39;a tree * \u0026#39;a tree and \u0026#39;a tree = Leaf of \u0026#39;a | Node of int * \u0026#39;a tree * \u0026#39;a tree let empty = [] let isEmpty = function | [] -\u0026gt; true | _ -\u0026gt; false exception Empty let size = function | Leaf _ -\u0026gt; 1 | Node (n, _, _) -\u0026gt; n let link t1 t2 = Node (size t1 + size t2, t1, t2) let cons x ts = let rec consTree t = function | [] -\u0026gt; [One t] | One t1 :: tl -\u0026gt; Two (t, t1) :: tl | Two (t1, t2) :: tl -\u0026gt; One t :: consTree (link t1 t2) tl in consTree (Leaf x) ts let head = function | One Leaf x :: tl -\u0026gt; x | Two (Leaf x, _) :: tl -\u0026gt; x | _ -\u0026gt; assert false let tail = function | [] -\u0026gt; raise Empty | [One _] -\u0026gt; [] | One _ :: One Node (_, left, right) :: tl -\u0026gt; Two (left, right) :: tl | One _ :: Two (t, Node (_, left, right)) :: tl -\u0026gt; Two (left, right) :: One t :: tl | Two (_, t) :: tl -\u0026gt; One t :: tl | _ -\u0026gt; assert false let rec lookupTree i t = match i, t with | 0, Leaf x -\u0026gt; x | i, Leaf _ -\u0026gt; raise Empty | i, Node (n, left, right) -\u0026gt; if i \u0026lt; n / 2 then lookupTree i left else lookupTree (i - n / 2) right let rec updateTree i x t =match i, t with | 0, Leaf _ -\u0026gt; Leaf x | i, Leaf _ -\u0026gt; raise Empty | i, Node (n, left, right) -\u0026gt; if i \u0026lt; n / 2 then Node (n, updateTree i x left, right) else Node (n, left, updateTree (i - n / 2) x right) let rec lookup i = function | [] -\u0026gt; raise Empty | One t :: tl -\u0026gt; if i \u0026lt; size t then lookupTree i t else lookup (i - size t) tl | Two (t1, t2) :: tl -\u0026gt; if i \u0026lt; size t1 then lookupTree i t1 else if i \u0026lt; size t2 then lookupTree (i - size t1) t2 else lookup (i - size t1 - size t2) tl let rec update i x = function | [] -\u0026gt; raise Empty | (One t as hd) :: tl -\u0026gt; if i \u0026lt; size t then One (updateTree i x t) :: tl else hd :: update (i - size t) x tl | (Two (t1, t2) as hd) :: tl -\u0026gt; if i \u0026lt; size t1 then Two (updateTree i x t1, t2) :: tl else if i \u0026lt; size t2 then Two (t1, updateTree (i - size t1) x t2) :: tl else hd :: update (i - size t1 - size t2) x tl Now the head and tail take O(1) time.\nData-structural bootstrapping The term \u0026ldquo;bootstrapping\u0026rdquo; refers to solving problems via solving simple instance of the same problem. And there are three algorithmic design techniques of data-structural bootstrapping. The first, structural decomposition, involves bootstrapping complete data structures from incomplete data structures. The second, structural abstraction, involves bootstrapping efficient data structures from inefficient data structures. The last bootstrapping data structures with aggregate elements from data structures with atomic elements.\nStructural decomposition Typically structural decomposition involves taking an implementation can handle objects only up to some bound size, and extending it to handle objects of unbounded size. Consider typical recursive datatypes such as lists and binary leaf trees:\n1 2 type \u0026#39;a list = Nil | Cons of \u0026#39;a * \u0026#39;a list type \u0026#39;a tree = Leaf of \u0026#39;a | Node of \u0026#39;a tree * \u0026#39;a tree In some ways, these can be regarded as instances of some bounded size(zero for lists and one fo tree) and a rule for recursively decomposing larger objects into smaller objects until eventually each object is small enough to be handled by the bounded case.\nHowever, both of these definitions are particularly simple that the recursive component in each definition is identical to the type being defined, which called uniformly recursive. In general, we reserve the term structural decomposition to describe recursive data structure that are non-uniform for cases that the recursive component is different from its definition, e.g. type 'a seq = Nil | Cons of 'a * ('a * 'a) seq. But you can not implement structural decomposition directly in ML, althought it allows the definition of non-uniform recursive datatypes. But the type system always disallow the functions on such types like below:\n1 2 3 4 (type illegal) let rec size = function | Nil -\u0026gt; 0 | Cons (x, ps) -\u0026gt; 1 + 2 * size ps Fortunately it is always possible to convert a non-uniform type into a uniform type by introducing a new datatype to collapse the different instances into a single type, for example, we can rewrite the seq as:\n1 2 type \u0026#39;a ep = Elem of \u0026#39;a | Pair of \u0026#39;a ep * \u0026#39;a ep type \u0026#39;a seq = Nil | Cons of \u0026#39;a ep * \u0026#39;a seq Notice that the 'a ep type is isomorphic to binary leaf trees, so the version of 'a seq is equivalent to 'a tree list, though we would tend to think a list of trees differently that we would think of a sequence of pairs \u0026ndash; some algorithms will seem simpler or more natural for one of the representations, and some for the other.\nTo use sequence represent positional number system, we need to represent zero, it\u0026rsquo;s easily corrected by adding another constructor of the type:\n1 2 3 4 type \u0026#39;a seq = | Nil | Zero of (\u0026#39;a * \u0026#39;a) seq | One of \u0026#39;a * (\u0026#39;a * \u0026#39;a) seq Now we can represent the sequence 0\u0026hellip;10 as One(0, One((1, 2), Zero(One((((3, 4), (5, 6)), ((7, 8), (9, 10))), Nil)))), which has 11 elements, written 1101 in binary. The pairs in this type are always balanced. In fact, another way to think of pairs of elements is as complete binary leaf trees. And then we can replement binary random-access lists use this type.\nTries Binary search trees work well when comparisons on the key or element type are cheap. This is true for simple types like integers or characters, but may not be true for aggregate types like strings. A better solution for aggregate types such as string is to choose a representation that takes advantage of the structure of that type. One such representation is tries, also known as a digital search trees.\nA trie is a multiway tree where each edge is labelled with a character. Edges leaving the root of a trie represent the first character of a string, and so on. and if the node is vaild, which means it contains a value, we can mark it as Some x, otherwise None. The critical remaining question is how to represent the edges leaving a node, we can represent edges as a vector, an association list, a binary search tree, or even another trie. But all of these are just finite maps from edges labels to tries. So we can use a given structure Map implementing finite maps over base type:\n1 type \u0026#39;a t = Trie of \u0026#39;a option * \u0026#39;a Map Map.t Thus we can implement Trie as a functor from finiteMap to finiteMap:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 module type FiniteMap = sig type \u0026#39;a t type key exception NotFound val empty : \u0026#39;a t val bind : key -\u0026gt; \u0026#39;a -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;a t val lookup : key -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;a end module Make (Map : FiniteMap) : FiniteMap = struct type key = Map.key list type \u0026#39;a t = Trie of \u0026#39;a option * \u0026#39;a t Map.t exception NotFound let empty = Trie(None, Map.empty) let rec lookup key trie = match key, trie with | [], Trie (None, _) -\u0026gt; raise NotFound | [], Trie (Some x, _) -\u0026gt; x | k :: ks, Trie (_, m) -\u0026gt; lookup ks (Map.lookup k m) let rec bind key x trie = match key, x, trie with | [], x, Trie (_, m) -\u0026gt; Trie (Some x, m) | k :: ks, x, Trie (v, m) -\u0026gt; let t = try Map.lookup k m with NotFound -\u0026gt; empty in let t\u0026#39; = bind ks x t in Trie (v, Map.bind k t\u0026#39; m) end ","permalink":"https://www.sdlinks.net/posts/2018/functional-data-structure-2/","summary":"\u003ch2 id=\"amortization\"\u003eAmortization\u003c/h2\u003e\n\u003cp\u003eImplementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case\nbounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about\nthe running time of any individual operation.\u003c/p\u003e\n\u003cp\u003eFor instance, given a sequence of n operations, we may wish to bound the\ntotal running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might\nbe satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n).\nThis freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and\nfaster than worst-case solutions with equivalent bounds.\u003c/p\u003e","title":"Functional Data Structure 2"},{"content":"Introduction To implement data structure in a functional way, there are two basic problems. First, from the point of view of designing and implementing efficient data structures, functional programming\u0026rsquo;s stricture against destructive updates(i.e. assignments) is a staggering handicap, tantamount to confiscating a master chef\u0026rsquo;s knives.\nImperative data structures often rely on assignments in crucial ways, and so different solutions must be found for functional programs. The second difficulty is that functional data strcutures are expected to be more flexible than their imperative counterparts. In particular, when we update an imperative data structure we typically accept that the old version of the data strcuture will no longer be available, but when we update a functional data structure, we expect that both the old and the new version of the data structure will be available for further processing, this is called persistent, while the other is called ephemeral. And we are not surprised if the persistent version is more complicated and even less efficient that the ephemeral one.\nThe term data structure has at least four distinct, but related, meanings:\nAn abstract data type, that is, a type and a collection of functions on that type, we can refer to this as an abstraction. A concrete realization of an abstract data type, we can refer to this as an implementation, but note that an implentation need not be actualized as code \u0026ndash; a concrete design is sufficient. An instance of a data type, such as a particular list or tree. We can refer to such an instance generically as an object or a version. However, particular data types often have their own nomenclature, for example, we simply refer to stack or queue objects as stacks or queues. A unique identity that is invariant under updates. For example, in a stack-based interpreter, we often speak informally about \u0026ldquo;the stack\u0026rdquo; as if there were only one stack, rather than different versions at different times. We can refer to this identity as a persistent identity. Persistence A distinctive property of functional data structures is that they are always persistent, updating a functional data structure does not destory the existing version, but rather creates a new version that coexists with the old one. Persistence is achieved by coping the affected nodes of a data structure and making all changes in the copy of rather than in the original. Because nodes are never modified directly, all nodes that are unaffected by an update can be shared between the old and new version of the data structure without worrying that a change in one version will inadvertently be visible to the other.\nLists Linked lists are common in imperative programming and ubiquitous in functional programming. And we can define its abstraction as follow:\n1 2 3 4 5 6 7 8 9 10 11 (** userList.mli *) type \u0026#39;a t val empty : \u0026#39;a t val isEmpty : \u0026#39;a t -\u0026gt; bool exception Empty (* the exception does not matter *) val cons : \u0026#39;a -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;a t val head : \u0026#39;a t -\u0026gt; \u0026#39;a val tail : \u0026#39;a t -\u0026gt; \u0026#39;a t It can be implemented trivially using either the built-in type of lists or a custom datatype:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 (** userList.ml *) type \u0026#39;a t = | Nil | Cons of \u0026#39;a * (\u0026#39;a t) let empty = Nil exception Empty let isEmpty = function | Nil -\u0026gt; true | _ -\u0026gt; false let cons(hd, tl) = Cons (hd, tl) let head = function | Nil -\u0026gt; raise Empty | Cons (hd, tl) -\u0026gt; hd let tail = function | Nil -\u0026gt; raise Empty | Cons (hd, tl) -\u0026gt; tl Another common function on the lists is append(@ in ocaml), we denote it as ++, and it\u0026rsquo;s easy to implement it in a O(n) way, while we can implement in a O(1) way in an imperative setting:\n1 2 3 let rec (++) = function | Nil, ys -\u0026gt; ys | Cons (hd, tl), ys -\u0026gt; tl ++ Cons (hd, ys) In functional setting, we have to copy the entire list to keep the persistence so that we are free to continue using the old lists as well as the new list. Although this is undeniably a lot of copying, notice that the second list ys shares the nodes wit the new list. Another function that illustrates these twin concepts of copying and sharing is update, which changes the value of a node at a given index in the list:\n1 2 3 4 let rec update xs idx x = match (xs, idx) with | Nil, _ -\u0026gt; raise Subscript | Cons (hd, tl), 0 -\u0026gt; Cons (x, tl) | Cons (hd, tl), (_ as n) -\u0026gt; Cons (hd, update tl (n - 1) x) Notice that this version of update is not tail call, so we can transform it via CPS:\n1 2 3 4 5 6 7 let rec update xs idx x = let rec updateK xs idx x k = match xs, idx with | Nil, _ -\u0026gt; raise Subscript | Cons (hd, tl), 0 -\u0026gt; k (Cons (x, tl)) | Cons (hd, tl), (_ as n) -\u0026gt; updateK tl (n - 1) x (fun var1 -\u0026gt; Cons (x, var1)) in updateK xs idx x (fun var1 -\u0026gt; var1) so that the tail optimization can be applied.\nBinary search trees Binary search trees provide a good example of the kind of sharing the node with more than one pointer field. And a binary search tree can implement sets or finite maps, whose minimal interfaces as:\n1 2 3 4 5 6 7 8 module type Set = sig type t type elem val empty : t val insert : elem -\u0026gt; t -\u0026gt; t val member : elem -\u0026gt; t -\u0026gt; bool end module type finiteMap = sig\rtype \u0026#39;a t\rtype key\rexception NotFound\rval empty : \u0026#39;a t\rval bind : key -\u0026gt; \u0026#39;a -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;a t\rval lookup : key -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;a (* raise NotFound if key is not found *)\rend where the elem is some fixed type of totally-ordered elements. A more realistic implementation would probably include many additional functions, such as deleting an element or enumerating all elements. An unblanced set via binary search tree can be implemented as:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 open Core module UnbalancedSet(Elem : Comparable) : (Set with type elem = Elem.t) = struct type elem = Elem.t type t = | Leaf | Node of t * elem * t let empty = Leaf exception AlreadyInSet let rec insert x tree = let aux = function | Leaf -\u0026gt; Node (Leaf, x, Leaf) | Node (left, v, right) -\u0026gt; if Elem.compare x v \u0026lt; 0 then Node (insert x left, v, right) else if Elem.compare x v \u0026gt; 0 then Node (left, v, insert x right) else raise AlreadyInSet in try aux tree with AlreadyInSet -\u0026gt; tree let rec member x tree = let rec aux candidate = function | Leaf -\u0026gt; match candidate with | None -\u0026gt; false | Some v -\u0026gt; Elem.compare x v = 0 | Node (left, v, right) -\u0026gt; if Elem.compare x v \u0026lt; 0 then memberHelp candidate left else member (Some v) right in aux None tree end where the Comparable is:\nmodule type Comparable = sig\rtype t\rval compare : t -\u0026gt; t -\u0026gt; int\rend Notice that in the member function, we defined a auxiliary function that take a candidate that less than or equal to the search value such that it take no more than d + 1 comparisons, where d is the depth of the tree, while in a traditional way, we need 2d comparisons in the worst case. And in the insert function, we introduce a AlreadyInSet exception so that it return the tree itself while inserting an existing value to the tree to avoid the extra copying in the situation.\nTo sum up, we keep the persistence via sharing and copying.\nSome Familiar Data Structures in A Functional Setting Although many imperative data structures are difficult or impossible to adapt to a functional setting, some can be adapted quite easily.\nLeftist heaps Sometimes we need efficient access only to the minimum element, a data structure supporting this kind of access is called a priority queue or a heap:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module type Heap = sig type t type elem exception Empty val empty : t val isEmpty : t -\u0026gt; bool val insert : elem -\u0026gt; t -\u0026gt; t val merge : t -\u0026gt; t -\u0026gt; t val findMin : t -\u0026gt; elem val deleteMin : t -\u0026gt; t end Heap can be implemented as heap-ordered trees, in which the element at each node is no large than the elements at its children. Under this ordering, the minimum element in a tree is always at the root. Leftist heaps are heap-ordered binary trees that satisfy the leftist property: the rank of any left child is at least as large as the rank of its right sibling. The rank of node is defined to be the length of its right spine(the rightmost path from the node in question to an empty node). A simple consequence of the leftist property is that the right spine of any node is always the shortest path to an empty node.\nWe define the leftist heap as functor:\n1 2 3 4 5 6 7 8 9 10 11 12 module LeftistHeap (Elem : Comparable) : (Heap with type elem = Elem.t) = struct type elem = Elem.t type t = | Leaf | Node of int * elem * t * t (* rank * value * left * right *) let empty = Leaf let isEmpty = function | Leaf -\u0026gt; true | _ -\u0026gt; false end The key insight behind leftist heaps is that two heaps can be merged by merging their right spines as you would merge two sorted lists, and then swapping the children of nodes along this path as necessary to restore the leftist proerty, this can beimplemented as follow:\n1 2 3 4 5 6 let rec merge h1 h2 = match h1, h2 with | (_ as h), Leaf | Leaf, (_ as h) -\u0026gt; h | Node (_, x1, left1, right1), Node (_, x2, left2, right2) -\u0026gt; if Elem.compare x1 x2 \u0026lt;= 0 then makeTree x1 left1 (merge right1 h2) else makeTree x2 left2 (merge h1 right2) where the makeTree function make a new tree from two tree and a key:\n1 2 3 4 5 6 7 8 let rank = function | Leaf -\u0026gt; 0 | Node (r, _, _, _) -\u0026gt; r let makeTree x h1 h2 = if rank left \u0026gt;= rank right then Node (rank b + 1, x, h1, h2) else Node (rank a + 1, x, h2, h1) Because the length of each right spine is at most logarithmic, merge runs in O(logN) time. And remaining functions are trivial via merge. To sum up, we have:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 (** leftistHeap.ml *) open Core module type Heap = sig type t type elem exception Empty val empty : t val isEmpty : t -\u0026gt; bool val insert : elem -\u0026gt; t -\u0026gt; t val merge : t -\u0026gt; t -\u0026gt; t val findMin : t -\u0026gt; elem val deleteMin : t -\u0026gt; t end module Make (Elem : Comparable) : (Heap with type elem = Elem.t) = struct type elem = Elem.t type t = | Leaf | Node of int * elem * t * t (* rank * value * left * right *) let empty = Leaf let isEmpty = function | Leaf -\u0026gt; true | _ -\u0026gt; false let rank = function | Leaf -\u0026gt; 0 | Node (r, _, _, _) -\u0026gt; r let makeTree x h1 h2 = if rank h1 \u0026gt;= rank h2 then Node (rank h2 + 1, x, h1, h2) else Node (rank h1 + 1, x, h2, h1) let rec merge h1 h2 = match h1, h2 with | (_ as h), Leaf | Leaf, (_ as h) -\u0026gt; h | Node (_, x1, left1, right1), Node (_, x2, left2, right2) -\u0026gt; if Elem.compare x1 x2 \u0026lt;= 0 then makeTree x1 left1 (merge right1 h2) else makeTree x2 left2 (merge h1 right2) let insert x h = merge (Node (1, x, Leaf, Leaf)) h exception Empty let findMin = function | Node (_, x, _, _) -\u0026gt; x | _ -\u0026gt; raise Empty let deleteMin = function | Node (_, x, left, right) -\u0026gt; merge left right | _ -\u0026gt; raise Empty end Binomial heaps Another common implementation of heaps is binomial queues, which we call binomial heaps to avoid confusion with FIFO queues. Binomial heaps are composed of more primitive objects known as binomial trees. Binomial trees are inductively defined as follows:\nA binomial tree of rank 0 is a singleton node A binomial tree of rank k + 1 is formed by linking two binomial trees of rank k, making one tree the leftmost child of the other. So, it is easy to see that a binomial tree of rank r contains exactly $ 2^r $ nodes. Another equivalent definition of binomial trees is : a binomial tree of rank r in a node with r children $ t_1, \\cdots, t_r $, where each $ t_i $ is a binomial tree of rank $ r - i $, so we can represent a node in binomial tree as an element and a list of children as:\n1 type tree = Node of int * elem * (tree list) Each list of children is maintained in decreasing order of rank, and elements are sorted in heap order. Now a binomial heap is a collection of heap-orderd binomial trees in which no two trees have the same rank, this collection is represented as a list trees in increasing order of rank.\n1 type heap = tree list Because each binomial tree contains $ 2^r $ elements and no two trees have the same rank, the trees in a binomial heap of size n correspond exactly to ones in the binary representation of n. For example, the binary representation of 21 is 10101 so a binomial heap of size 21 would contain one tree of rank 0, one of rank 2 and one of rank 4. Note that, just as the binary representation of n contains at most log(n+1) ones, a binomial heap of size n contains at most log(n+1) trees.\nTo insert a new element into a heap, we first create a new binomial tree with rank 0, we then step through the existing trees in increasing order of rank until we find a missing rank, linking trees of equal rank as we go:\n1 2 3 4 5 6 7 8 9 10 11 let rank = function | Node (r, _, _) -\u0026gt; r let rec insertTree t = function | [] -\u0026gt; [t] | hd :: tl as h -\u0026gt; if rank t \u0026lt; rank hd then t :: h else insertTree (link t hd) tl let insert x h = insertTree (Node (0, x, [])) h The worst case is insertion into a heap of size $ n = 2^k - 1 $, requiring a total of k links and $ O(k)=O(log n) $. To merge two heaps, we step through both lists of trees in increasing order of rank, linking trees of equal rank as we go:\n1 2 3 4 5 6 7 8 let rec merge ts1 ts2 = match ts1, ts2 with | [], (_ as ts) | (_ as ts), [] -\u0026gt; ts | hd1 :: tl1, hd2 :: tl2 -\u0026gt; if rank hd1 \u0026lt; rank hd2 then hd1 :: (merge tl1 ts2) else if rank hd2 \u0026lt; rank hd1 then hd2 :: (merge tl2 ts1) else insertTree (link hd1 hd2) (merge tl1 tl2) And the deleteMin and findMin can implement simply by calling an auxiliary function removeMinTree, which find the tree with minimum root and remove it from the list, return both the tree and remaining list, thus we have complete implementation as follow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 (** binomialHeap.ml *) open Core module type Heap = sig type t type elem exception Empty val empty : t val isEmpty : t -\u0026gt; bool val insert : elem -\u0026gt; t -\u0026gt; t val merge : t -\u0026gt; t -\u0026gt; t val findMin : t -\u0026gt; elem val deleteMin : t -\u0026gt; t end module Make (Elem : Comparable) : (Heap with type elem = Elem.t) = struct type elem = Elem.t type tree = Node of int * elem * tree list type t = tree list exception Empty let empty = [] let isEmpty = function | [] -\u0026gt; true | _ -\u0026gt; false let link t1 t2 = match t1, t2 with | Node (r, v1, ts1), Node (_, v2, ts2) -\u0026gt; if Elem.compare v1 v2 \u0026lt;= 0 then Node (r + 1, v1, t2 :: ts1) else Node (r + 1, v2, t1 :: ts2) let rank = function | Node (r, _, _) -\u0026gt; r let root = function | Node (_, v, _) -\u0026gt; v let rec insertTree t = function | [] -\u0026gt; [t] | hd :: tl as ts -\u0026gt; if rank t \u0026lt; rank hd then t :: ts else insertTree (link t hd) tl let insert x ts = insertTree (Node (0, x, [])) ts let rec merge ts1 ts2 = match ts1, ts2 with | [], (_ as ts) | (_ as ts), [] -\u0026gt; ts | hd1 :: tl1, hd2 :: tl2 -\u0026gt; if rank hd1 \u0026lt; rank hd2 then hd1 :: (merge tl1 ts2) else if rank hd2 \u0026lt; rank hd1 then hd2 :: (merge tl2 ts1) else insertTree (link hd1 hd2) (merge tl1 tl2) let rec removeMinTree = function | [] -\u0026gt; raise Empty | [t] -\u0026gt; t, [] | hd :: tl -\u0026gt; match (removeMinTree tl) with | t, ts -\u0026gt; if Elem.compare (root hd) (root t) \u0026lt;= 0 then hd, tl else t, hd :: ts let findMin ts = match (removeMinTree ts) with | t, _ -\u0026gt; root t let deleteMin ts = match (removeMinTree ts) with | Node (_, _, ts1), ts2 -\u0026gt; merge (List.rev ts1) ts2 end And each major operation require O(log n) time in the worst case.\nRed black tree As we know, a simply binary search tree perform very poorly on ordered data, for which any individual operation might take up to O(n) times. The solution to this problem is to keep each tree approximately balanced, which is knwon as balanced binary search tree, and red-black trees are one of the most popular families of balanced binary search tree. A red-black tree is a binary search tree in which every node is colored either red or black. every red-black tree satisfy the following invariants:\nall empty nodes are black no red node has a red child every path from root to an empty node contains the same number of black nodes. Take together, these invariants guarantee that the longest possible path in a red-black tree, one with alternating black and red nodes, is no more than twice as long as the shortest possible path, one with black nodes only. We can simple implement a red-black tree as:\n1 2 type color = Red | Black type t = Empty | Node of (color * t * elem * t) (* for some convenience *) The member function is the same as the function in binary search tree, because it does not care the color of node:\n1 2 3 4 5 6 7 8 let rec member x = function | Empty -\u0026gt; false | Node (_, left, v, right) -\u0026gt; if Elem.compare x v \u0026lt; 0 then member x left else if Elem.compare x v \u0026gt; 0 then member x right else true The insert function need to mantain the two balanced invariants:\n1 2 3 4 5 6 7 8 9 10 11 12 let insert x tree = let rec aux = function | Empty -\u0026gt; Node (Red, Empty, x, Empty) | Node (color, left, v, right) -\u0026gt; if Elem.compare x v \u0026lt; 0 then balance color (aux left) v right else if Elem.compare x v \u0026gt; 0 then balance color left v (aux right) else tree in match (aux tree) with | Node (_, left, v, right) -\u0026gt; Node (Black, left, v, right) | Empty -\u0026gt; Empty (* have no sense except avoid warning *) First, when we create a new node with Empty, we initially color it red. Second we force the final root to be black, regardless of the color. Finally, we replace the calls to the Node constructor in the with the balance function, which acts just as the Node constructor except that it massages its arguments as necessary to enforce the balance invariants.\nColoring the new node red maintains invariant 3, but violate invariant 2 whenever the parent of the new node is red. We allow a single red-red violation at a time, and percolate this violation up the search path toward the root during rebalancing. The balance function detects and repairs each red-red violation when it processes the black parent of the red node with a red child. This black-red-red path can occur in any of four configurations, depending on whether each red node is a left or right child. However, the solution is the same in every case: rewrite the black-red-red path as a red node with two black children:\n1 2 3 4 5 6 7 let balance color left v right = match color, left, v, right with | Black, (Node (Red, Node (Red, a, x, b), y, c)), z, d (* left-left case *) | Black, (Node (Red, a, x, Node (Red, b, y, c))), z, d (* left-right case *) | Black, a, x, (Node (Red, Node (Red, b, y, c), z, d)) (* right-left case *) | Black, a, x, (Node (Red, b, y, Node (Red, c, z, d))) -\u0026gt; (* right-right case *) Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d)) | _ as tuple -\u0026gt; Node tuple And you can see it\u0026rsquo;s much elegant than any version written in imperative setting. After balancing a given subtree, the red root of that subtree might now be the child of another red node. Thus we continue balancing all the way to the top of the tree. At the very top of the tree, we might end up with a red node with a red child, but with no black parent, we handle this case by always recoloring the root to be black. Now we sum it all:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 (** redBlackSet.ml *) open Core module type Set = sig type t type elem val empty : t val insert : elem -\u0026gt; t -\u0026gt; t val member : elem -\u0026gt; t -\u0026gt; bool end module Make (Elem : Comparable) : (Set with type elem = Elem.t) = struct type elem = Elem.t type color = Red | Black type t = Empty | Node of (color * t * elem * t) let empty = Empty let rec member x = function | Empty -\u0026gt; false | Node (_, left, v, right) -\u0026gt; if Elem.compare x v \u0026lt; 0 then member x left else if Elem.compare x v \u0026gt; 0 then member x right else true let balance color left v right = match color, left, v, right with | Black, (Node (Red, Node (Red, a, x, b), y, c)), z, d (* left-left case *) | Black, (Node (Red, a, x, Node (Red, b, y, c))), z, d (* left-right case *) | Black, a, x, (Node (Red, Node (Red, b, y, c), z, d)) (* right-left case *) | Black, a, x, (Node (Red, b, y, Node (Red, c, z, d))) -\u0026gt; (* right-right case *) Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d)) | _ as tuple -\u0026gt; Node tuple let insert x tree = let rec aux = function | Empty -\u0026gt; Node (Red, Empty, x, Empty) | Node (color, left, v, right) -\u0026gt; if Elem.compare x v \u0026lt; 0 then balance color (aux left) v right else if Elem.compare x v \u0026gt; 0 then balance color left v (aux right) else tree in match (aux tree) with | Node (_, left, v, right) -\u0026gt; Node (Black, left, v, right) | Empty -\u0026gt; Empty (* have no sense except avoid warning *) end Even without optimization, this implementation of balanced binary search trees is one of the fastest around. With appropriate optimizations, such as eliminating comparison (we have done this before) and eliminating redundant testing(while recursing on the left child their is no need for red-red violations involving the right child)\n","permalink":"https://www.sdlinks.net/posts/2018/functional-data-structure-1/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eTo implement data structure in a functional way, there are two basic problems. First, from the point of view of designing\nand implementing efficient data structures, functional programming\u0026rsquo;s stricture against destructive updates(i.e. assignments)\nis a staggering handicap, tantamount to confiscating a master chef\u0026rsquo;s knives.\u003c/p\u003e\n\u003cp\u003eImperative data structures often rely on\nassignments in crucial ways, and so different solutions must be found for functional programs. The second difficulty is\nthat functional data strcutures are expected to be more flexible than their imperative counterparts. In particular, when\nwe update an imperative data structure we typically accept that the old version of the data strcuture will no longer\nbe available, but when we update a functional data structure, we expect that both the old and the new version of the data\nstructure will be available for further processing, this is called \u003cem\u003epersistent\u003c/em\u003e, while the other is called \u003cem\u003eephemeral\u003c/em\u003e.\nAnd we are not surprised if the persistent version is more complicated and even less efficient that the ephemeral one.\u003c/p\u003e","title":"Functional Data Structure 1"},{"content":"The Address Space The address space is the abstraction that OS is providing to the running program. The address space of a process contains all of the memory state of the running program. For example, the code of the program, the stack and the heap. In the sight of the program, it loaded into at a particular address and has a potentially very large address space, thus, we say that the OS is virtualizing memory.\nThe major goal of a virtual memory(VM) system is transparency. The OS should implement virtual memory in a way that is invisible to the running program. Another goal of VM is efficiency, the OS should strive to make the virtualization as efficient as possible, both in terms of time and space. Finally, a third VM goal is protection.\nIn running a C program, there are two types of memory that are allocated. The first is called stack memory, and allocations and deallocations of it are managed implicitly by the compiler, for this reason it is sometimes called automatic memory. The second type of memory, called heap memory, where all allocations and deallocations are explicitly handled by the programmer.\nAddress Translation With address translation, the hardware transforms each memory access, changing the virtual address provided by the instruction to a physical address where the desired information is actually located. Thus, on each and every memory reference, an address translation is performed by the hardware to redirect application memory reference to their actual locations in memory. Of cause, the hardware alone cannot virtualize memory, as it jsut provides the low-level mechanism for doing so efficiently. The OS must get involved at key points to set up the hardware so that the correct translations take place, it must thus manage memory, keeping track of which locations are free and which are in use. Once again, the goal of all of this work is to create a beautiful illusion: that the program has its own private memory, where its own code and data reside. While behind the virtual reality lies the ugly physical truth: that many programs are actually sharing memory at the same time, as the CPU switchs between running one program and the next.\nSegmentation The first hardware-based address translation is a simple idea referred to as base and bounds. Specifically, we\u0026rsquo;ll need two hardware registers within each CPU: one is called the base register, and the other the bounds(sometimes called a limit register). When a program starts running, the OS decides where in physical memory it should be loaded and sets the base register to that value. Thus, when any memory reference is generated by the process, it is translated by the processor in the following manner:\nphysical address = virtual address + base And the bounds register is there to help with protection, specifically, the processor will first check that the memory reference is within bounds to make sure it is legal.\nIt\u0026rsquo;s clear to see that the simple approach of using a base and bounds register pair to virtualize memory is wasteful, because there may have a lot of free space between the stack and the heap. To solve this problem, the idea of segmentation was born, instead of having just one base and bounds pair in our MMU(memory manage unit), we just have a base and bounds pair per logical segment of the address space. A segment is just a contiguous portion of the address space of a particular length. To refer which which segment is used, one common approach is adding explicit bit to the address bits to refer which segment is used. For example, if we have the address 1011010101, the top two bit 10 refers to the third segment and the rest refers to the offset. And if we want to spoort backwards-growed memory reference, such as stack, we could add an extra support, the hardware need to know which way the segment grows. And to support sharing, we need to add more information about which segment can be read and write or execute.\nHowever, segmentation raises a number of new issues. The first is what should the OS do on a context switch, the OS must make sure to set up the base and bounds registers correctly before letting the process run again. The second and more important issue is managing free space in physical memory, called external fragmentation, the problem grows when many segments was allocated and each segment might be a different size. Thus the physical memory quickly becomes full of little holes of free space, making it difficult to allocate new segment or to grow existing ones.\nPaging The segmentation chops things up into variabled-sized pieces, unfortunately, the space itselt can become fragmented under this solution. Thus the second approach chopping things into fixed-sized pieces may be worth considering, which is called paging. In this view, the physical memory like an array of fixed-sized slots called page frames. With a full-developed paging approach, the system will be able to support the abstraction of an address space effectively, regardless of how a process uses the address space. Also, paging simplifies free-space management, the OS only need to know which page are free.\nTo record where each virtual page of the address space is placed in physical memory, the OS usually keeps a per-process data structure known as a page table. The major role of the page table is to store address translations for each of the virtual pages of the address space. It is important that the page table is a per-process structures, this means that different processes have different page table.\n","permalink":"https://www.sdlinks.net/posts/2018/address-space/","summary":"\u003ch2 id=\"the-address-space\"\u003eThe Address Space\u003c/h2\u003e\n\u003cp\u003eThe address space is the abstraction that OS is providing to the running program. The address space of a process contains\nall of the memory state of the running program. For example, the code of the program, the stack and the heap. In the sight\nof the program, it loaded into at a particular address and has a potentially very large address space, thus, we say that\nthe OS is \u003cem\u003evirtualizing memory\u003c/em\u003e.\u003c/p\u003e","title":"Address Space"},{"content":"Linking Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into machine code; at load time, when the program is loaded into memory and executed by the loader; and even at run time, by application programs. On modern systems, linking is performed automatically by programs called linkers.\nStatic linking Static linker such as the Unix ld program take as input a collection of relocatable object files and command-line arguments and generate as output a fully linked executable object file that can be loaded and run. To build the executable, the linker must perform two main tasks:\nSymbol resolution. Object files define and reference symbols. The purpose of symbol resolution is to associate each symbol reference with exactly one symbol definition. Relocation. Compilers and assemblers generate code and data sections that start at address 0. The linker relocates these sections by associating a memory location with each symbol definition, and then modifying all of the references to those symbols so that they point to this memory location. Object file Object files are merely collections of blocks of bytes, it comes in three forms:\nRelocatable object file. Contains binary code and data in a form that can be combined with other relocatable object files at compile time to create an executable object file. Executable object file. Contains binary code and datain a form that can be copied directly into momory and executed. Shared object file. A special type of relocatable object file that can be loaded into memory and linked dynamically, at either load time or run time. Modern x86-64 Linux and Unix system use Executable and Linkable Formate(ELF) to format object file, A typical ELF relocatable object file contains the following sections:\n.text: The machine code of the compiled program. .rodata: Read-only data such as the format strings in printf statements, and jump tables for switch statements. .data: Initialized global C variables. .bss: Uninitialized global C variables. This section occupies no actual space in the object file; it is merely a place holder. .symtab: A symbol table with information about functions and global variables that are defined and referenced in the program. .rel.text: A list of locations in the .text section that will need to be modified when the linker combines this object file with others. .rel.data: Relocation information for any global variables that are referenced or defined by the module. .debug: A debugging symbol table with entries for local variables and typedefs defined in the program, global variables defined and referenced in the program, and the original C source file. .line: A mapping between line numbers in the original C source program and machine code instructions in the .text section. .strtab: A string table for the symbol tables in the .symtab and .debug sections, and for the section names in the section headers. The .debug and .line sections only present if the compiler driver is invoked with the -g option.\nSymbol Each relocatable object module m, has a symbol table that contains information about the symbols that are defined and referenced by m. In the context of a linker, there are three different kinds of symbols:\nGlobal symbols that are defined by module m and that can be referenced by other modules. Global linker symbols correspond to nonstatic C functions and global variables that are defined without the C static attribute. externals that are the Global symbols referenced by module m but defined by some other module. Local symbols that are defined and referenced exclusively by module m. Some local linker symbols correspond to C functions and global variables that are defined with the static attribute. These symbols are visible anywhere within module m, but cannot be referenced by other modules. Interestingly, local procedure variables that are defined with the C static attribute are not managed on the stack. Instead, the compiler allocates space in .data or .bss for each definition and creates a local linker symbol in the symbol table with a unique name.\nSymbol tables are built by assemblers, using symbols exported by the compiler into the assembly-language .s file, it contains an array of entries, each entry has the format below:\n1 2 3 4 5 6 7 8 9 typedef struct { int name; /* String table offset */ char type:4, /* Function or data (4 bits) */ binding:4; /* Local or global (4 bits) */ char reserved; /* Unused */ short section; /* Section header index */ long value; /* Section offset, or absolute address */ long size; /* Object size in bytes */ } Elf64_Symbol; The linker resolves symbol references by associating each reference with exactly one symbol definition from the symbol tables of its input relocatable object files. It\u0026rsquo;s much easy to reference local symbols than global symbols.The compiler allows only one definition of each local symbol per module. Overloaded functions in C++ and Java work because the compiler encodes each unique method and parameter list combination into a unique name for the linker, which is known as mangling.\nAt compile time, the compiler exports each global symbol to the assembler as either strong or weak, and the assembler encodes this information implicitly in the symbol table of the relocatable object file. Functions and initialized global variables get strong symbols. Uninitialized global variables get weak symbols. Given this notion of string and weak symbols, Unix linkers use the following rules for dealing with multiply defined:\nMultiple strong symbols are not allowed. Given a strong symbol and multiple weak symbols, choose the strong symbol. Given multiple weak symbols, choose any of the weak symbols. Exceptional Control Flow Exceptions can be divided into four classes: interrupts, traps, faults and aborts.\nInterrupts occur asynchronously as a result of signals from I/O devices that are external to the processor. Exception handlers for hardware interrupts are often called interrupt handlers. After the current instruction finishes executing, the processor notices that the interrupt pin has gone high, reads the exception number from the system bus, and then calls the appropriate interrupt handler. When the handler return, it returns control to next instruction. The remaining classes of exceptions(traps, falusts and aborts) occur synchronously as a result of executing the current instruction. We refer to this instruction as the faluting instruction.\nTraps are intentional exceptions that occur as a result of executing an instruction. The most import use of traps is to provide a procedure-like interface between user programs and the kernel known as system call. From a programmer\u0026rsquo;s perspective, a system call is identical to a regular function call. However, regular functions run in user mode, which restricts the types of instructions they can execute, and they acess the same stack as the calling function, while a system call runs in kernel mode, which allows it to execute instructions, and accesses a stack defined in the kernel.\nFaults result from error conditions that a handler might be able to correct. When a fault occurs, the processor transfers control to the fault handler. If the handler is able to correct the error condition, it returns control to the faulting instruction, thereby reexecuting it. Otherwise, the handler returns to an abort routine in the kernel that terminates the application program that caused the fault.\nAborts result from unrecoverable faltal errors, typically hardware errors.\nx86-64 system has up to 256 different exception types. Numbers in the range from 0 to 31 corresnpond to execeptions that are defined by Intel, while numbers in the range from 32 to 255 correspond to interrupts and traps that are defined by the operating system.\nProcesses Exceptions are the basic building blocks that allow the operating system to provide the notion of a process, one of the most profound and successful ideas in computer science. The classic definition of a process is an instance of a program in execution. A process provides two key abstractions: An independent logical control flow and A private address space.\nUnix provides a number of system calls for manipulating processes from C programs. Each process has a unique positive (nonzero) process ID (PID). The getpid function returns the PID of the calling process. The getppid function returns the PID of its parent. The fork function creates a new running child process. The fork function is called once but returns twice: once in the calling process (the parent), and once in the newly created child process. In the parent, fork returns the PID of the child. In the child, fork returns a value of 0. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main () { pid_t pid; int x = 1; pid = fork(); if (pid == 0) { printf(\u0026#34;child : x=%d\\n\u0026#34;, ++x); exit(0); } printf(\u0026#34;parent: x=%d\\n\u0026#34;, --x); exit(0); } And it\u0026rsquo;s result in Unix system is\nparent: x=0\rchild: x=2 Here you can see the fork function call once, return twice. And the parent and the child are sperate processes that run concurrently, we can never make assumptions about the order of the two process. Those two process also share duplicate but separate address spaces, they both have x equals to 1, but they do different things to x sperately. Also they share files, that means the child process inherits all of parent\u0026rsquo;s open files.\nCommon memory-related bugs in C Dereference bad pointers: If we attempt to dereference a pointer into the unmapped virtual address or the read-only areas and write, the operating system will terminate the program with a segmentation exception. But if the address is legal, then it will never report a problem, which usually cause baffling consequences.\nRead uninitialized memory: While bss memory locations(such as unintialized global C variables) are always initialized to zero by the loader, this is not true for heap memory. You should always zero it explicitly or use calloc.\nAllow stack buffer overflows: A program has a buffer overflow bug if it writes to a target buffer on the stack without examining the size of the input string.\nAssume that pointers and the objects they point to are the same size, It is always incorrect.\nMake off-by-one errors: index out of range.\nReference a pointer instead of the object it points to.\nMisunderstande pointer arithmetic.\nReference nonexistent variables: always means return a pointer point to the local variable.\nReference data in free heap blocks: reference the data after it frees.\nIntroduce memory leaks: memory leaks are particularly serious for programs such as daemons and servers, which by definition never terminate.\nSystem-level I/O A Unix file is a sequence of m bytes: $$ B_0, B_1, \\cdots, B_k, \\cdots, B_{m-1} $$ All I/O devices, such as networks, disks, and terminals, are modeled as files, and all input and output is performed by reading and writing the appropriate files.This elegant mapping of devices to files allows the Unix kernel to export a simple, lowlevel application interface, known as Unix I/O, that enables all input and output to be performed in a uniform and consistent way:\nOpening files. Changing the current file position. Reading and writing files. Closing files. Every Unix file has a type to show their role in system:\nregular file contains any data, applications always need to distinguish between text file and binary file. directory contains a set of links. Each link maps a filename to a file. \u0026ldquo;.\u0026rdquo; links the directory itself, and \u0026ldquo;..\u0026rdquo; links the parent directory. socket is used for cross-network communication. and so on(named pipe, symbolic link). Every process have a current working directory in its context to refer the work location. ","permalink":"https://www.sdlinks.net/posts/2018/computer-system-4/","summary":"\u003ch2 id=\"linking\"\u003eLinking\u003c/h2\u003e\n\u003cp\u003eLinking is the process of collecting and combining various pieces of code and data into a single file that can be loaded\n(copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into\nmachine code; at load time, when the program is loaded into memory and executed by the \u003cem\u003eloader\u003c/em\u003e; and even at run time, by\napplication programs. On modern systems, linking is performed automatically by programs called \u003cem\u003elinkers\u003c/em\u003e.\u003c/p\u003e","title":"Computer System 4"},{"content":"Optimization Writing an efficient program requires several type of activities. First, we must select an appropriate set of algorithms and data structures. Second, we must write source code that the compiler can effectively optimize to turn into efficient executable code. A third technique for dealing with especially demanding computations is to divide a task into portions that can be computed in parallel, on some combination of multiple cores and multiple processors.\nAnd our goal in optimization is to keep modifying the source code in attempt to coax the compiler into generating efficient code. Compared to the alternative of writing code in assembly language, this indirect approach has the advantage that the resulting code will still run on other machines, although perhaps not with peak performance.\nCompilers must be careful to apply only safe optimizations to a program, meaning that the the resulting program will have the exact same behavior as would an unoptimized version for all possible cases the program may encounter.\nThe first problem is the memory aliasing that two pointers designate the same memory location, and in performing only safe optimizations, the compiler must assume that different pointers may be aliased. If a compiler cannot determine whether or not twopointers may be aliased, it must assume that either case is possible, limiting the set of possible optimizations\nA second optimization blocker is due to function calls. It\u0026rsquo;s hard to optimize the function calls with side effect, which modifies some part of the global program state. Most compilers do not try to determine whether a function is free of side effects, instead the compiler assumes the worse case and leaves function calls intact. Among compilers, GCC is considered adequate, but not exceptional.\nWe introduce the metric cycles per element(CPE), CPE measurements help us understand the loop performance of an iterative program at a detailed level. The sequencing of activities by a processor is controlled by a clock providing a regular signal of some frequency, usually expressed in gigahertz(GHz), billions of cycles per second. For example, when product literature characterizes a system as \u0026ldquo;4 GHz\u0026rdquo; processor, it means that the processor clock runs at 4.0E9 cycles per second, and the period of the processor is 0.25 nanoseconds, which is the reciprocal of the clock frequency.\nFor example, consider the two programs of computing the prefix sum of a vector a:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void psum1(float a[], float p[], long n) { long i; p[0] = a[0]; for (i = 1; i \u0026lt; n; i++) { p[i] = p[i - 1] + a[i]; } } void psum2(float a[], float p[], long n) { long i; p[0] = a[0]; for (i = 1; i \u0026lt; n - 1; i += 2) { float mid_val = p[i - 1] + a[i]; p[i] = mid_val; p[i + 1] = mid_val + a[i + 1]; } if (i \u0026lt; n) { p[i] = p[i - 1] + a[i]; } } They takes 368 + 9.0n cycles and 368 + 6.0 cycles, for lagre N the run times will be dominated by the linear factors. We refer to the coefficients in these terms as the effective number of cycle per element, so the first one\u0026rsquo;s CPE is 9.0 and the second one is 6.0.\nModern processors One of the remarkable feats of modern microprocessors is they employ complex and exotic microarchitectures, in which multiple instructions can be executed in parallel, while presenting an operational view of simple sequential instruction execution. There are two different lower bounds characterize the maximum performance of a program. The latency bound is encountered when a series of operations must performed in strict sequence, because the result of one operations is required before the next one can begin. This bound can limit program performance when the data dependencies in the code limit the ability of the processor to exploit instruction-level parallelism. The throughput bound characterizes the raw computing capacity of the processor\u0026rsquo;s functional units. This bound becomes the ultimate limit on program performance.\nTrick code motion: Identify a computation that is performed multiple times but such that the result of the computation will not change, and therefor move the computation to an eailer section of the code that does not get evaluated as often. eliminate unneeded menory reference: For frequent memory reference, it could be improved by introduced a temporary variables instead of using memory referencing(pointer) in a loop. loop unrolling: Reduce the number of iterations for a loop by increasing the number of elements computed on each iteration. It can improve performance in two ways. First, it reduces the number of operations that do not contribute directly to the program result, such as loop indexing and conditional branching. Second, it expose ways in which we can futher transform the code to reduce the number of operations in the cirtical paths of the overall computation. The Memory Hierarchy Random-access memory Random-access memory(RAM) comes in two varieties, static and dynamic. Static RAM(SRAM) is faster and significantly more expensive than dynamic RAM(DRAM). SRAM is used for cache memories, both on and off the CPU chip. DRAM is used for the amin memory plus the frame buffer of a graphics system.\nRead-only memory Read-only memory can retain their information even when they are powered off, while the RAM lose their information if the supply voltage is turned off. flash memory is a type of nonvolstile memory, based on EEPROM(electrically erasable programmable ROM), that has become an important storage rechnology. The solid state disk(SSD), that provides a faster, sturdier and less power-hungry alternative to conventional rotating disk is a new form of flash-based disk driver.\nPrinciple of Locality programs with good locality run faster than programs with poor locality. Locality is typically described as having two distinct forms: temporal locality and spatial locality. In a program with good temporal locality, a memory location that is referenced once is likely to be referenced again multiple times in the near future. In a program with good spatial locality, if a memory location that is referenced once, then the program is likely to reference a nearby memory location in the near future.\nConsider a program of matrix multiplication(C=AxB):\n1 2 3 4 5 6 7 8 for (i = 0; i \u0026lt; n; i++) for (j = 0; j \u0026lt; m; j++) { sum = 0.0; for (k = 0; k \u0026lt; p; k++) { sum += A[i][k] * B[k][j]; } C[i][j] = sum; } if we switch the loop order for j and k:\n1 2 3 4 5 6 7 for (i = 0; i \u0026lt; n; i++) for (k = 0; k \u0026lt; p; j++) { r = A[i][k] for (j = 0; j \u0026lt; m; k++) { C[i][j] += r * B[k][j]; } } these will not change the result, but the second improves efficiency. Because the second has no cache missing.\nPrograms that repeatedly reference the same variables enjoy good temporal locality. For programs with stride-k reference patterns, the smaller the stride the better the spatial locality. Programs with stride-1 reference patterns have good spatial locality. Programs that hop around memory with large strides have poor spatial locality. Loops have good temporal and spatial locality with respect to instruction fetches. The smaller the loop body and the greater the number of loopiterations, the better the locality. ","permalink":"https://www.sdlinks.net/posts/2018/computer-system-3/","summary":"\u003ch2 id=\"optimization\"\u003eOptimization\u003c/h2\u003e\n\u003cp\u003eWriting an efficient program requires several type of activities. First, we must select an appropriate set of algorithms\nand data structures. Second, we must write source code that the compiler can effectively optimize to turn into efficient\nexecutable code. A third technique for dealing with especially demanding computations is to divide a task into portions\nthat can be computed in parallel, on some combination of multiple cores and multiple processors.\u003c/p\u003e","title":"Computer System 3"},{"content":"Assembler Computer execute machine code, sequences of bytes encoding the low-level operations that manipulate data manage memory, read and write data on storage devices, and communicate over networks.\nWe will focus on x86-64, the commonest machine language used in processor with laptop and PC, also it\u0026rsquo;s widely used in supercomputer and lager data center.\nthe x86-64 machine code is much different with the corresponding C code, the processor states below are everywhere:\nprogram counter: called \u0026ldquo;%rip\u0026rdquo;, indicates the address in memory of the next instruction to be executed. the integer register file contains 16 named location storing 64-bit values. the condition code register hold status information about the most recently executed arithmetic or logical instruction. a set of vector registers store one or more integer and floating-point data. for example, the below C code: 1 2 3 4 5 6 7 //mstore.c long mult2(long, long); void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t; } could have the assembly code used by gcc -Og -S mstore.c command:\n//mstore.s\r.file\t\u0026#34;mstore.c\u0026#34;\r.text\r.globl\tmultstore\r.type\tmultstore, @function\rmultstore:\r.LFB0:\r.cfi_startproc\rpushq\t%rbx\r.cfi_def_cfa_offset 16\r.cfi_offset 3, -16\rmovq\t%rdx, %rbx\rcall\tmult2\rmovq\t%rax, (%rbx)\rpopq\t%rbx\r.cfi_def_cfa_offset 8\rret\r.cfi_endproc\r.LFE0:\r.size\tmultstore, .-multstore\r.ident\t\u0026#34;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\u0026#34;\r.section\t.note.GNU-stack,\u0026#34;\u0026#34;,@progbits where the lines beginning with ‘.’ are directives to guide the assembler and linker, we can generally ignore these, thus we obtain(in ATT format distinguish with Intel format):\nmultstore:\rpushq\t%rbx\rmovq\t%rdx, %rbx\rcall\tmult2\rmovq\t%rax, (%rbx)\rpopq\t%rbx\rret Intel use term word to represent 16-bit data types, so it calls 32-bit as double words, and 64-bit as quad words. The table below illsulates the default C data types and its x86-64 representation.\nC declartive Intel data type assembly suffix size(byte) char byte b 1 short word w 2 int double words l 4 long quad words q 8 char* quad words q 8 float single-precision s 4 double double-precision l 8 A x86-64 CPU contains a set of 16 universal destination registers storing 64-bit values. They are: %rax, %rbx, %rcx, %rdx, %rsi, %rdi, %rbp, %rsp(in 32-bit those begin with e, e.g. %eax), %r8 to %r15(in 32-bit those ends with d, e.g. %r9d). It\u0026rsquo;s worth noting that the stack point %rsp, which indicates the address of program finished stack.\nData movement instructions Among the most heavily used instructions are those that copy data from one location to another. The most simplest instructions is the MOV class, cosists of four instructions: movb, movw, movl, movq; they differ only in that they operate on data of size 1, 2, 4 and 8 bytes. In most casees, MOV only update the register and memory address indicated by the operands, but movl will fill the left bit with 0 in a register with a 32-bit data, which is the convention in x86-64. The MOVZ class will always fill the other bit with zero, while the MOVS class fill by sign expansion. MOVS and MOVZ always ends with two characters indicates the size of size, e.g. movzbw moves byte to word with zero expansion. but there no movzlq because it could replaced by movl as we mentioned above. The cltq always moves from %eax to %rax with sign expansion, so it is the same as movslq %eax, %rax.\nThe final two data movement instructions are used to push data onto and pop data from the program stack: pushq and popq. For example to push a quad words onto a stack, first we subtract %rsp(the stack point) with 8(the stack grows from high address to low address) and write the data to the new address of %rsp. Since the stack is contained in the same memory as the program code and other forms of program data, programs can access arbitrary positions within the stack using the standard memory addressing methods.\nArithmetic and logical operations Instruction Effect Description leal S, D D := \u0026amp;S Load effective address INC D D := D + 1 Increment DEC D D := D - 1 Decrement NEG D D := -D Negate NOT D D := ~D Complement ADD S, D D := D + S Add SUB S, D D := D - S Subtract IMUL S, D D := D * S Multiply XOR S, D D := D ^ S Exclusive-or OR S, D D := D | S Or AND S, D D := D \u0026amp; S And SAL k, D D := D \u0026laquo; k Left shift SHL k, D D := D \u0026laquo; k the same as SAL SAR k, D D := D \u0026raquo; k Arithmetic right shift(with sign expansion) SHR k, D D := D \u0026raquo; k Logical right shift(with zero expansion) The load effective address instruction leal is actually a variant of the movl instruction. It just works as the \u0026amp; in C. In addition, it can be used co compactly describe common arithmetic operations, e.g. if register %edx contains value x, then the instruction leal 7(%edx, \u0026amp;edx, 4), %eax will set register %eax to 5x+7. But the destination operand must be a register.\nFor shift operations, the shift amount is given either as an immediate or in the single-byte register element %c1(in %rcx),\nControl Machine code provides two basic low-level mechanisms for implementing coditional behavior: it tests data values and then either alters the control flow or the data flow based on the result of these test. Data-dependent control flow is the more general and more common approach for implementing coditional behavior. The execution order of a set of machine-code instructions can be altered with jump instruction, indicating that control should pass to some other part of the program, possibly contingent on the result of some test.\nIn addition to the integer register, the CPU maintains a set of single-bit condition code register describing attributes of the most rescent arthmetic or logical operation. These register can then be tested to perform conditional branches. The most useful cndition codes are:\nCF: Carry Flag. The most recent operation generated a carry out of the most significant bit. Used to detect overflow for unsigned operations ZF: Zero Flag. The most recent operation yielded zero. SF: Sign Flag. The most recent operation yielded negative value. OF: Overflow Flag. The most recent operation caused a two\u0026rsquo;s-complement overflow, either negative or positive. For example, suppose we used one of the ADD instructions to perform the equivalent of the C assignment t=a+b, where variables a, b, and t are integers. Then the condition codes would be set according to the following C expressions:\nCF: (unsigned) t \u0026lt; (unsigned) a Unsigned overflow ZF: t == 0 Zero SF: t \u0026lt; 0 Negative OF: (a \u0026lt; 0 == b \u0026lt; 0) \u0026amp;\u0026amp; (t \u0026lt; 0 != a \u0026lt; 0) Signed overflow There are two instruction classes that set condition codes without altering any other registers, the CMP class and TEST class. The CMP instructions behave in the same manner as the SUB instructions except that they don\u0026rsquo;t update their destinations. The TEST instructions behave in the same manner as the And instructions except that they don\u0026rsquo;t update their destinations, too.\nRather than reading the condition codes directly, there are three common ways of using the codition code:\nwe can set a single byte to 0 or 1 depending on somecombination of the condition codes we can coditionally jump to some other part og the program, or we can conditionally transfer data. For the first case, there are SET class instructions to set a single byte to 0 or 1 depending on some combination of the condition codes. e.g. setl and setb denote \u0026ldquo;set less\u0026rdquo; and \u0026ldquo;set below\u0026rdquo;\nA jump instruction can cause the execution to switch to a completely new position in the program. These jump destinations are negerally indicated in assembly code by a label\nTranslating Conditional Branches The most general way to translate conditional expressions and statement from C into machine code is to use combinations of conditional and unconditional jumps.\nThe general form of an if-else statement in C is given by the template\n1 2 3 4 if (test-expr) then-statement else else-statement for this general form the assmebly implementation typically adheres to the following form, where we use C syntax(use goto) to describe the control flow.\n1 2 3 4 5 6 7 8 t = test-expr if (!t) goto false; then-statement goto done; false: else-statement done: Translating conditional branches by control is simple and in common use. But in modern processor, it sometimes may be much inefficient. A substitution strategy is using data to translate conditional branches, this strategy compute both branches\u0026rsquo; result and choose one according to the condition. It could only be feasible in some constraint situation, but if feasible, then we can use one conditional transfer instruction to implement.\nTo explain why using conditional transfer is faster than using control(jump), we need to know how instructions are executed in processor. Moder processor gains high performance by using pipelining. In pipelining, it takes many phases to process a instruction, such like read instruction from memory, determine the class of instruction, etc. This method obtains high performace by coinciding sequential those phases of instructions, e.g. the processor could execute the arithmetic of the previous instruction while reading the current instruction. To do this, the processor need to know the order of instructions sequence before, to ensure that there are enough instruction to execute. Then we stand on the conditional branch, the processor need to compute what branch to go. Though moder processor using very accurate branch prediction logic to predict which jump instructions will be execute(the accuracy \u0026gt; 90%) to assure there are enough instruction in the pipelining, it have to deprecate the work done for the wrong jump instruction, which takes 15~30 clock cycle. On the other hand, it would always takes 8 clock cycle by data transfer, it not depending what the data like, thus it would be easy to fill the piplining with instructions.\nThe CMOVE class implaments for conditional move(e.g. cmovene S R, move data from S to R while). Consider the expression v = test-expr : then-expr : else-expr, using control to compile it could be below:\n1 2 3 4 5 6 7 if (!test-expr) goto false; v = then-expr; goto done; false: v = else-expr; done: either then-expr or else-expr would be execute, while using conditional transfer it would execute both of them:\n1 2 3 4 v = then-expr; ve = else-expr; t = test-expr; if(!t) v = ve; So, it\u0026rsquo;s easy to see that it could be much slow if the cost if then-expr and else-expr is too expensive.\nLoop Do-while loop do-while have the form below:\n1 2 3 do body-statement while (test-expr) it can be translate into conditionals and goto statements as follow:\n1 2 3 4 5 loop: body-statement t = test-expr; if (t) goto loop; While loop while loop have the form below:\n1 2 while (test-expr) body-statement There multiple ways to translate it, the GCC uses two of them, the first is called jump to middle, in goto form that is:\n1 2 3 4 5 6 7 goto test; loop: body-statement test: t = test-expr; if (t) goto loop; the second method is called guarded-do, it first translate to the do-while form:\n1 2 3 4 5 6 7 t = test-expr; if (!t) goto done; do body-statement while (test-expr); done: futher more, it can be translated below:\n1 2 3 4 5 6 7 8 9 t = test-expr; if (!t) goto done; loop: body-statement t = test-expr; if (t) goto loop; done: GCC would translate while loop in guarded-do form with -O1 option.\nFor loop for loop has the form below:\n1 2 for (init-expr; test-expr; update-expr) body-statement C standard indicate that it is the same as the while loop below(except one situation):\n1 2 3 4 init-expr while (test-expr) body-statement update-expr; So GCC translate the for loop as same as the while loop above, choosing which form depending to the optimization degree.\nSwitch statement A switch statement provides a multi way branching capability vased on the value of an integer index. They are particularly useful when dealing with tests where there can be a large number of possible outcomes. Not only do they make the C code more readable, they also allow an efficiant implementation using a data structure called jump table. JUmp tables are used when there are a number of cases(e.g. four or more) and they span a small range of values. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void switch_eg(long x, long n, long *dest) { long val = x; switch (n) { case 100: val *= 13; break; case 102: val += 10; case 103: val += 11; break; case 104: case 106: val *= val; break; default: val = 0; } *dest = val; } the code above would be translated below by a jump table:\nswitch_eg:\r.LFB0:\r.cfi_startproc\rsubq\t$100, %rsi\rcmpq\t$6, %rsi\rja\t.L8\rjmp\t*.L4(,%rsi,8) the jump table\r.section\t.rodata\r.align 8\r.align 4\r.L4:\r.quad\t.L3\r.quad\t.L8\r.quad\t.L5\r.quad\t.L6\r.quad\t.L7\r.quad\t.L8\r.quad\t.L7\r.text\r.L3:\rleaq\t(%rdi,%rdi,2), %rax\rleaq\t(%rdi,%rax,4), %rdi\rjmp\t.L2\r.L5:\raddq\t$10, %rdi\r.L6:\raddq\t$11, %rdi\rjmp\t.L2\r.L7:\rimulq\t%rdi, %rdi\rjmp\t.L2\r.L8:\rmovl\t$0, %edi\r.L2:\rmovq\t%rdi, (%rdx)\rret\r.cfi_endproc Procedures A procedure call involves passing both data and control form one part of program to another, it could have different form in different language: function, method, subroutine, handler. To supprot procedures, machine must have the abilities:\ntransfer control transfer data allocate and deallocate memory sapce. Runtime stack While the x86-64 procedure need more spaces than register have, then it would allocate space on stack, which called a stack frame of the procedure. If all local variables could be stored in register, the procedure don\u0026rsquo;t need the stack frame.\nTransfer control To transfer control from procedure P to Q, it just simply set the PC with the start of Q, x86-64 uses call Q to push address A and then set the PC with the start of Q, the corresponding instruction ret would pop the address A, and set the PC with A.\nTransfer data In x86-64, it can store 6 parameters in register at most, for 64-bit size data, they stored in the order: %rdi, %rsi, %rdx %rcx, %r8, %r9. So the parameters beyond should transfer by stack.\nRegister local space Register is the only resource shared by all procedures. Conventionally, register %rbx, %rbp and %r12 ~ %r15 are called callee-saved registers, this means when procedure Q is called by P, then Q must save the values of any of these registers on the stack before overwriting them and restore them before returning. Any other registers except the stack point %rsp are called caller-saved registers, this means any procedure can overwriting this registers without restoring. The prefix of \u0026ldquo;saved\u0026rdquo; means who should store the data before pass the control to another procedure.\nOut-of-Bounds Memory References and Buffer Overflow We have see that C does not perform any bounds checking for array references, and that local variables are stored on the stack along with state information such as saved register values and return addresses. This combination can lead to serious program errors, where the state stored on the stack gets corrupted by a write to an out-of-bounds array element. When the program then tries to reload the register or execute a ret instruction with this corrupted state, things can go seriously wrong.\n","permalink":"https://www.sdlinks.net/posts/2018/computer-system-2/","summary":"\u003ch2 id=\"assembler\"\u003eAssembler\u003c/h2\u003e\n\u003cp\u003eComputer execute machine code, sequences of bytes encoding the low-level operations that manipulate data manage memory,\nread and write data on storage devices, and communicate over networks.\u003c/p\u003e\n\u003cp\u003eWe will focus on x86-64, the commonest machine language used in processor with laptop and PC, also it\u0026rsquo;s widely used in\nsupercomputer and lager data center.\u003c/p\u003e\n\u003cp\u003ethe x86-64 machine code is much different with the corresponding C code, the processor states below are everywhere:\u003c/p\u003e","title":"Computer System 2"},{"content":"Hardware Organization of A System A typical system has those hadrware below:\nBuses: Running throughout the system is a collection of electrical conduits called buses that carry bytes of ingormation back and forth betweent the components. Buses are typically designed to transfer fiexed sized chunks of bytes know as words. The number of bytes in a word is a fundamental system parameter that varies across systems. Most have word sizes of 8 bytes (64 bits)today\nI/O Devices: I/O devices are the system\u0026rsquo;s connection to the external wrold. Each I/O device is connected to the I/O bus by either a controller or an adapter. The distinction between the two is mainly one of packaging. Controllers are chip sets in the devices itself or on the system\u0026rsquo;s main printed circuit board(motherboard). An adapter is a card that plugs into a slot on the motherboard. Regardless, the purpose of each is to transfer information back and forth between the I/O bus and an I/O device.\nMain Memory: The main memory is a temporary storage device that holds both a program and the data it mainipulates while the processor is executing the program. Physically, main memory consists of a collection of dynamic random access memory (DRAM) chips. Logically, memory is organized as a linear array of bytes, each with its own unique address(array index) starting at zero.\nCache: In a typical system, An L1 cache on the processor chip holds tens of thousands of bytes and can be accessed nearly as fast as the register file. A larger L2 cache with hundreds of thousands to millions of bytes is connected to the processor by a special bus. It might take 5 times longer for the process to access the L2 cache than L1 cache. The L1 cache and L2 cache are implemented with a hardware technology known as static random access memory(SRAM).\nProcessor: The central processing unit(CPU), or simply processor, is the engine that interprets instructions stored in main memory. At its core is a word-sized storage device(or register) called the program counter(PC). At any point in time, the PC points at some machine-language instruction in main memory. A processor appears to operate according to a very simple instruction execution model, defined by its instruction set architecture. There are only a few of these simple operations, and they revolve around memory, the register file, and the arithmetic/logic unit(ALU). The register file is a small storage device that consists of a collection of world-sized registers, each with its own unique name. The ALU computes new data and address values, here are some operations the CPU might carry out:\nLoad: Copy a byte or a word from main memory into a register, overwriting the previous contents of the register. Store: Copy a byte or a word from a register to a location in main memory, overwriting the previous contents of that location. Operate: Copy the contents of two register to the ALU, perform an arthmetic operation on the two words, and store the result in a register, overwriting the previous contents of that register. Jump: Extract a word from the instruction itself and copy that word into the PC, overwriting the previous value of the PC. Operating System The operating system has two primary purposes:\nto protect the hardware from misuse by runaway applications, and to provide applications with simple and uniform mechanisms for mainpulating complicated and often wildly different low-level hardware devices. The operating system achieves both goals via the fundametal abstractions: processes, virtual memory, and files. Files are abstractions for I/O devices, virtual memory is an abstraction for both the main memory and disk I/O devices, and processes are abstractions for the processor, main memory and I/O devices.\nProcesses: A process is the operating system\u0026rsquo;s abstraction for a running program. By concurrently, we mean that the instructions of one process are interleaved with the instructions of another process. A single CPU can appear to execute multiple processes concurrently by having the processor switch among them. The operation system performs this interleaving with a mechanism known as context switching. The operating system keeps track of all the state information that the process needs in order to run. This state, which is known as context, includes information such as the current value of the PC, the register file, and the contents of main memory. When the operating system decides to transfer control from the current process to some new process, it performs a context switch by saving the context of the current process, restoring the context of the new process, and then passing control to some new process. In modern systems a process can actually consist of multiple execution units, called threads, each running in the context of the process and sharing the same code and global data. It is easier to share data between multiple threads that between multiple processes, and threads are typically more efficient than processes.\nVirtual Memory: Virtual memory is an abstraction that provides each process with the illsion that it has exclusive use of the main memory. Each process has the same uniform view of memory, which known as its virtual address space. In Linux, the topmost region of the address space is reserved for code and data in the operating system that is common to all processes. The low region of the address space holds the code and data defined by the user\u0026rsquo;s process. Starting with the lowest address to the highest address are: Program code and data, heap, shared libraries, stack, kernel virtual memory.\nFiles: A file is a sequence of bytes, nothing more or nothing less. Every I/O device, including disks, keyboards, display, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files.\nVirtual Machine: Providing an abstraction of the entire computer, including the operating system, the process, and the programs\nCocurrency and Parallelism The term concurrency refer to the general concept of a system with multiple, simultaneous activities, and the term parallelism refer to the use of concurrency to make a system run faster. Here are three levels, working from the highest to the lowest level in the system hierarchy\nThread-Level Concurrency: With threads, we can even have multiple control flows executing within a single process. This form of concurrency allows multiple users to interact with a system at the same time, such as many people want to get pages from a single Web server. Hyperthreading, sometimes called simultaneous multi-threading, is a technique that allows a single CPU execute multiple flows of control. Instruction-Level Parallelism: At a much lower level of abstraction, modern processors can execute multiple instructions at one time. Processors that can sustain execution rates faster than one instruction per cycle are known as superscala processors. Single-Instruction, Multiple Data(SIMD) Parallelism: At the low level, many modern processors have special hardware that allows a single instruction to cause multiple operatios to be performed in parallel. SIMD instructions are provided mostly to speed up applications that process image, sound and video data. ","permalink":"https://www.sdlinks.net/posts/2018/computer-system-1/","summary":"\u003ch2 id=\"hardware-organization-of-a-system\"\u003eHardware Organization of A System\u003c/h2\u003e\n\u003cp\u003eA typical system has those hadrware below:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eBuses: Running throughout the system is a collection of electrical conduits called buses that carry bytes of ingormation\nback and forth betweent the components. Buses are typically designed to transfer fiexed sized chunks of bytes know as words.\nThe number of bytes in a word is a fundamental system parameter that varies across systems. Most have word sizes of 8 bytes\n(64 bits)today\u003c/p\u003e","title":"Computer System 1"},{"content":"字符串处理算法具有很高的重要性以及应用领域的多样性. 以下讨论默认的是扩展的ASCII字符集(R=256).\n字符串排序算法 对于许多排序应用而言, 决定顺序的键都是字符串. 利用字符串的特殊性质来将其排序通常能够获得更高的效率.\n键索引计数法 我们首先介绍一种适用于小整数键的简单排序算法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class KeyIndexedCount { public static void sort(char[] chr, int R) { int[] count = new int[R + 1]; char[] temp = new char[chr.length]; for (char aChr : chr) { count[aChr + 1]++; } for (int i = 0; i \u0026lt; R; i++) { count[i + 1] += count[i]; } for (char aChr : chr) { temp[count[aChr]] = aChr; count[aChr]++; } System.arraycopy(temp, 0, chr, 0, chr.length); } public static void sort(char chr[]) { sort(chr, 256); } } 进行频率统计, 将频率转换为索引, 任意一个键的起始位置总是在比它小的键的频率之和的后面, 用一个辅助数组进行排序, 将排序好的内容回写到原来的数组. 很容易发现, 算法仅仅使用了四个循环, 所以其时间复杂度是线性的(四次循环共访问数组10N+3R次). 上述算法的另一个显而易见的特性是排序的稳定性(因为该算法 按顺序遍历数组来排序).\n低位优先排序算法 低位优先排序算法很容易处理那些长度相等的键的排序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class LSD { public static void sort(String[] a, int W) { int N = a.length; final int R = 256; int[] count = new int[R + 1]; String[] aux = new String[N]; for (int i = W - 1; i \u0026gt;= 0; i--) { for (String str : a) { count[str.charAt(i) + 1]++; } for (int k = 0; k \u0026lt; R; k++) { count[k + 1] += count[k]; } for (int k = 0; k \u0026lt; N; k++) { aux[count[a[i].charAt(i)]] = a[k]; count[a[i].charAt(i)]++; } System.arraycopy(aux, 0, a, 0, a.length); } } } 利用键索引计数法就能够得到线性时间复杂度的该算法. 低位优先排序算法依赖于键索引计数法排序的稳定性, 如果没有该特性, 那么该算法在某一轮中打破了稳定性可 能打破上一轮的排序. 对于基于R个字符的字母表的N个以长为W的字符串为键的元素, 该算法需要访问数组~7WN+3WR次, 使用的空间与N+R成正比. 因此在R远小于N 的情形下, 算法总是与WN成正比.\n高位优先排序算法 虽然我们可以修正上述低位优先的排序算法以适应字符串长度不等的情况, 但通常从左向右遍历字符更符合这种情况. 对于某些语言来说(例如C/C++), 已经约定了字符 串末尾的表示方法(\\0). 而对于没有约定结尾的可以实现一个专门的内置方法, 对于指定位置超过字符串长度时取-1, 这样对于频率统计数组count而言, 则需要R+2 的位置来存储.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class MSD { private static final int R = 256; private static final int M = 15; private static String[] aux; private static int charAt(String s, int d) { if (d \u0026gt;= s.length()) { return -1; } else { return s.charAt(d); } } public static void sort(String[] a) { aux = new String[a.length]; sort(a, 0, a.length - 1, 0); } private static void sort(String[] a, int lo, int hi, int d) { if (hi \u0026lt;= lo + M) { InsertionX.sort(a, lo, hi, d); // 将lo到hi的部分从按d位开始的字符串进行排序 return; } int[] count = new int[R + 2]; for (int i = lo; i \u0026lt;= hi; i++) { count[charAt(a[i], d) + 2]++; } for (int i = 0; i \u0026lt; R + 1; i++) { count[i + 1] += count[i]; } for (int i = lo; i \u0026lt;= hi; i++) { aux[count[charAt(a[i], d) + 1]] = a[i]; count[charAt(a[i], d) + 1]++; } System.arraycopy(aux, lo, a, lo, hi - lo + 1); for (int i = 0; i \u0026lt; R; i++) { sort(a, lo + count[i], lo + count[i + 1] - 1, d + 1); } } } 小数组处理对于高位优先的字符串排序算法非常重要, 否则使用Unicode(65536)字符集时, 排序速度会下降非常明显. 因为如果不做任何处理, 最后算法会递归到 对长度为1的数组进行排序. 因此在子数组长度较小时, 切换到插入排序是非常有必要的(例如在长度小于或等于10时使用插入排序可以将运行时间降低为原来的1/10). 高位优先排序对于含有大量的等值键或者有很多前缀相同的键排序会较慢, 因为算法无法跳过等值键的排序(无法对等值键进行分组). 当递归深度较深的时候, 由于在 每一层递归不得不创建一个和Alphabet大小相当的count数组, 算法会造成非常大的空间开销.对于随机输入, 算法的运行时间是亚线性的; 而在最坏的情况下, 即所 有键都相等的情况下, 算法的时间复杂度是线性的.\n将基于大小为R的Alphabet和N个字符串排序, 该算法平均需要检查$N\\log_RN$, 访问数组在8N+3R到~7wN+3wR之间, 其中w是字符串平均长度, 所需空间在最坏 情况下与R乘以最长的字符串的长度之积成正比. 可见该算法的主要限制在于有较长公共部分的数据.\n三向字符串快速排序 该算法只是对原来的三向快速排序改成了字符串的版本. 相较与高位优先算法可能会创建大量的子数组, 三向快速排序总是创建3个, 因此该算法能够很好的处理等值键, 有较长公共前缀的键, 取值范围较小的键和小数组. 而且该算法不需要额外的空间.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Quick3string { public static void sort(String[] a) { sort(a, 0, a.length - 1, 0); } private static int charAt(String s, int d) { if (d \u0026gt;= s.length()) { return -1; } else { return s.charAt(d); } } private static void exch(String[] a, int i, int j) { String temp = a[i]; a[i] = a[j]; a[j] = temp; } public static void sort(String[] a, int lo, int hi, int d) { if (hi \u0026lt;= lo) { return; } int lt = lo, gt = hi; int i = lo + 1; int v = charAt(a[lo], d); while (i \u0026lt; gt) { int t = charAt(a[i], d); if (t \u0026gt; v) { exch(a, i, gt); gt--; } else if (t \u0026lt; v) { exch(a, i, lt); lt++; i++; } else { i++; } } sort(a, lo, lt - 1, d); if (v \u0026gt; 0) { sort(a, lt, gt, d + 1); } sort(a, gt + 1, hi, d); } } 当然, 也可以在数组长度较小时切换到插入排序以提高效率, 以及可以在排序前将数组随机打乱(比较简单的做法是将第一个元素与一个随机位置的元素交换)以防止出现 最坏的情况.\nTrie(单词查找树) 在一般情况下, Trie可以到达以下性能:\n查找命中所需要的时间与被查找的键的长度成正比. 查找未命中的键只需要检查若干字符. R向Trie 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // 一种简单实现 public class TrieST\u0026lt;Value\u0026gt; { private static final int R = 256; private Node root; private static class Node { private int size; private Object val; private Node[] next = new Node[R]; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public Value get(String key) { Node x = get(root, key, 0); if (x == null) { return null; } else { return (Value) x.val; } } private Node get(Node x, String key, int d) { if (x == null) { return null; } if (d == key.length()) { return x; } char c = key.charAt(d); return get(x.next[c], key, d + 1); } public void put(String key, Value val) { root = put(root, key, val, 0); } private Node put(Node x, String key, Value val, int d) { if (x == null) { x = new Node(); } if (d == key.length()) { x.val = val; return x; } char c = key.charAt(d); x.size += 1; x.next[c] = put(x.next[c], key, val, d + 1); return x; } public int size() { return root.size; } private int size(Node x) { if (x == null) { return 0; } int sum = 0; if (x.val != null) { sum += 1; } for (char c = 0; c \u0026lt; R; c++) { sum += size(x.next[c]); } return sum; } public Iterable\u0026lt;String\u0026gt; keys() { return keysWithPrefix(\u0026#34;\u0026#34;); } public Iterable\u0026lt;String\u0026gt; keysWithPrefix(String pre) { Queue\u0026lt;String\u0026gt; queue = new Queue\u0026lt;\u0026gt;(); collect(get(root, pre, 0), pre, queue); return queue; } private void collect(Node x, String pre, Queue\u0026lt;String\u0026gt; q) { if (x == null) { return; } if (x.val != null) { q.enqueue(pre); } for (char c = 0; c \u0026lt; R; c++) { collect(x.next[c], pre + c, q); } } public String longestPrefixOf(String s) { int length = search(root, s, 0, 0); return s.substring(0, length); } private int search(Node x, String s, int d, int length) { if (x == null) { return length; } if (x.val != null) { length = d; } if (d == s.length()) { return length; } char c = s.charAt(d); return search(x.next[c], s, d + 1, length); } public void delete(String key) { root = delete(root, key, 0); } private Node delete(Node x, String key, int d) { if (x == null) { return null; } if (d == key.length()) { x.val = null; } else { char c = key.charAt(d); x.next[c] = delete(x.next[c], key, d + 1); x.size = size(x); } if (x.val != null) { return x; } for (char c = 0; c \u0026lt; R; c++) { if (x.next[c] != null) { return x; } } return null; } } R向Trie具有以下性质:\n链表结构与键的插入顺序无关 查找或删除操作访问数组的次数最多为键的长度加1 字母表的大小为R, 在一颗N个随构造的R向Trie中, 未命中的查找平均所需检查的结点为$ \\sim \\log_RN $, 空间占用在RN到RNw之间. 因此上述算法在处理大型 字母表(如Unicide)的大量长键时, 空间消耗通常是不能接受的.\n三向Trie 三向单词查找树通过显示保存字符来避免R向Trie的过度空间消耗. 可以看成是R向Trie的紧凑版, 但关键的差别在于三向Trie的结构依赖与键的插入顺序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // delete方法类似与二叉树的删除结点操作 public class TST\u0026lt;Value\u0026gt; { private Node root; private class Node { private char c; private Node left, mid, right; private Value val; } public void put(String key, Value val) { root = put(root, key, val, 0); } public Value get(String key) { Node x = get(root, key, 0); if (x == null) { return null; } else { return x.val; } } private Node get(Node cur, String key, int d) { if (cur == null) { return null; } char c = key.charAt(d); if (c \u0026lt; cur.c) { return get(cur.left, key, d); } else if (c \u0026gt; cur.c) { return get(cur.right, key, d); } else if (d \u0026lt; key.length() - 1) { return get(cur.mid, key, d + 1); } else { return cur; } } private Node put(Node cur, String key, Value val, int d) { char c = key.charAt(d); if (cur == null) { cur = new Node(); return cur; } if (c \u0026lt; cur.c) { cur.left = put(cur.left, key, val, d); } else if (c \u0026gt; cur.c) { cur.right = put(cur.right, key, val, d); } else if (d \u0026lt; key.length() - 1) { cur.mid = put(cur.mid, key, val, d + 1); } else { cur.val = val; } return cur; } } 在一颗N个随机字符串构成的三向Trie中, 查找为命中平均需要比较字符~lnN, 空间消耗在3N到3Nw之间(w为字符串平均长度).\n子字符串查找 字符串的一个基本操作就是子字符串查找: 给定一段长度为N的文本和长度为M的模式字符串(通常N \u0026raquo; M), 在文本中找到和该模式相符的子字符串.\n暴力查找算法 查找字符串的一个最直接的算法就是遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class BruteForceSearch { public static int search(String pat, String txt) { int M = pat.length(); int N = txt.length(); for (int i = 0; i \u0026lt; N; i++) { int j = 0; while (txt.charAt(i + j) == pat.charAt(j)) { j++; if (j == M) { return i; } } } return N; } } 上述算法的效率取决于文本的内容, 在最坏的情况下时间复杂度为NM, 而在最好的情况下为N.\nKMP(Knuth-Morris-Pratt)算法 KMP算法的主要思想是判断如何回退指针, 以避免不必要的回退, 而这只取决于模式本身. 事实上KMP算法是对确定有限状态自动机(Deterministic finitestate automaton, DFA)的模拟. DFA从0状态开始, 每次匹配成功都会将DFA带入下一个状态, 每次匹配失败则会使DFA回退到较早的一个状态.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class KMP { private String pat; private int M; private int[][] dfa; public KMP(String pat) { this.pat = pat; M = pat.length(); int R = 256; dfa = new int[R][M]; //构造DFA dfa[pat.charAt(0)][0] = 1; for (int X = 0, j = 1; j \u0026lt; M; j++) { for (int c = 0; c \u0026lt; R; c++) { dfa[c][j] = dfa[c][X]; } dfa[pat.charAt(j)][j] = j + 1; X = dfa[pat.charAt(j)][X]; } } public int search(String txt) { int i, j; int N = txt.length(); for (i = 0, j = 0; i \u0026lt; N \u0026amp;\u0026amp; j \u0026lt; M; i++) { j = dfa[txt.charAt(i)][j]; } if (j == M) { return i - M; } else { return N; } } } KMP算法时间复杂度为~M+N. KMP算法的一个优点是不需要在输入中回退, 因此KMP算法更适合在长度不确定的输入流中进行查找(如标准输入). 当回退的成本较低时, Boyer-Moore算法具有更好的性能.\nBoyer-Moore算法 Boyer-Moore算法从右向左扫描模式字符串, 当不匹配发生时, 可能有以下两种情况:\n不匹配的字符串在模式串中, 此时需要将模式字符串向右移动x位直到模式串中与之相等的字符与文本串对齐(对于模式串中有重复的字符而言可以简单的移动一位). 不匹配的字符串不在模式中, 此时可以将模式串向有移动M位. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class BoyerMoore { private int[] right; private int M; private String pat; public BoyerMoore(String pat) { this.pat = pat; M = pat.length(); int R = 256; right = new int[R]; for (int c = 0; c \u0026lt; R; c++) { right[c] = -1; } for (int j = 0; j \u0026lt; M; j++) { right[pat.charAt(j)] = j; } } public int search(String txt) { int N = txt.length(); int skip; for (int i = 0; i \u0026lt;= N - M; i += skip) { skip = 0; int j = M - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; pat.charAt(j) == txt.charAt(i + j)) { j--; } if (j \u0026gt;= 0) { skip = j - right[txt.charAt(i + j)]; if (skip \u0026lt; 1) { skip = 1; } } else { return i; } } return N; } } 在一般情况下, Boyer-Moore算法时间复杂度为~N/M.\n正则表达式 正则表达式是对非确定有限状态自动机(Nondeterministic finite-state automata, NFA)的模拟, Kleene定理表明对于任意正则表达式都存在一个与之 对应的NFA, 并且具有以下特定:\n长度为M的正则表达式中的每个字符在所对应的NFA中都有且只有一个对应的状态, NFA的起始状态为0并且含有一个(虚拟的)接受状态. 字母表中的字符所对应的状态都有一条从它指出的边, 这条边指向模式中的下一个字符所对应的状态. 元字符\u0026quot;(\u0026quot;, \u0026ldquo;)\u0026rdquo;, \u0026ldquo;|\u0026rdquo;, \u0026ldquo;*\u0026ldquo;所对应的状态至少含有一条指出的边, 这些边可以指向其他的任意状态. 存在匹配转换和$ \\epsilon $转换, 后者相当于匹配$ \\epsilon $ 而NFA与DFA的最大区别在于状态的不确定性, 即NFA状态转换有多种可能.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 简单正则表达式和NFA的转换 public class NFA { private char[] re; // 匹配转换 private Digraph G; // epsilon转换 private int M; /** * NFA构造函数 * @param regexp: 用括号包裹的正则表达式, 只识别了\u0026#34;|\u0026#34;和\u0026#34;*\u0026#34; */ public NFA(String regexp) { Stack\u0026lt;Integer\u0026gt; ops = new Stack\u0026lt;\u0026gt;(); re = regexp.toCharArray(); M = re.length; G = new Digraph(M + 1); for (int i = 0; i \u0026lt; M; i++) { int lp = i; if (re[i] == \u0026#39;(\u0026#39; || re[i] == \u0026#39;|\u0026#39;) { ops.push(i); } else if (re[i] == \u0026#39;)\u0026#39;) { int or = ops.pop(); if (re[or] == \u0026#39;|\u0026#39;) { lp = ops.pop(); G.addEdge(lp, or + 1); G.addEdge(or, i); } else { lp = or; } } if (i \u0026lt; M - 1 \u0026amp;\u0026amp; re[i + 1] == \u0026#39;*\u0026#39;) { G.addEdge(lp, i + 1); G.addEdge(i + 1, lp); } if (re[i] == \u0026#39;(\u0026#39; || re[i] == \u0026#39;*\u0026#39; || re[i] == \u0026#39;)\u0026#39;) { G.addEdge(i, i + 1); } } } public boolean recogizes(String txt) { Bag\u0026lt;Integer\u0026gt; pc = new Bag\u0026lt;\u0026gt;(); DirectedDFS dfs = new DirectedDFS(G, 0); for (int v = 0; v \u0026lt; G.V(); v ++) { if (dfs.marked(v)) { pc.add(v); } } for (int i = 0; i \u0026lt; txt.length(); i++) { Bag\u0026lt;Integer\u0026gt; match = new Bag\u0026lt;\u0026gt;(); for (int v : pc) { if (v \u0026lt; M) { if (re[v] == txt.charAt(i) || re[v] == \u0026#39;.\u0026#39;) { match.add(v + 1); } } } pc = new Bag\u0026lt;\u0026gt;(); dfs = new DirectedDFS(G, match); for (int v = 0; v \u0026lt; G.V(); v++) { if (dfs.marked(v)) { pc.add(v); } } } for (int v : pc) { if (v == M) { return true; } } return false; } } 上述算法将一个正则表达式转换为NFA, 并能够识别文本串中是否包含模式串.\n","permalink":"https://www.sdlinks.net/posts/2018/string-algorithms/","summary":"\u003cp\u003e字符串处理算法具有很高的重要性以及应用领域的多样性. 以下讨论默认的是扩展的ASCII字符集(R=256).\u003c/p\u003e\n\u003ch2 id=\"字符串排序算法\"\u003e字符串排序算法\u003c/h2\u003e\n\u003cp\u003e对于许多排序应用而言, 决定顺序的键都是字符串. 利用字符串的特殊性质来将其排序通常能够获得更高的效率.\u003c/p\u003e\n\u003ch3 id=\"键索引计数法\"\u003e键索引计数法\u003c/h3\u003e\n\u003cp\u003e我们首先介绍一种适用于小整数键的简单排序算法.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eKeyIndexedCount\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esort\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003echr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eR\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eR\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003echr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003elength\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eaChr\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003echr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eaChr\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e]++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eR\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eaChr\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003echr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eaChr\u003c/span\u003e\u003cspan class=\"o\"\u003e]]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eaChr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eaChr\u003c/span\u003e\u003cspan class=\"o\"\u003e]++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003earraycopy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003echr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003echr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003elength\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esort\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003echr\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003esort\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e256\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003col\u003e\n\u003cli\u003e进行频率统计,\u003c/li\u003e\n\u003cli\u003e将频率转换为索引, 任意一个键的起始位置总是在比它小的键的频率之和的后面,\u003c/li\u003e\n\u003cli\u003e用一个辅助数组进行排序,\u003c/li\u003e\n\u003cli\u003e将排序好的内容回写到原来的数组.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e很容易发现, 算法仅仅使用了四个循环, 所以其时间复杂度是线性的(四次循环共访问数组10N+3R次). 上述算法的另一个显而易见的特性是排序的稳定性(因为该算法\n按顺序遍历数组来排序).\u003c/p\u003e","title":"字符串处理算法"},{"content":"One day ago, I started upgrading my Ubuntu 16.04 to 18.04, after I see the update from website. The most diffrience betwen 16.04 and 18.04 is that the 18.04 use GNOME desktop rather than Unity. I had heard that the GNOME desktop is better than Unity, so I tried 18.04 for the new desktop. Unfortunately, after I upgraded my OS, I found that the GNOME desktop wasjust so uncomfortable. And after one hour I gone back to 16.04:(, and content of this article is about the problems I met while reinstalling the OS.\nI installed the 16.04 OS just the same as what I done before: burned the IOS to USB, started the computer, and do what the OS suggested to do.\nSoft Lockup The first thing I met was what called soft lockup, like below\nwatchdog: BUG: soft lockup cpu#0 stuck for 23s. emmm, it was quite depressed, but fortunately I found the solutions on ubuntu forums. The problem can be solved add grub boot option as below.\nWhen you stay at the GRUB menu(you maybe need to press and hold the left shift key right after starting the system if you only has one OS.). Then Hightlight the kernel you want to use and press the e key, thus you should able to see and edit the commands associated with the hightlighted kernel you do before. Go down to the line starting with linux and add the parameter nomodeset to its end. Now press Ctrl + x to boot in the specific config. And remember it just work temporarily, you should configure the /etc/default/grub file as same as what you do before, finally run sudo update-grub to permanently update GRUB\u0026rsquo;s configuration.\nSo in conclusion, what you need to do is add nomodeset to kernel boot configure.\nPCIe Bus Error After I solved the problem above, finally I was led to a NEW PROBLEM:( The PCIe Bus error actually appeared before the soft lockup, it was solved by askubuntu, just add pci=noaer to the kernel boot config, which I explained at soft lockup.\nFinally I could use my Ubuntu again. But what the parameter, like pci=nomsi really mean?, or \u0026ldquo;just work\u0026rdquo; is fine? Thanks the internet a lot, I found an post about this, here are some summary.\nnomodeset, may be the most common one, which is needed for some graphics cards that otherwise boot into a black screen or corrupted splash. The newest kernels have moved the video mode setting into the kernel. So all the programming of hardware specific clock rates and registers on the video card happen in the kernel rather than in the X driver when the X server starts. This make it possible to have high resolution nice looking splash(boot) screens and flicker free transitions from boot splash to login screen. Unfortunately, on some cards this doesn\u0026rsquo;t work properly and you end up with a black screen(or soft lockup above). Adding the parameter instructs the kernel to not load video drivers and use BIOS modes instead until X is loaded. Note that this option is sometions needed for nVidia cards when using the default \u0026ldquo;nouveau\u0026rdquo; drivers. Installing proprietary nvidia drivers ususlly makes this option no longer necessary, so it may not be needed to make this option permanet, just for one boot until you installed the nvidia drivers.\npci=, the argument can be used to change the behaviour of PCI bus device problem and device behaviour.\nUbuntu and Windows Time Difference Operating systems store and retrieve the time in the hardware clock located on your motherland so that it can keep track of the time even when the system does not have power. Most operating system(Linux, Unix, MacOS) store the time on the hardware clock as UTC by default, though some system(notably Microsoft Windows) store the time on the hardware clock as the \u0026ldquo;local\u0026rdquo; time. This causes problems in a dual boot system if both system view the hardware clock differently.\nThe advantage of having the hardware clock as UTC is that you don\u0026rsquo;t need to change the hardware clock when moving bewteen timezones or when Daylight Savings Time(DST) begins or ends as UTC does not have DST or timezone offsets. And changing Linux to use local time is easier and more reliable than changing Windows to use UTC.\nMake Linux use \u0026rsquo;local\u0026rsquo; time, pre-Ubuntu 15.04 systems, you should edit /etc/default/rcS and add or change the following section UTC=no, while Ubuntu 15.04 and above you should run timedatectl set-local-rtc 1 --adjust-system-clock in terminal since the Ubuntu use timedatectl to manage time after 15.04.\nMake Windows use UTC, for windows 10 you can create a *.reg(on the desktop) with the following content and double-click it to import it to registry:\nWindows Registry Editor Version 5.00\r[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation]\r\u0026#34;RealTimeIsUniversal\u0026#34;=dword:00000001 ","permalink":"https://www.sdlinks.net/posts/2018/some-ubuntu-install-problem/","summary":"\u003cp\u003eOne day ago, I started upgrading my Ubuntu 16.04 to 18.04, after I see the update from website. The most diffrience\nbetwen 16.04 and 18.04 is that the 18.04 use GNOME desktop rather than Unity. I had heard that the GNOME desktop is\nbetter than Unity, so I tried 18.04 for the new desktop. Unfortunately, after I upgraded my OS, I found that the GNOME\ndesktop wasjust so uncomfortable. And after one hour I gone back to 16.04:(, and content of this article is about the\nproblems I met while reinstalling the OS.\u003c/p\u003e","title":"一些Ubuntu安装问题"},{"content":"采用哪种数据结构来表示图, 主要考虑以下两个方面:\n必须为可能在应用中碰到的各种类型的图预留出足够的空间, 以及 Graph的实例方法一定要高效. 常见的表示方法有以下几种:\n邻接矩阵, 对于有N个顶点的图而言, 邻接矩阵需要$ N^2 $的空间. 边的数组, 通过定义边来定义图, 这种方法在寻找相邻的点时需要遍历整个数组. 邻接表数组, 使用一个顶点为索引的列表数组, 其中每个元素都是和该顶点相邻的顶点列表. 这种结构能够满足上述的两个条件. 常见实现的性能比较(V表示结点数, E表示边数):\n数据结构 所需空间 添加边 检查顶点是否相邻 遍历所有相邻顶点 边的列表 E 1 E E 邻接矩阵 $ V^2 $ 1 1 V 邻接表 E+V 1 degree(V) degree(V) 非稠密图的标准表示是邻接表, 这种表示具有以下特性:\n使用的空间和V+E成正比, 添加一条边所需要的时间为常数, 以及 遍历顶点v的所有相邻顶点所需要的时间和v的度数成正比. 无向图 无向图只定义了顶点以及顶点之间的关系.\n深度优先搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class DepthFirstSearch { private boolean[] marked; private int count; public DepthFirstSearch(Graph G, int s) { marked = new boolean[G.V()]; dfs(G, s); } private void dfs(Graph G, int v) { marked[v] = true; count++; for (int w : G.adj(v)) { if (!marked[w]) { dfs(G, w); } } } public boolean marked(int w) { return marked[w]; } public int count() { return count; } } 深度优先搜索能够所有与起点相连的顶点, 且所需时间和所有连通顶点的度数之和成正比.\n广度优先搜索 深度优先搜索得到的路径不仅取决于图的结构, 还取决于图的表示和递归调用的性质.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class BreadthFirthSearch { private boolean[] marked; private int count; public BreadthFirthSearch(Graph G, int s) { marked = new boolean[G.V()]; bfs(G, s); } public void bfs(Graph G, int v) { Queue\u0026lt;Integer\u0026gt; queue = new Queue\u0026lt;\u0026gt;(); marked[v] = true; queue.enqueue(v); while (!queue.isEmpty()) { int x = queue.dequeue(); for (int w : G.adj(x)) { if (!marked[w]) { queue.enqueue(w); marked[w] = true; count++; } } } } public boolean marked(int v) { return marked[v]; } public int count() { return count; } } 深度优先搜索与广度优先搜索的差别在于数据结构的不同, 前者使用栈而后者使用队列, 我们在搜索的时候都会将起点加入数据结构, 然后重复以下步骤直到数据结构被 清空:\n取其中的下一个顶点并标记它 将v的所有相邻而又为被标记的顶点加入数据结构 两者的差别只在于数据结构如何获取下一个顶点, 而这种差异导致了图的两者不同视图, 但最终所有与顶点相连的点都会被检查到 有向图 环的检测 有向图常常需要检测是否存在环.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * only for one cycle */ public class DirectedCycle { private boolean[] marked; private int[] edgeTo; private Stack\u0026lt;Integer\u0026gt; cycle; private boolean[] onStack; public DirectedCycle(Digraph G) { onStack = new boolean[G.V()]; edgeTo = new int[G.V()]; marked = new boolean[G.V()]; for (int v = 0; v \u0026lt; G.V(); v++) { if (!marked[v]) { dfs(G, v); } } } private void dfs(Digraph G, int v) { onStack[v] = true; marked[v] = true; for (int w : G.adj(v)) { if (this.hasCycle()) { return; } else if (!marked[w]) { edgeTo[w] = v; dfs(G, w); } else if (onStack[w]) { cycle = new Stack\u0026lt;\u0026gt;(); for (int x = v; x != w; x = edgeTo[x]) { cycle.push(x); } cycle.push(w); cycle.push(v); } } onStack[v] = false; } public boolean hasCycle() { return cycle != null; } public Iterable\u0026lt;Integer\u0026gt; cycle() { return cycle; } } 拓扑排序 拓扑排序是解决优先级限制下任务调度的常见算法, 能否进行拓扑排序的先决条件是是否是有向无环图. 进而问题变为有向无环图中基于深度优先遍历的顶点排序问题, 常见的排序方式有以下三种:\n前序, 在递归调用前将顶点加入队列 后序, 在递归调用之后将顶点加入队列 逆后序, 在递归调用之后将顶点加入栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class DepthFirthOrder { private boolean[] marked; private Queue\u0026lt;Integer\u0026gt; pre; private Queue\u0026lt;Integer\u0026gt; post; private Stack\u0026lt;Integer\u0026gt; reverstPost; public DepthFirthOrder(Digraph G) { marked = new boolean[G.V()]; pre = new Queue\u0026lt;\u0026gt;(); post = new Queue\u0026lt;\u0026gt;(); reverstPost = new Stack\u0026lt;\u0026gt;(); for (int v = 0; v \u0026lt; G.V(); v++) { if (!marked[v]) { dfs(G, v); } } } private void dfs(Digraph G, int v) { marked[v] = true; pre.enqueue(v); for (int w : G.adj(v)) { if (!marked[w]) { dfs(G, w); } } post.enqueue(v); reverstPost.push(v); } public Iterable\u0026lt;Integer\u0026gt; pre() { return pre; } public Iterable\u0026lt;Integer\u0026gt; post() { return post; } public Iterable\u0026lt;Integer\u0026gt; reverstPost() { return reverstPost; } } 进而拓扑排序可以有如下实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Topological { private Iterable\u0026lt;Integer\u0026gt; order; public Topological(Digraph G) { DirectedCycle cycle = new DirectedCycle(G); if (!cycle.hasCycle()) { DepthFirthOrder dfs = new DepthFirthOrder(G); order = dfs.reverstPost(); } } public Iterable\u0026lt;Integer\u0026gt; order() { return order; } public boolean isDAG() { return order != null; } public static void main(String[] args) throws FileNotFoundException { String filename = args[0]; String sp = args[1]; SymbolDigraph sg = new SymbolDigraph(new File(filename), sp); Topological top = new Topological(sg.G()); top.order.forEach(v -\u0026gt; System.out.println(sg.name(v))); } } 这种实现非常简单, 但它被忽略了很多年, 比它更流行的是一种使用队列存储顶点的直观算法:\n初始化一条含有所有起点的队列Q 如果Q为空, 停止, 否则从队列Q中删除一个起点并将其标记; 遍历由被删除顶点指出的所有边, 将被指向的顶点的入度减1; 如果顶点的入度变为0, 将其加入Q; 跳转至2. 加权无向图 加权无向图的一个典型问题是如何寻找最小生成树.\nprim算法 设N\u0026lt;V, {E}\u0026gt;是连通网, 记U={ $u_0$ }, TE={} 在所有$ u \\in U, v \\in V-U $的边$ (u, v) \\in E $中找到一条代价最小的边$ (u_0, v_0)并加入TE $ 将$ v_0 $加入U 若U=V, 停止否则继续2 我们将使用优先队列来进行添加最小边的操作. 并且我们需要在添加新顶点之后检查队列中边的有效性. Prim的一种延时实现: public class LazyPrimMST {\rprivate boolean[] marked;\rprivate Queue\u0026lt;Edge\u0026gt; mst;\rprivate MinPQ\u0026lt;Edge\u0026gt; pq;\rpublic LazyPrimMST(EdgeWeightedGraph G) {\rpq = new MinPQ\u0026lt;\u0026gt;();\rmarked = new boolean[G.V()];\rmst = new Queue\u0026lt;\u0026gt;();\rvisit(G, 0);\rwhile (!pq.isEmpty()) {\rEdge e = pq.delMin();\rint v = e.either();\rint w = e.other(v);\rif (!marked[v] || !marked[w]) {\rmst.enqueue(e);\rif (!marked[v]) { visit(G, v); }\rif (!marked[w]) { visit(G, w); }\r}\r}\r}\rprivate void visit(EdgeWeightedGraph G, int v) {\rmarked[v] = true;\rfor (Edge e : G.adj(v)) {\rif (!marked[e.other(v)]) { pq.insert(e); }\r}\r}\rpublic Iterable\u0026lt;Edge\u0026gt; edges() { return mst; }\rpublic double weight() {\rdouble weight = 0;\rfor (Edge e : edges()) {\rweight += e.weight();\r}\rreturn weight;\r}\r} 延时实现会将所有边都将入优先队列中, 并且不会删除失效的边, 而是在删除的时候检查边的有效性. 所需时间与ElgE成正比, 所需空间与E成正比.\n一种即时实现是总是删除优先队列中失效的边. 我们感兴趣的其实只是连接树顶点和非树顶点中权重最小的边. 当我们将一个顶点v将入到树中时, 对与一个非树中的 顶点w, 只可能使得w到最小生成树的距离更小. 换言之, 我们只会在优先队列中保存每个非树顶点的一条边: 使它与树中顶点连接起来权重最小的一条边.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class PrimMST { private Edge[] edgeTo; private double[] distTo; private boolean[] marked; private IndexMinPQ\u0026lt;Double\u0026gt; pq; public PrimMST(EdgeWeightedGraph G) { edgeTo = new Edge[G.V()]; distTo = new double[G.V()]; marked = new boolean[G.V()]; for (int v = 0; v \u0026lt; G.V(); v++) { distTo[v] = Double.POSITIVE_INFINITY; } pq = new IndexMinPQ\u0026lt;\u0026gt;(); distTo[0] = 0.0; pq.insert(0, 0.0); while (!pq.isEmpty()) { visit(G, pq.delMin()); } } private void visit(EdgeWeightedGraph G, int v) { marked[v] = true; for (Edge e : G.adj(v)) { int w = e.other(v); if (!marked[w] \u0026amp;\u0026amp; e.weight() \u0026lt; distTo[w]) { edgeTo[w] = e; distTo[w] = e.weight(); if (pq.contains(w)) { pq.change(w, distTo[w]); } else { pq.insert(w, distTo[w]); } } } } public Iterable\u0026lt;Edge\u0026gt; edges() { Bag\u0026lt;Edge\u0026gt; edges = new Bag\u0026lt;\u0026gt;(); for (int v = 1; v \u0026lt; edgeTo.length; v++) { edges.add(edgeTo[v]); } return edges; } public double weight() { double weight = 0; for (Edge e : edges()) { weight += e.weight(); } return weight; } } 即时的版本所需时间与ElgV成正比, 空间和V成正比.\n对于常见的稀疏图而言, 两者在时间上限上没有明显的区别(对于稀疏图而言, lgE~lgV), 但空间占用上显然即时的版本更优秀.\nKruskal 算法 相较于Prim算法根据顶点构成树, Kruskal则算法根据边来构成树. 该算法不断地将最小边加入到树中并确保不会构成环. 可以使用最小队列来保存边, 并用 union-find来判断是否有环:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class KruskalMST { private Queue\u0026lt;Edge\u0026gt; mst; public KruskalMST(EdgeWeightedGraph G) { mst = new Queue\u0026lt;\u0026gt;(); MinPQ\u0026lt;Edge\u0026gt; pq = new MinPQ\u0026lt;\u0026gt;(); for (Edge e : G.edges()) { pq.insert(e); } WeightedQuickUnionUF uf = new WeightedQuickUnionUF(G.V()); while (!pq.isEmpty() \u0026amp;\u0026amp; mst.size() \u0026lt; G.V() - 1) { Edge e = pq.delMin(); int v = e.either(); int w = e.other(v); if (!uf.connected(v, w)) { uf.union(w, v); mst.enqueue(e); } } } public Iterable\u0026lt;Edge\u0026gt; edges() { return mst; } public double weight() { double weight = 0; for (Edge e : edges()) { weight += e.weight(); } return weight; } } Kruskal算法一般情况下会比Prim算法慢, 因为union-find还需要进行一次connect操作.\n最小生成树各算法比较(设V个顶点, E条边):\n算法 空间 时间 延时的Prim算法 E ElgE 即时的Prim算法 V ElgV Kruskal E ElgE Fredman-Tarjan V E+VlgV Chazelle V 非常接近E 加权有向图 加权有向图的一个典型的问题是如何寻找最短路径. 我们的重点是单点最短路径问题, 对于给定的起点s得到一颗包含s到所有可达顶点的最短路径树(SPT).\nDijkstra算法 Dijkstra算法按广度优先来寻找最短路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class DijkstraSP { private DirectedEdge[] edgeTo; private double[] distTo; private IndexMinPQ\u0026lt;Double\u0026gt; pq; public DijkstraSP(EdgeWeightedDigraph G, int s) { edgeTo = new DirectedEdge[G.V()]; distTo = new double[G.V()]; pq = new IndexMinPQ\u0026lt;\u0026gt;(); for (int v = 0; v \u0026lt; G.V(); v ++) { distTo[v] = Double.POSITIVE_INFINITY; } distTo[0] = 0.0; pq.insert(s, 0.0); while (!pq.isEmpty()) { relax(G, pq.delMin()); } } private void relax(EdgeWeightedDigraph G, int v) { for (DirectedEdge e : G.adj(v)) { int w = e.to(); double newWeight = distTo[v] + e.weight(); if (distTo[w] \u0026gt; newWeight) { distTo[w] = newWeight; edgeTo[w] = e; if (pq.contains(w)) { pq.change(w, distTo[w]); } else { pq.insert(w, distTo[w]); } } } } public double distTo(int v) { return distTo[v]; } public boolean hasPathTo(int v) { return distTo[v] \u0026lt; Double.POSITIVE_INFINITY; } public Iterable\u0026lt;DirectedEdge\u0026gt; pathTo(int v) { if (!hasPathTo(v)) { return null; } else { Stack\u0026lt;DirectedEdge\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) { path.push(e); } return path; } } } 可以看到, Dijkstra算法和Prim算法两者之间非常类似. 某种程度上可以把Dijkstra看成是Prim算法的有向图版本. 类似的, Dijkstra算法所需的空间与V成正比 时间与ElgV成正比. 但是Dijkstra算法不适用于存在权重为负的有向图(因为在允许负权重的有向图中, 绕路经过更多的负权重边可能会使得权重之和更小, 而这在 Dijkstra算法中是不被允许的).\n无环加权有向图的最短路径算法 无环加权有向图可以利用拓扑排序来获得一个线性时间的最短路径算法, 并且能够处理负权重的边.\npublic class AcyclicSP {\rprivate DirectedEdge[] edgeTo;\rprivate double[] distTo;\rpublic AcyclicSP(EdgeWeightedDigraph G, int s) {\redgeTo = new DirectedEdge[G.V()];\rdistTo = new double[G.V()];\rfor (int v = 0; v \u0026lt; G.V(); v++) { distTo[v] = Double.POSITIVE_INFINITY; }\rdistTo[s] = 0;\rEdgeweightedTopological top = new EdgeweightedTopological(G);\rfor (int v: top.order()) {\rrelax(G, v);\r}\r}\rprivate void relax(EdgeWeightedDigraph G, int v) {\rfor (DirectedEdge e : G.adj(v)) {\rint w = e.to();\rdouble newWeight = distTo[v] + e.weight();\rif (distTo[w] \u0026gt; newWeight) {\rdistTo[w] = newWeight;\redgeTo[w] = e;\r}\r}\r}\rpublic double distTo(int v) { return distTo[v]; }\rpublic boolean hasPathTo(int v) { return distTo[v] \u0026lt; Double.POSITIVE_INFINITY; }\rpublic Iterable\u0026lt;DirectedEdge\u0026gt; pathTo(int v) {\rStack\u0026lt;DirectedEdge\u0026gt; path = new Stack\u0026lt;\u0026gt;();\rfor (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) { path.push(e); }\rreturn path;\r}\rpublic static void main(String[] args) throws FileNotFoundException {\rFile file = new File(args[0]);\rEdgeWeightedDigraph G = new EdgeWeightedDigraph(file);\rint s = Integer.parseInt(args[1]);\rAcyclicSP sp = new AcyclicSP(G, s);\rfor (int t = 0; t \u0026lt; G.V(); t++) {\rSystem.out.print(s + \u0026#34; to \u0026#34; + t);\rSystem.out.printf(\u0026#34; (%4.2f): \u0026#34;, sp.distTo(t));\rif (sp.hasPathTo(t)) {\rfor (DirectedEdge e : sp.pathTo(t)) { System.out.print(e + \u0026#34; \u0026#34;); }\r}\rSystem.out.println();\r}\r}\r} 按照拓扑顺序来遍历并relax顶点, 就能够在和E+V成正比的时间内解决单点最短路径问题 按照拓扑顺序可以保证每条边都被relax一次, 任意一个顶点在relax后, 算法便不在处理任何指向该顶点的边. 而每次relax操作只会减少 路径长, 因此在所有从s可达的顶点都被加入到树中后, 最短路径的最优条件成立. 而拓扑排序的时间复杂度是线性的, 因此总时间复杂度也是线性的.\n因为该算法依赖于拓扑排序, 所以任何有环的图都将无法使用该算法. 另外一点是, 该算法可以解决负权重的边. 值得一提的是, 简单的修改上述算法可以在 线性时间复杂度内解决无环加权有向图的单点最长路径, 将Double.POSITIVE_INFINITY改为Double.NEGATIVE_INFINITY, 并修改relax的 不等号方向. 但是在一般的加权有向图中寻找最长简单路径的已知最好算法是指数级别的.\n关键路径 一种和无环加权有向图的最长路径等价的问题是优先级限制下的并行任务调度问题, 即关键路径问题. 将并行调度任务转换为无环有向图的步骤如下:\n创建一个包含起点s和终点t且每个任务都对应两个顶点(一个起始顶点和结束顶点); 对于每个任务, 都添加一条从起始顶点指向结束顶点且权重为任务所需时间的边. 对于每个优先级限制v -\u0026gt; w, 添加一条从v结束顶点指向w起始顶点且 权重为0的边. 为每个任务添加一条从起点指向该任务起始顶点且权重为0的边, 以及一条从该任务结束顶点指向终点且权重为0的边. 例如, 有如下测试数据 10\r41.0 1 7 9 // 必须在1 7 9之前完成\r51.0 2\r50.0\r36.0\r38.0\r45.0\r21.0 3 8\r32.0 3 8\r32.0 2\r29.0 4 6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class CMP { public static void main(String[] args) { Scanner stdIn = new Scanner(System.in); int N = stdIn.nextInt(); stdIn.nextLine(); EdgeWeightedDigraph G = new EdgeWeightedDigraph(2 * N + 2); int s = 2 * N; int t = 2 * N + 1; for (int i = 0; i \u0026lt; N; i++) { String[] line = stdIn.nextLine().split(\u0026#34;\\\\s+\u0026#34;); double duration = Double.parseDouble(line[0]); G.addEdge(new DirectedEdge(i, i + N, duration)); G.addEdge(new DirectedEdge(s, i, 0.0)); G.addEdge(new DirectedEdge(i + N, t, 0.0)); for (int j = 1; j \u0026lt; line.length; j++) { int successor = Integer.parseInt(line[j]); G.addEdge(new DirectedEdge(i + N, successor, 0.0)); } } AcyclicLP lp = new AcyclicLP(G, s); System.out.println(\u0026#34;Start times:\u0026#34;); for (int i = 0; i \u0026lt; N; i++) { System.out.printf(\u0026#34;%4d: %5.1f\\n\u0026#34;, i, lp.distTo(i)); } System.out.printf(\u0026#34;Finish time: %5.1f\\n\u0026#34;, lp.distTo(t)); } } 可以得到如下结果:\nStart times:\r0: 0.0\r1: 41.0\r2: 123.0\r3: 91.0\r4: 70.0\r5: 0.0\r6: 70.0\r7: 41.0\r8: 91.0\r9: 41.0\rFinish time: 173.0 之所以最长路径路径能够解决并行任务调度问题在于s到t的最长路径是所有任务完成所需的最短时间.\n一般加权有向图的最短路径算法 考虑包含deadline限制的相对最后期限限制下的并行任务调度问题, 一般的deadline限制都是相对与第一个的任务的开始时间而言, 即在任务调度的问题中加入某个任 务必须在指定的时间点之前开始. 该问题等价于加权有向图中最短路径问题(可以有环和负权重). 构造一个加权有向图与关键路径类似, 但需要为每条deadline限制添加一条边: 如果任务v必须在任务w启动后的d个单位时间内开始, 则添加一条从v指向w且权重为负的 边. 将所有边的权重取反即可得到一个加权有向图的最短路径问题.\n当且仅当加权有向图中至少存在一条从s到v的有向路径且其上的任意顶点都不存在与负权重环中时, 最短路径才存在. 对于任意一个负权重的环(权重之和为负数), 重复该环即可得到权重任意小的路径, 而这是无意义的.\n因此该算法要求能够:\n对于从起点不可达的顶点, 最短路径是$ +\\infty $ 对于从起点可达但存在与一个负权重环的顶点, 最短路径为$ -\\infty $ 对于其他顶点, 能够计算最短路径的权重 Bellman-Ford算法可以解决这样的问题, 基本思想是按节点依次构建最短路径, 于是该算法的时间与VE成正比, 空间和V成正比. 该方法非常通用, 因为其没有规定 边的放松顺序, 且总是放松VE条边. 我不会着力于这个版本, 而是介绍另外一个改进的版本.\n基于队列的Bellman-Ford算法\n我们很容易发现, 原始的版本在每一轮中有很多relax操作都不会成功, 只有在上一轮中起点到该点路径长度改变的点指出的边才能够改变起点到其他顶点的路径长. 为了记录这样的顶点, 可以使用一个FIFO的队列来记录这些点.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 public class BellmanFordSP { private double[] distTo; private DirectedEdge[] edgeTo; private boolean[] onQ; private Queue\u0026lt;Integer\u0026gt; queue; private int cost; // relax调用的次数 private Iterable\u0026lt;Integer\u0026gt; cycle; public BellmanFordSP(EdgeWeightedDigraph G, int s) { distTo = new double[G.V()]; edgeTo = new DirectedEdge[G.V()]; onQ = new boolean[G.V()]; queue = new Queue\u0026lt;\u0026gt;(); for (int v = 0; v \u0026lt; G.V(); v++) { distTo[v] = Double.POSITIVE_INFINITY; } distTo[s] = 0.0; queue.enqueue(s); onQ[s] = true; while (!queue.isEmpty() \u0026amp;\u0026amp; !hasNegativeCycle()) { int v = queue.dequeue(); onQ[v] = false; relax(G, v); } } private void relax(EdgeWeightedDigraph G, int v) { for (DirectedEdge e : G.adj(v)) { int w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()) { distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (!onQ[w]) { queue.enqueue(w); onQ[w] = true; } } cost += 1; if (cost % G.V() == 0) { findNegativeCycle(); } } } private void findNegativeCycle() { int V = edgeTo.length; EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V); for (int v = 0; v \u0026lt; V; v++) { if (edgeTo[v] != null) { spt.addEdge(edgeTo[v]); } } EdgeWeightedCycleFinder cf = new EdgeWeightedCycleFinder(spt); cycle = cf.cycle(); } public boolean hasNegativeCycle() { return cycle != null; } public Iterable\u0026lt;Integer\u0026gt; negativeCycle() { return cycle; } public double distTO(int v) { return distTo[v]; } public boolean hasPathTo(int v) { return distTo[v] \u0026lt; Double.POSITIVE_INFINITY; } public Iterable\u0026lt;DirectedEdge\u0026gt; pathTo(int v) { Stack\u0026lt;DirectedEdge\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) { path.push(e); } return path; } } 为了避免负权重出现, 我们需要在每轮进行负权重环的检测.\n加权有向图最短路径算法比较 算法 限制 时间复杂度 空间复杂度 优势 Dijkstra算法 权重需要为正 ElgV V 最坏情况下仍有较好性能 利用拓扑排序的最短路径算法 只适用于无环加权有向图 E + V V 是无环图中的最优算法 Bellman-Ford算法 不能存在负权重环 E + V(最坏EV) V 适用性高 ","permalink":"https://www.sdlinks.net/posts/2018/graph-algorithms/","summary":"\u003cp\u003e采用哪种数据结构来表示图, 主要考虑以下两个方面:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e必须为可能在应用中碰到的各种类型的图预留出足够的空间, 以及\u003c/li\u003e\n\u003cli\u003eGraph的实例方法一定要高效.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e常见的表示方法有以下几种:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e邻接矩阵, 对于有N个顶点的图而言, 邻接矩阵需要$ N^2 $的空间.\u003c/li\u003e\n\u003cli\u003e边的数组, 通过定义边来定义图, 这种方法在寻找相邻的点时需要遍历整个数组.\u003c/li\u003e\n\u003cli\u003e邻接表数组, 使用一个顶点为索引的列表数组, 其中每个元素都是和该顶点相邻的顶点列表. 这种结构能够满足上述的两个条件.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e常见实现的性能比较(V表示结点数, E表示边数):\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e数据结构\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e所需空间\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e添加边\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e检查顶点是否相邻\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e遍历所有相邻顶点\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e边的列表\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eE\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eE\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eE\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e邻接矩阵\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$ V^2 $\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eV\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e邻接表\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eE+V\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003edegree(V)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003edegree(V)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e非稠密图的标准表示是邻接表, 这种表示具有以下特性:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用的空间和V+E成正比,\u003c/li\u003e\n\u003cli\u003e添加一条边所需要的时间为常数, 以及\u003c/li\u003e\n\u003cli\u003e遍历顶点v的所有相邻顶点所需要的时间和v的度数成正比.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"无向图\"\u003e无向图\u003c/h2\u003e\n\u003cp\u003e无向图只定义了顶点以及顶点之间的关系.\u003c/p\u003e\n\u003ch3 id=\"深度优先搜索\"\u003e深度优先搜索\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eDepthFirstSearch\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eboolean\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emarked\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eDepthFirstSearch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGraph\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eG\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003emarked\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eboolean\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eG\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eV\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003edfs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eG\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003edfs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGraph\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eG\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003emarked\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eG\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eadj\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003emarked\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edfs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eG\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eboolean\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003emarked\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emarked\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e深度优先搜索能够所有与起点相连的顶点, 且所需时间和所有连通顶点的度数之和成正比.\u003c/p\u003e","title":"图算法"},{"content":"符号表是一种存储键值对的数据结构, 支持插入和查找操作. 要确定一个给定的键是否存在于符号表中, 首先要建立对象等价性的概念. 为了保证一致性, 最好选择不 可变的数据类型作为键. 成本模型: 统计比较的次数, 在内循环不进行比较的情况下, 转为统计数组的访问次数.\n二叉查找树 每个结点的键都大于其左子树的任意结点的键而小于右子树的任一结点的键. 一棵二叉查找树代表了一组键(及其相应的值)的集合, 同一个集合可以用多棵不同的二叉树 表示, 如果将所有键都投影到一条直线上, 则可以保证得到一个有序的键列.\n查找的惯用做法是: 如果含有该键的结点存在于表中, 则返回相应的值或者返回null. 我们将采用Java 8的Optional类型使得查找的结果总是返回Optional, 将 显示的调用交给使用者.\n使用二叉查找树的算法的运行时间取决于树的形状. 在最好的情况下, 一棵含有N个结点的树是完全平衡的, 每条空链接和根结点的距离都为lgN; 而在最坏的情况下 树的高度为N. 当键的分布是随机的情况下, 二叉查找树一般具有较好的平衡性, 此时查找或者插入操作平均所需的次数为2lnN(1.39lgN). 虽然二叉查找树的查找 成本比二分查找高约39%, 但插入操作是对数级别的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class BST\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;, Value\u0026gt; { private Node root; private class Node { private Node left, right; private Key key; private Value val; private int N; Node(Key key, Value val, int N) { this.key = key; this.val = val; this.N = N; } } public int size() { return size(root); } private int size(Node node) { if (node == null) return 0; return node.N; } public Optional\u0026lt;Value\u0026gt; get(Key key) { return Optional.of(get(root, key)); } private Value get(Node node, Key key) { if (node == null) return null; int cmp = key.compareTo(node.key); if (cmp \u0026gt; 0) get(node.right, key); else if (cmp \u0026lt; 0) get(node.left, key); return node.val; } public void put(Key key, Value val) { root = put(root, key, val); } private Node put(Node node, Key key, Value val) { if (node == null) return new Node(key, val, 1); int cmp = key.compareTo(node.key); if (cmp \u0026gt; 0) node.right = put(node.right, key, val); else if (cmp \u0026lt; 0) node.left = put(node.left, key, val); else node.val = val; node.N = size(node.left) + size(node.right) + 1; return node; } } 平衡查找树 2-3查找树 一棵2-3查找树或为一棵空树, 或者由以下结点组成:\n2-结点, 含有一个键和两条链接. 3-结点, 含有两个键和三条链接. 一棵完美平衡的2-3查找树中所有空链接到根结点的距离都应该是相同的.\n红黑二叉查找树 红黑二叉查找树是用标准的二叉查找树和一些额外的信息来表示2-3树, 树中的链接分为两者情形:\n红链接将两个2-结点连接起来构成一个3-结点. 黑链接是2-3树中普通的链接. 另一种定义是含有红黑链接并满足下列条件的二叉查找树:\n红链接均为左链接. 没有任何一个结点同时和两条红链接相连. 该树是完美黑色平衡的, 即任意空链接到根结点的路径上的黑链接数量相同. 满足这样定义的红黑树和相应的2-3树是一一对应的. (注: 标准的红黑树是允许红链接为右链接的). 一种标准红黑树的实现(具体删除插入调整细节网上很多):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 public class RBST\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;, Value\u0026gt; { private final Node nil = new Node(null, null, BLACK); private Node root = nil; private static final boolean RED = true; private static final boolean BLACK = false; private class Node { private Node left, right, parent; private Key key; private Value val; private boolean color; // private int N; Node(Key key, Value val, boolean color) { this.key = key; this.val = val; // this.N = N; this.color = color; } boolean nonLeft() { return left == nil; } boolean nonRight() { return right == nil; } boolean isNil() { return this == nil; } void flipColors() { color = !color; } @Override public String toString() { StringBuilder result = new StringBuilder(); result.append(\u0026#34;\u0026lt;key: \u0026#34;).append(key); if (parent != null) result.append(\u0026#34;, parent: \u0026#34;).append(parent.key); result.append(\u0026#34;\u0026gt;\u0026#34;); return result.toString(); } } public Iterable\u0026lt;Key\u0026gt; keys() { Queue\u0026lt;Key\u0026gt; queue = new Queue\u0026lt;\u0026gt;(); keys(root, queue); return queue; } private void keys(Node node, Queue\u0026lt;Key\u0026gt; queue) { if (node.isNil()) return; keys(node.left, queue); queue.enqueue(node.key); keys(node.right, queue); } private boolean isRed(Node node) { if (node == null) return BLACK; return node.color == RED; } private void rotateLeft(Node node) { Node newNode = node.right; node.right = newNode.left; if (!newNode.left.isNil()) newNode.left.parent = node; newNode.parent = node.parent; if (node.parent.isNil()) this.root = newNode; else if (node == node.parent.left) node.parent.left = newNode; else node.parent.right = newNode; newNode.left = node; node.parent = newNode; } private void rotateRight(Node node) { Node newNode = node.left; node.left = newNode.right; if (!newNode.right.isNil()) newNode.right.parent = node; newNode.parent = node.parent; if (node.parent.isNil()) this.root = newNode; else if (node == node.parent.left) node.parent.left = newNode; else node.parent.right = newNode; newNode.right = node; node.parent = newNode; } private void flipColors(Node node) { node.flipColors(); node.left.flipColors(); node.right.flipColors(); } public void insert(Key key, Value val) { Node parent = nil; Node current = root; Node insertNode = new Node(key, val, RED); while (!current.isNil()) { parent = current; int cmp = key.compareTo(current.key); if (cmp \u0026lt; 0) current = current.left; else if (cmp \u0026gt; 0) current = current.right; else { current.val = val; return; } } insertNode.parent = parent; if (parent.isNil()) this.root = insertNode; else if (key.compareTo(parent.key) \u0026lt; 0) parent.left = insertNode; else parent.right = insertNode; insertNode.left = nil; insertNode.right = nil; insertFixUp(insertNode); } private void insertFixUp(Node current) { Node parent = current.parent; Node grandparent; while (isRed(parent)) { parent = current.parent; grandparent = parent.parent; if (parent == grandparent.left) { Node uncle = grandparent.right; if (isRed(uncle)) { flipColors(grandparent); current = grandparent; } else { if (current == parent.right) { current = parent; rotateLeft(current); } parent.color = BLACK; grandparent.color = RED; rotateRight(grandparent); } } else { Node uncle = grandparent.left; if (isRed(uncle)) { flipColors(grandparent); current = grandparent; } else { if (current == parent.left) { current = parent; rotateRight(current); } parent.color = BLACK; grandparent.color = RED; rotateLeft(grandparent); } } } root.color = BLACK; } public Optional\u0026lt;Value\u0026gt; get(Key key) { return get(root, key).map(x -\u0026gt; x.val); } private Optional\u0026lt;Node\u0026gt; get(Node root, Key key) { Node current = root; int cmp; while (!current.isNil()) { cmp = key.compareTo(current.key); if (cmp \u0026gt; 0) current = current.right; else if (cmp \u0026lt; 0) current = current.left; else{ // System.out.println(\u0026#34;hit\u0026#34;); return Optional.of(current); } } return Optional.empty(); } public Optional\u0026lt;Key\u0026gt; min() { if (root.isNil()) return Optional.empty(); return min(root).map(x -\u0026gt; x.key); } private Optional\u0026lt;Node\u0026gt; min(Node root) { if (root == nil) return Optional.empty(); Node current = root; while (!current.left.isNil()) current = current.left; return Optional.of(current); } public Optional\u0026lt;Key\u0026gt; deleteMin() { return deleteMin(root).map(x -\u0026gt; x.key); } private Optional\u0026lt;Node\u0026gt; deleteMin(Node root) { Optional\u0026lt;Node\u0026gt; optionalNode = min(root); if (optionalNode.isPresent()) { Node minNode = optionalNode.get(); Node current; if (minNode.nonRight()) current = nil; else current = minNode.right; current.parent = minNode.parent; if (minNode == minNode.parent.left) { minNode.parent.left = current; } else { minNode.parent.right = current; } if (this.root == minNode) { this.root = current; } deleteFixUp(current); return Optional.of(minNode); } return optionalNode; } private void deleteFixUp(Node current) { while (current != this.root \u0026amp;\u0026amp; !isRed(current)) { if (current == current.parent.left) { Node sibling = current.parent.right; if (isRed(sibling)) { sibling.color = BLACK; current.parent.color = RED; rotateLeft(current.parent); sibling = current.parent.right; } if (!isRed(sibling.left) \u0026amp;\u0026amp; !isRed(sibling.right)) { sibling.color = RED; current = current.parent; } else { if (!isRed(sibling.right)) { sibling.left.color = BLACK; sibling.color = RED; rotateRight(sibling); sibling = current.parent.right; } sibling.color = current.parent.color; current.parent.color = BLACK; sibling.right.color = BLACK; rotateLeft(current.parent); current = this.root; } } else { Node sibling = current.parent.left; if (isRed(sibling)) { sibling.color = BLACK; current.parent.color = RED; rotateRight(current.parent); sibling = current.parent.left; } if (!isRed(sibling.left) \u0026amp;\u0026amp; !isRed(sibling.right)) { sibling.color = RED; current = current.parent; } else { if (!isRed(sibling.left)) { sibling.right.color = BLACK; sibling.color = RED; rotateLeft(sibling); sibling = current.parent.left; } sibling.color = current.parent.color; current.parent.color = BLACK; sibling.left.color = BLACK; rotateRight(current.parent); current = this.root; } } } current.color = BLACK; nil.parent = null; } public void delete(Key key) { Optional\u0026lt;Node\u0026gt; optionalNode = get(root, key); if (optionalNode.isPresent()) { Node deleteNode = optionalNode.get(); Node parent = deleteNode.parent; Optional\u0026lt;Node\u0026gt; optionalTempNode = min(deleteNode.right); if (optionalTempNode.isPresent()) { Node tempNode = optionalTempNode.get(); if (this.root == deleteNode) { this.root = tempNode; } flipNode(deleteNode, tempNode); deleteMin(tempNode.right); } else { Node current = deleteNode.left; if (this.root == deleteNode) { this.root = current; } current.parent = parent; if (deleteNode == parent.left) parent.left = current; else parent.right = current; deleteFixUp(current); } } } private void resetNil() { nil.parent = null; nil.left = null; nil.right = null; } private void flipNode(Node lnode, Node rnode) { Node tep; if (lnode == lnode.parent.left) { lnode.parent.left = rnode; } else { lnode.parent.right = rnode; } if (rnode == rnode.parent.left) { rnode.parent.left = lnode; } else { rnode.parent.right = lnode; } tep = lnode.parent; lnode.parent = rnode.parent; rnode.parent = tep; tep = lnode.left; lnode.left = rnode.left; rnode.left.parent = lnode; rnode.left = tep; tep.parent = rnode; tep = lnode.right; lnode.right = rnode.right; rnode.right.parent = lnode; rnode.right = tep; tep.parent = rnode; resetNil(); } } 红黑树可以看成是一种折中的平衡策略, 很多操作和二叉查找树一致, 但因为更好的平衡性而具有更好的性能.\n散列表 散列最主要的目的在于均匀地将键散布开来, 因此在散列之后会丢失键的顺序信息. 散列表实现的重点在于散列函数的选择以及处理碰撞冲突的策略. 我们假设所使用的散列函数能够均匀并独立地将所有的键散布于0到M-1之间.\n散列函数 一个散列函数应该易于计算并且能够均匀分布所有键. 一个优秀的散列方法需要满足以下条件:\n一致性, 等价的键必须产生相等的散列值. 高效性, 计算简便. 均匀性, 均匀的散列所有值而避免大量的碰撞. 拉链法 一种处理碰撞的方法是拉链法, 该方法将大小为M的数组中的每个元素指向一条链表, 链表中的每个结点都存储了散列值为该元素的索引的键值对. 这种方法需要选择 足够大的M, 使所有链表都尽可能短以保证高效的查找.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class SequentialSearchST\u0026lt;Key, Value\u0026gt; { private Node first; private class Node { Key key; Value val; Node next; Node(Key key, Value val, Node next) { this.key = key; this.val = val; this.next = next; } } public Optional\u0026lt;Value\u0026gt; get(Key key) { for (Node current = first; current != null; current = current.next) { if (key.equals(current.key)) return Optional.of(current.val); } return Optional.empty(); } public void put(Key key, Value val) { for (Node current = first; current != null; current = current.next) { if (key.equals(current.key)) { current.val = val; return; } } first = new Node(key, val, first); } public void delete(Key key) { Node parent = first; for (Node current = first; current != null; current = current.next) { if (key.equals(current.key)) { if (current == first) { first = current.next; } else { parent.next = current.next; } return; } parent = current; } } } public class SeparateChainingHashST\u0026lt;Key, Value\u0026gt; { private int N; private int M; private SequentialSearchST\u0026lt;Key, Value\u0026gt; [] st; public SeparateChainingHashST() { this(996); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public SeparateChainingHashST(int M) { this.M = M; st = (SequentialSearchST\u0026lt;Key, Value\u0026gt;[]) new SequentialSearchST[M]; for (int i = 0; i \u0026lt; M; i++) { st[i] = new SequentialSearchST\u0026lt;\u0026gt;(); } } private int hash(Key key) { return key.hashCode() \u0026amp; 0x7fffffff % M; } public Optional\u0026lt;Value\u0026gt; get(Key key) { return st[hash(key)].get(key); } public SeparateChainingHashST\u0026lt;Key, Value\u0026gt; put(Key key, Value val) { st[hash(key)].put(key, val); return this; } public void delete(Key key) { st[hash(key)].delete(key); } } 基于线性探测法的散列表 实现散列表的另一种方式就是用大小为M的数组保存N个键值对(M \u0026gt; N), 依靠数组中的空位解决碰撞冲突. 这类方法统称为开放地址散列表, 其中最简单的方法是 线性探测法: 当碰撞发生时, 我们检查散列表中的下一个位置:\n命中, 该位置的键和被查找的键相同, 为命中, 该位置没有键, 以及 继续查找, 该位置的键和被查找的键不同. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class LinearProbingHashST\u0026lt;Key, Value\u0026gt; { private int N; private int M; private Key[] keys; private Value[] vals; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public LinearProbingHashST(int size) { M = size; keys = (Key[]) new Object[M]; vals = (Value[]) new Object[M]; } private int moduloPlusOne(int i) {return (i + 1) % M; } private void remove(int i) { keys[i] = null; vals[i] = null; N--; } private int hash(Key key) { return (key.hashCode() \u0026amp; 0x7fffffff) % M; } private void resize(int size) { LinearProbingHashST\u0026lt;Key, Value\u0026gt; t = new LinearProbingHashST\u0026lt;\u0026gt;(size); for (int i = 0; i \u0026lt; M; i++) { if (keys[i] != null) { t.put(keys[i], vals[i]); } } keys = t.keys; vals = t.vals; M = t.M; } public void put(Key key, Value val) { if (N \u0026gt; M/2) { resize(2 * M); } int i; for (i = hash(key); keys[i] != null; i = moduloPlusOne(i)) { if (key.equals(keys[i])) { vals[i] = val; return; } } keys[i] = key; vals[i] = val; N++; } public Optional\u0026lt;Value\u0026gt; get(Key key) { for (int i = hash(key); keys[i] != null; i = moduloPlusOne(i)) { if (key.equals(keys[i])) { return Optional.of(vals[i]); } } return Optional.empty(); } public void delete(Key key) { get(key).ifPresent(value -\u0026gt; { int i = hash(key); while (!key.equals(keys[i])) { i = moduloPlusOne(i); } remove(i); i = moduloPlusOne(i); while (keys[i] != null) { Key keyRedo = keys[i]; Value valRedo = vals[i]; remove(i); put(keyRedo, valRedo); i = moduloPlusOne(i); } if (N \u0026gt; 0 \u0026amp;\u0026amp; N \u0026lt; M/8) resize(M / 2); }); } } 线性探测的平均水平取决于元素在插入数组后聚集成的一组连续的条目, 也叫键簇. 显然, 插入的效率依赖于键簇的长度. 在一张大小为M并含有$ N=\\alpha M $个 键的基于线性探测的散列表中, 在均匀散列假设的条件下, 命中和未命中查找所需的次数分别为: $$ \\sim \\frac{1}{2}(1 + \\frac{1}{1 - \\alpha}) 以及 \\sim \\frac{1}{2}(1 + \\frac{1}{(1 - \\alpha)^2}) $$\n可见当散列表在快满的时候查找所需的探测次数非常多, 因此需要动态调整数组以保证使用率不超过1/2(或其他值).\n注: 关于Java的散列函数:\nInteger类型会直接返回该整数的32位值, Double和Long会返回机器表示的前32位和后32位异或的结果. String的hash函数为: $$ h(s) = \\sum_{i=0}^{n-1} s[i] \\times 31^{n-1-i} $$ \u0026ldquo;polygenelubricants\u0026quot;的散列值为$ -2^{31} $ 相对于二叉查找树, 散列表的实现简单, 且查找时间最优. 红黑树能够保证最差情况的性能且支持更多操作.\n","permalink":"https://www.sdlinks.net/posts/2018/search-algorithms/","summary":"\u003cp\u003e符号表是一种存储键值对的数据结构, 支持插入和查找操作. 要确定一个给定的键是否存在于符号表中, 首先要建立对象等价性的概念. 为了保证一致性, 最好选择不\n可变的数据类型作为键. 成本模型: 统计比较的次数, 在内循环不进行比较的情况下, 转为统计数组的访问次数.\u003c/p\u003e\n\u003ch2 id=\"二叉查找树\"\u003e二叉查找树\u003c/h2\u003e\n\u003cp\u003e每个结点的键都大于其左子树的任意结点的键而小于右子树的任一结点的键. 一棵二叉查找树代表了一组键(及其相应的值)的集合, 同一个集合可以用多棵不同的二叉树\n表示, 如果将所有键都投影到一条直线上, 则可以保证得到一个有序的键列.\u003c/p\u003e\n\u003cp\u003e查找的惯用做法是: 如果含有该键的结点存在于表中, 则返回相应的值或者返回null. 我们将采用Java 8的Optional类型使得查找的结果总是返回Optional, 将\n显示的调用交给使用者.\u003c/p\u003e\n\u003cp\u003e使用二叉查找树的算法的运行时间取决于树的形状. 在最好的情况下, 一棵含有N个结点的树是完全平衡的, 每条空链接和根结点的距离都为\u003cdel\u003elgN; 而在最坏的情况下\n树的高度为N. 当键的分布是随机的情况下, 二叉查找树一般具有较好的平衡性, 此时查找或者插入操作平均所需的次数为\u003c/del\u003e2lnN(1.39lgN). 虽然二叉查找树的查找\n成本比二分查找高约39%, 但插入操作是对数级别的.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e48\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eBST\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eextends\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eNode\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eroot\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eNode\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eNode\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eright\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eNode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ekey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eval\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eN\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e       \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eroot\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eNode\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eOptional\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eOptional\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eroot\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eNode\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecmp\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ecompareTo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecmp\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eright\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecmp\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eroot\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eroot\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eNode\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eNode\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eNode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecmp\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ecompareTo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecmp\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eright\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eright\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecmp\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eleft\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eval\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eN\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eright\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"平衡查找树\"\u003e平衡查找树\u003c/h2\u003e\n\u003ch3 id=\"2-3查找树\"\u003e2-3查找树\u003c/h3\u003e\n\u003cp\u003e一棵2-3查找树或为一棵空树, 或者由以下结点组成:\u003c/p\u003e","title":"查找算法"},{"content":"优先队列 当一颗二叉树的每个节点都大于等于它的两个子结点时, 它被称为堆有序, 于是从任一结点向上都能够得到一列非递减的元素. 二叉堆(以下简称堆)是一组能够用堆有序 的完全二叉树排序的元素, 并在数组中按照层级存储. 在一个堆中, 位置k的节点的父结点的位置为$ \\lfloor k/2 \\rfloor $, 而它的两个子节点的位置是2k和 2k+1.\n对于一个含有N个元素的堆, 插入元素操作只需不超过lgN+1次比较, 删除最大元素的操作不超过2lgN次比较.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class MaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { private Key[] pq; private int N = 0; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private Key[] cast(Object obj) { return (Key[]) obj; } private boolean less(int i, int j) { return pq[i].compareTo(pq[j]) \u0026lt; 0; } private void exch(int i, int j) { Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; } private void swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; less(k / 2, k)) { exch(k, k / 2); k = k / 2; } } private void sink(int k) { while (2 * k \u0026lt;= N) { int j = 2 * k; if (j \u0026lt; N \u0026amp;\u0026amp; less(j, j + 1)) j++; if (!less(k, j)) break; exch(k, j); k = j; } } private void resize(int newSize) { Key[] t = cast(new Comparable[newSize]); System.arraycopy(pq, 1, t, 1, N); pq = t; } public MaxPQ() { pq = cast(new Comparable[1]); } public MaxPQ(int max) { pq = cast(new Comparable[max + 1]); } public MaxPQ(Key[] a) { } public void insert(Key v) { if (N \u0026gt;= pq.length - 1) resize(pq.length * 2); pq[++N] = v; swim(N); } public Key max() { return pq[1]; } public Key delMax() { if (N \u0026lt; (pq.length - 1) / 2) resize(pq.length / 2); Key max = pq[1]; exch(1, N); pq[N--] = null; sink(1); return max; } public boolean isEmpty() { return N == 0; } public int size() { return N; } } 索引优先队列 索引优先队列可以看成一个能够快速访问其中最小元素的数组, 事实上, 它能够快速访问数组的一个特定子集中的最小元素.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 public class IndexMinPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { private int[] pq; private int[] qp; private Key[] keys; private int N = 0; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private Key[] cast(Object obj) { return (Key[]) obj; } private boolean greater(int i, int j) { return keys[pq[i]].compareTo(keys[pq[j]]) \u0026gt; 0; } private void exch(int i, int j) { int t = pq[i]; pq[i] = pq[j]; pq[j] = t; qp[pq[i]] = i; qp[pq[j]] = j; } private void swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; greater(k / 2, k)) { exch(k, k / 2); k = k / 2; } } private void sink(int k) { while (2 * k \u0026lt;= N) { int j = 2 * k; if (j \u0026lt; N \u0026amp;\u0026amp; greater(j, j + 1)) j++; if (!greater(k, j)) break; exch(k, j); k = j; } } public IndexMinPQ(int max) { pq = new int[max + 1]; qp = new int[max + 1]; keys = cast(new Comparable[max + 1]); for (int elem : qp) elem = -1; } public void insert(int k, Key key) { N++; qp[k] = N; pq[N] = k; keys[k] = key; swim(N); } public void change(int k, Key key) { keys[k] = key; swim(qp[k]); sink(qp[k]); } public boolean contains(int k) { return qp[k] != -1; } public void delete(int k) { int index = qp[k]; exch(index, N--); swim(index); sink(index); keys[k] = null; qp[k] = -1; } public Key min() { return keys[pq[1]]; } public int minIndex() { return pq[1]; } public int delMin() { int idxOfMin = pq[1]; exch(1, N); qp[pq[N--]] = -1; sink(1); keys[pq[N]] = null; return idxOfMin; } public boolean isEmpty() { return N == 0; } public int size() { return N; } } ","permalink":"https://www.sdlinks.net/posts/2018/priority-queue/","summary":"\u003ch2 id=\"优先队列\"\u003e优先队列\u003c/h2\u003e\n\u003cp\u003e当一颗二叉树的每个节点都大于等于它的两个子结点时, 它被称为堆有序, 于是从任一结点向上都能够得到一列非递减的元素. 二叉堆(以下简称堆)是一组能够用堆有序\n的完全二叉树排序的元素, 并在数组中按照层级存储. 在一个堆中, 位置k的节点的父结点的位置为$ \\lfloor k/2 \\rfloor $, 而它的两个子节点的位置是2k和\n2k+1.\u003c/p\u003e\n\u003cp\u003e对于一个含有N个元素的堆, 插入元素操作只需不超过lgN+1次比较, 删除最大元素的操作不超过2lgN次比较.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e48\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e49\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e50\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e51\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e52\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e53\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e54\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e55\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e56\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e57\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e58\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e59\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e60\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e61\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e62\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e63\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e64\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e65\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e66\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e67\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e68\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e69\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e70\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e71\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e72\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e73\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e74\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e75\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e76\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e77\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e78\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e79\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e80\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMaxPQ\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eextends\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nd\"\u003e@SuppressWarnings\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;unchecked\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003ecast\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eObject\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eboolean\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eless\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ecompareTo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eexch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eswim\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eless\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"n\"\u003eexch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esink\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eless\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eless\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"n\"\u003eexch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eresize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enewSize\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecast\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003enewSize\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003earraycopy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eMaxPQ\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecast\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eMaxPQ\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecast\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eMaxPQ\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003einsert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003elength\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eresize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003elength\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"o\"\u003e[++\u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eswim\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003edelMax\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003elength\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eresize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003elength\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eexch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003epq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"o\"\u003e--]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003esink\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eboolean\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eisEmpty\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"索引优先队列\"\u003e索引优先队列\u003c/h2\u003e\n\u003cp\u003e索引优先队列可以看成一个能够快速访问其中最小元素的数组, 事实上, 它能够快速访问数组的一个特定子集中的最小元素.\u003c/p\u003e","title":"优先队列"},{"content":"排序算法的目标就是将所有元素的主键按照某种方式排列. 成本模型: 计算比较和交换的次数, 对于不交换元素的算法, 计算访问数组的次数. 排序算法的额外内存开销 和运行时间是同等重要的, 排序算法可以分为原地排序算法以及需要额外内存空间来存储另一份数组副本的其他排序算法.\n我们使用的算法模板如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface Sort { static void sort(Comparable[] a) { } static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u0026lt; 0; } static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } static void show(Comparable[] a) { for (Comparable x : a) { StdOut.print(x + \u0026#34; \u0026#34;); StdOut.println(); } } static boolean isSorted(Comparable[] a) { for (int i = 1; i \u0026lt; a.length; i++) { if (less(a[i], a[i - 1])) return false; } return true; } static void main(String[] args) { String[] a = StdIn.readAllStrings(); sort(a); assert isSorted(a); show(a); } } 选择排序 最简单的算法是选择排序, 不断寻找数组剩下元素的最小值, 并将其放在适当的位置. 其特点在于:\n运行时间与输入无关. 数据移动最少, 交换次数和数组大小是线性关系, 其他算法大都是线性对数或者平方级别的. 1 2 3 4 5 6 7 8 9 10 public static void sort(Comparable[] a) { int N = a.length; for (int i = 0; i \u0026lt; N; i++) { int min = i; for (int j = i + 1; j \u0026lt; N; j++) { if (Sort.less(a[j], a[min])) min = j; Sort.exch(a, i, min); } } } 对于长度为N的数组, 选择排序大约需要$ N^2/2 $次比较和N次交换.\n插入排序 对于随机排列长度为N且主键不重复的数组, 平均情况下插入排序需要$ \\sim N^2/4 $次比较以及$ \\sim N^2/4 $次交换. 最坏情况下, 比较和交换的次数 都为$ \\sim N^2/2 $, 最好的情况下需要N-1次比较和0次交换.\n1 2 3 4 5 6 7 8 public static void sort(Comparable[] a) { int N = a.length; for (int i = 1; i \u0026lt; N; i++) { for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; Sort.less(a[j], a[j-1]); j--) { Sort.exch(a, j, j-1); } } } 倒置是指数组中两个顺序颠倒的元素, 例如\u0026quot;E A\u0026quot;中E-A就是一对倒置, 如果数组中倒置的数量小于数组大小的某个倍数, 则称该数组为部分有序. 部分有序有以下 几种典型情况:\n数组中每个元素距离它的最终位置都不远. 一个有序的大数组接一个小数组. 数组中只有几个元素的位置不正确. 插入排序对这样的数组很有效, 当倒置数量很少时, 插入排序可能比其他任何排序都快. 事实上, 设长度为N的数组的倒置数量为m, 则插入排序需要的交换操作等于m, 需要的比较次数大于等于m, 小于等于m+N-1.\n对于随机排序的无重复主键的数组, 插入排序和选择排序的运行时间是平方级别的, 两者之比应该是一个较小的常数.\n希尔排序 希尔排序简单的改进了插入排序, 其思想是使数组中任意间隔为h的元素都是有序的, 这样的数组称为h有序数组. 一个h有序数组指的是h个互相独立的数组交错在一起 的数组, 当h很大时, 就能把元素移到较远的位置. 对于任意以1结尾的h序列, 数组都能够排序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void sort(Comparable[] a) { int N = a.length; int h = 1; // 使用序列1/2 (3^k - 1) while (h \u0026lt; N/3) h = 3 * h + 1; while (h \u0026gt;= 1) { for (int i = h; i \u0026lt; N; i++) { for (int j = i; j \u0026gt;= h \u0026amp;\u0026amp; Sort.less(a[j], a[j - h]); j -= h) { Sort.exch(a, j, j - h); } } h /= 3; } } 算法的性能取决于h序列的选择, 我们选择的序列在最坏的情况下与$ N^{3/2} $成正比. 其他算法在N不是特别大的情况下, 大约只比希尔排序快2倍左右.\n归并排序 归并排序保证任意长度为N的数组排序所需的时间和NlgN成正比, 它的主要缺点是所需的额外空间也和N成正比.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 自顶向下 public static void sort(Comparable[] a) { int N = a.length; // 辅助数组 aux = new Comparable[N]; sort(a, 0, N - 1); } public static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo)/2; sort(a, lo, mid); sort(a, mid + 1, hi); merge(a, lo, mid, hi); } public static void merge(Comparable[] a, int lo, int mid, int hi) { int i = lo; int j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) aux[k] = a[k]; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) a[k] = aux[j++]; else if (j \u0026gt; hi) a[k] = aux[i++]; else if (Sort.less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } } 对于长度为N的数组, 自顶向下的归并排序需要1/2NlgN到NlgN次比较.\n证明: 令C(N)表示将一个长度为N的数组排序所需要的比较次数, 我们容易得到$ C(0)=C(1)=0 $, 对于N\u0026gt;1的情况有: $$ C(N) \\le C(\\lceil N/2 \\rceil) + C(\\lfloor N/2 \\rfloor) + N $$ 以及: $$ C(N) \\ge C(\\lceil N/2 \\rceil) + C(\\lfloor N/2 \\rfloor) + N/2 $$ 当$ N=2^{n} $时, 有解: $$ C(2^n)/2^n = C(2^0)/2^0 + n = n $$ 两边同时乘以$ 2^n $并代回N,有: $$ C(N) = C(2^n) = n \\times 2^n = NlgN $$\n同理, 自顶向下的归并排序最多需要访问数组6NlgN.\n用不同的方法处理小规模问题能改进大多数递归算法的性能, 因为递归会使小规模问题中方法的调用过于频繁, 从而改进对它们的处理方法能够改进整个算法. 在归并 算法中, 使用插入排序来处理小规模的子数组一般能将运行时间缩短10%~15%. 而通过测试数组是否有序可以将任何有序的子数组运行时间变为线性.\n排序算法的复杂度 我们研究的排序算法是基于比较的(忽略了访问数组的开销), 一个基于比较的算法在两次比较之间可能会进行任意规模的计算, 但它们只能通过主键之间的比较来得到关 于某个主键的信息.\n没有任何基于比较的算法能够保证使用少于~NlgN(lgN!)次比较将长度为N的数组排序.\n证明: 假设数组没有重复的主键, 用二叉树来表示所有可能的情况. 那么叶子数最少是N!, 因为对于N个不同的主键有N!种不同的排列, 于是任何基于比较的 排序算法都对应着一颗高为h的二叉树, 其中: $$ N! \\le 叶子数 \\le 2^h $$ 而算法的复杂度对应与根节点到叶子的路径长, 即 $ T \\ge lgN! $, 根据斯特灵公式有lgN! ~NlgN.\n上述论证意味着, 没有任何排序算法能够用少于~NlgN次比较将数组排序, 归并排序是一种渐进最优的基于比较排序的算法. 但在实际情况中:\n归并排序的空间复杂度不是最优的. 在实践中不一定是最坏的情况. 算法的其他操作也可能成为关键所在. 不进行比较也能够将某些数组排序. 快速排序 快速排序的特点包括原地排序(只需要一个很小的辅助栈), 且将长度为N的数组排序的时间和NlgN成正比. 另外, 快速排序的内循环比大多数排序算法都小. 它的主要 缺点在于非常脆弱, 实现时要避免低劣的性能. 快速排序的效率依赖于切分数组的效果, 即依赖于切分数组的值.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //简单的实现 public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length); } private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt; lo) return; int j = partition(a, lo, hi); sort(a, lo, j); sort(a, j + 1, hi); } private static int partition(Comparable[] a, int lo, int hi) { if (lo == hi) return lo; int i = lo, j = hi + 1; Comparable v = a[lo]; while (true) { while (Sort.less(a[++i], v)) if (i == hi) break; while (Sort.less(v, a[--j])) if (j == lo) break; if (i \u0026gt; j) break; Sort.exch(a, i, j); } Sort.exch(a, lo, j); return j; } 快速排序的最好情况是每次都正好能将数组对半分, 此时满足分治递归的$ C_N = 2C_{N/2} + N $公式, 这样得到的解是NlgN. 平均而言, 切分元素都能够落在 数组的中间.\n将长度为N的无重复数组排序, 快速排序平均需要~2NlgN次比较.\n证明: 令$ C_k $为将N个不同元素排序平均需要的比较次数, 显然有$ C_0=C_1=0 $, 对于N\u0026gt;1的情况, 可得到以下递归关系: $$ C_N = N + 1 + (C_0 + C_1 + \\cdots + C_{N-2} + C_{N-1})/N + (C_{N-1} + C_{N-2} + \\cdots + C_0)/N $$ 其中第一项是切分成本, 总是N+1, 后面两项是左右子数组排序的平均成本, 等式两边同乘以N得到: $$ NC_N = N(N+1) + 2(C_0 + C_1 + \\cdots + C_{N-1}) $$ 即: $$ NC_N - (N-1)C_{N-1} = 2N + 2C_{N-1} $$ 进而得到: $$ C_N/(N+1) = C_{N-1}/N + 2/(N+1) $$ 于是有$ C_N/(N+1) - C_1/2 = 2(1/3 + 1/4 + \\cdots + 1/(N+1)) $, 即$ C_N = 2(N+1)(1/3 + 1/4 + \\cdots + 1/(N+1)) $ 近似的得到$ C_N \\approx 2NlnN \\approx 1.39NlgN $, 即平均的比较次数比最好的情况多39%.\n上述简单的快速排序有一个潜在的缺点, 即在切分不平衡时, 可能会极为低效, 在最坏的情况下快速排序需要$ N^2/2 $次比较, 我们在排序前shuffle数组就是为了 减少这种情况的发生.\n改进 适时切换到插入排序 和大多数递归算法一样, 对于小数组快速排序比插入排序更慢, 在数组长度为5~15之间选择插入排序通常能取得较好的效果. 三取样切分 使用子数组的一小部分元素的中位数来切分数组, 这样能得到更好的切分, 但需要额外计算中位数的代价, 当取样大小为3时切分效果最好, 还可以放置哨兵来取消 边界检测. 熵最优排序 当数组中含有大量重复元素的时候, 对于元素全部重复的元素可以不再排序. 一个简单的办法是将数组切分为三部分(荷兰国旗问题). 三向切分的快速排序 E. W. Dijkstra提出的三向切分解法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int lt = lo, i = lo + 1, gt = hi; Comparable v = a[lo]; while (i \u0026lt;= gt) { int cmp = a[i].compareTo(v); if (cmp \u0026lt; 0) Sort.exch(a, lt++, i++); else if (cmp \u0026gt; 0) Sort.exch(a, gt--, i); else i++; } sort(a, lo, lt - 1); sort(a, gt + 1, hi); } 对于只有若干不同主键的随机数组, 三向切分快速排序能够达到线性级别. 给定包含k个不同值的N个主键, 定义$ f_i $为第i个主键出现的次数, $ p_i = f_i/N $ 即第i个主键出现的概率, 那么香农熵定义为: $$ H = -(p_1lgp_1 + p_2lgp_2 + \\cdots + p_klgp_k) $$ 可以得到:\n不存在任何基于比较的算法能够保证在NH-N次比较内将N个元素排序. 对于大小为N的数组, 三向切分的快速排序需要~(2ln2)NH次比较. 当不存在重复主键时, $ H=lgN $, 而有重复主键时, 其具有更好的性能. 这两个性质说明了三向切分的快速排序是信息最优的.\n堆排序 堆排序首先构造一个堆, 然后使用下沉操作将数组按升序排序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public static void sort(Comparable[] a) { int N = a.length; for (int k = N / 2; k \u0026gt;= 1; k--) sink(a, k, N); while (N \u0026gt; 1) { exch(a, 1, N--); sink(a, 1, N); } } private static boolean less(Comparable[] a, int i, int j) { return a[i - 1].compareTo(a[j - 1]) \u0026lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i - 1]; a[i - 1] = a[j - 1]; a[j - 1] = t; } private static void sink(Comparable[] a, int k, int N) { while (2 * k \u0026lt;= N) { int j = 2 * k; if (j \u0026lt; N \u0026amp;\u0026amp; less(a, j, j + 1)) j++; if (!less(a, k, j)) break; exch(a, k, j); k = j; } } 将N个元素排序, 堆排序需要(2NlgN+2N)次比较(2N来源于堆的构造). 堆排序在排序复杂性的研究中具有重要地位, 因为它是唯一一个能够同时最优地利用空间和时间 的方法, 在最坏的情况下它也能保证~2NlgN次比较和恒定的空间. 在空间紧张的场景下具有很好的效果, 但却很少被现代操作系统的其他应用采用, 因为其无法利用缓 存.\n常用排序算法的比较 算法 稳定性 原地 时间复杂度 空间复杂度 选择排序 否 是 $ N^2 $ 1 插入排序 是 是 N到$ N^2 $ 1 希尔排序 否 是 $ N^{3/2} $ 1 快速排序 否 是 NlgN lgN 三向快速排序 否 是 N到lgN lgN 归并排序 是 否 NlgN N 堆排序 否 是 NlgN 1 大多数情况下快速排序是最佳选择; 如果需要稳定性且空间充足的情况下, 归并排序是很好的选择; 对于原始的数据, 直接操作数据排序更合适.\n","permalink":"https://www.sdlinks.net/posts/2018/sorting-algorithms/","summary":"\u003cp\u003e排序算法的目标就是将所有元素的主键按照某种方式排列. 成本模型: 计算比较和交换的次数, 对于不交换元素的算法, 计算访问数组的次数. 排序算法的额外内存开销\n和运行时间是同等重要的, 排序算法可以分为原地排序算法以及需要额外内存空间来存储另一份数组副本的其他排序算法.\u003c/p\u003e\n\u003cp\u003e我们使用的算法模板如下\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e35\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003einterface\u003c/span\u003e \u003cspan class=\"nc\"\u003eSort\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esort\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eboolean\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eless\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ecompareTo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eexch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eshow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"n\"\u003eStdOut\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"n\"\u003eStdOut\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eprintln\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eboolean\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eisSorted\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eComparable\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003elength\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eless\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eStdIn\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ereadAllStrings\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003esort\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eassert\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eisSorted\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eshow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"选择排序\"\u003e选择排序\u003c/h2\u003e\n\u003cp\u003e最简单的算法是选择排序, 不断寻找数组剩下元素的最小值, 并将其放在适当的位置. 其特点在于:\u003c/p\u003e","title":"排序算法"},{"content":"union-find算法是一个解决动态连通性的经典算法, 具有广泛性的应用. 简单起见, 我们将对象称为触点, 将整数对称为连接, 将等价类称为连通分量, 并用0 到N-1的整数来表示N个触点.\nAPI 1 2 3 4 5 6 7 public class UF { UF(int N) // 以整数标识初始化N个触点 void union(int p, int q) // 在p和q之间添加一条连接 int find(int p) //p所在分量的标识符 boolean connected(int p, int q) // p和q之间是否存在于同一个分量中 int count() // 连通分量的数量 } 成本模型: 以数组的访问次数作为成本模型, 无论读写.\n算法的关键在于find和union的设计上.\nquick-find算法 1 2 3 4 5 6 7 8 9 10 11 12 //quick-find算法 public int find(int p) { return id[p]; } public void union(int p, int q) { int pID = find(p), qID = find(q); // 两次读操作 if (pID != qID) { // N次读操作, 1~(N-1)次写操作 for (int i = 0; i \u0026lt; id.length; i++) if (id[i] == pID) id[i] = qID; count--; } } quick-find使用一个触点为索引的数组作为数据结构, 每次find()调用访问数组一次, 而union()调用访问数组(N+3)到(2N+1)次. 假设我们最后只得到 了一个连通分量, 那么至少需要调用N-1次union(), 即至少$ (N+3)(N-1) \\sim N^2 $次数组访问. 意味着该算法是平方级别的, 也意味着该算法不试用于 规模更大(百万级)的场景.\nquick-union算法 这个算法在于提高union()的速度, 和上面的quick-find相互补.\n1 2 3 4 5 6 7 8 9 10 11 12 public int find(int p) { while (p != id[p]) p = id[p]; // 2*树的深度+1 return p; } public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if (pRoot != qRoot) { id[pRoot] = id[qRoot]; count--; } } quick-union也使用一个触点为索引的数组作为数据结构, 但对应的元素都是同一个连通分量中另一个触点的名字(链接). 该算法将union()操作降低到线性级别, 但find()操作在最好的情况下只需访问一次资源, 而最坏的情况是2N+1(这是较为保守的估计, 因为while循环在编译后对id[p]的第二次引用一般不会访问数 组). 对于一般的输入数据而言, 是对quick-find算法较好的改进, 但对于有些输入并不会比quick-find快.\n同样, 假设我们最后只得到了一个连通分量, 在最坏的情况下是平方级别的: 输入的整数都是有序数对, 0-1, 0-2, 0-3等, 此时find访问数组的次数为 $ 3+5+7+\\cdots+(2N-1)\\sim N^2 $\n加权quick-union算法(union-find) 为了减少quick-union算法最坏情况出现, 将原来union()操作中随意将一棵树连接到另一棵树改为总是将较小的树连接到较大的树上.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 新增sz权重数组 public void union(int p, int q) { int i = find(p); int j = find(q); if (i != j) { if (sz[i] \u0026lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } count--; } } 改进的目的在于降低树的高度, 以减少find()调用的访问数组次数. 在最坏的情况下, 成本模型的增长数量级为logN. 即加权quick-union算法在处理N个触点 和M条连接时最多访问数组cMlgN.\n最优算法 理想情况下的最优算法应该能够保证在常数时间内完成union()和find()调用, 但这是非常困难的. 通常情况下, 路径压缩的加权算法quick-union算法是 最优算法:\n1 2 3 4 5 6 7 public int find(int p) { while (p != id[p]) { id[p] = id[id[p]]; //将所有节点都链接到根节点 p = id[p]; } return p; } 路径压缩算法将路径上遇到的所有都链接到根节点, 其和quick-find在理想情况下得到的树非常接近, 但并非所有操作都在常数时间完成. 但实际情况下已经不太可能 对加权quick-union算法进行任何改进了(笔者在测试数据为200W条时, 所得到的提升较小), 而且不存在其他算法能够保证union-find算法的所有操作在均摊后都 是常数级别的(在非常一般的cell probe模型之下, 即只记录对随机内存的访问, 内存大小足以保存所有输入且假设其他操作均没有成本). 使用路径压缩的加权quic k-union算法已经是我们对于这个问题能够给出的最优解.\n","permalink":"https://www.sdlinks.net/posts/2018/union-find-algorithm/","summary":"\u003cp\u003eunion-find算法是一个解决动态连通性的经典算法, 具有广泛性的应用. 简单起见, 我们将对象称为触点, 将整数对称为连接, 将等价类称为连通分量, 并用0\n到N-1的整数来表示N个触点.\u003c/p\u003e\n\u003ch2 id=\"api\"\u003eAPI\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eUF\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"n\"\u003eUF\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 以整数标识初始化N个触点\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eunion\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 在p和q之间添加一条连接\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003efind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e//p所在分量的标识符\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kt\"\u003eboolean\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003econnected\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e// p和q之间是否存在于同一个分量中\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 连通分量的数量\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e成本模型: 以数组的访问次数作为成本模型, 无论读写.\u003c/p\u003e\n\u003cp\u003e算法的关键在于\u003ccode\u003efind\u003c/code\u003e和\u003ccode\u003eunion\u003c/code\u003e的设计上.\u003c/p\u003e\n\u003ch2 id=\"quick-find算法\"\u003equick-find算法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//quick-find算法\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003efind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eunion\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epID\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003efind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eqID\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003efind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 两次读操作\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epID\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e!=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eqID\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"c1\"\u003e// N次读操作, 1~(N-1)次写操作\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003elength\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epID\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eqID\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003equick-find使用一个触点为索引的数组作为数据结构, 每次\u003ccode\u003efind()\u003c/code\u003e调用访问数组一次, 而\u003ccode\u003eunion()\u003c/code\u003e调用访问数组(N+3)到(2N+1)次. 假设我们最后只得到\n了一个连通分量, 那么至少需要调用N-1次\u003ccode\u003eunion()\u003c/code\u003e, 即至少$ (N+3)(N-1) \\sim N^2 $次数组访问. 意味着该算法是平方级别的, 也意味着该算法不试用于\n规模更大(百万级)的场景.\u003c/p\u003e","title":"union-find算法"},{"content":"本地操作 状态检览 1 2 $ git status -s XY PATH1 -\u0026gt; PATH2 PATH2只有在PATH1关联到不同的路径时才会显示(例如, 文件重命名).\nXY是两个状态码, 在合并冲突的时候, X和Y分别表示合并双方的修改状态; 而在一般情况下X表示暂存区域(index)的状态, Y表示工作目录的状态(work tree):\n\u0026rsquo; \u0026rsquo; = unmodified M = modified A = added D = deleted R = renamed C = copied U = updated but unmerged 未被追踪(untracked)的文件, XY = ??; 默认不显示忽略的文件(ignored), 除非使用--ignore选项, 此时XY = !!.\n查看已暂存和未暂存的修改 1 $ git diff 用来比较工作目录中当前文件和暂存区域快照之间的差异, 使用--staged选项查看已经暂存的将要添加到下次修改的内容\n提交更新 1 $ git commit 这种方式会启动shell的环境变量$EDDITOR所指定的软件, 一般是VIM或emacs, 或者使用git\tconfig\t--global\tcore.editor来指定编辑器, 使用-v选项将diff的内容追加到编辑器中, 使用-m '${comment}'选项来直接添加提交信息, 而不打开编辑器.\n跳过使用暂存区 1 $ git commit -a git会自动把所有已经跟踪过的文件暂存起来一并提交, 跳过git add步骤.\n移除文件 1 $ git rm ${fileName} 移除工作目录文件, 并记录移除操作, 如果删除之前修改过并且已经放到暂存区域的话, 必须使用强制删除选项-f, 用于防止误删.\n1 $ git rm --cached ${fileName} 从git仓库(亦从暂存区移除)移除文件, 而保留磁盘文件\n移动文件 1 $ git mv ${oldFileName} ${newFileName} 等价于\n1 2 3 $ mv ${oldFileName} ${newFileName} $ git rm ${oldFileName} $ git add ${newFileName} 查看提交历史 1 $ git log 默认情况下, git会按提交时间列出所有的更新, 最近的更新排在最上面. 使用-p选项来显示每次提交的内容差异; -${n}选项来明确要显示几次提交, n为自然数; --stat选项输出每次提交的简略统计信息; --pretty来指定使用不同的默认格式的方式展示提交历史, 格式有oneline, short, full和fuller, 或者用--pretty=format:\u0026quot;${format}\u0026quot;来指定显示格式; --graph选项使用ASCII字符形象地展示分支, 合并历史.\n撤销操作 1 $ git commit --amend 用来尝试重新提交, 修改提交信息.\n1 $ git reset HEAD ${fileName} 撤销文件暂存.\n1 $ git checkout -- ${fileName} 撤销对文件的修改(丢失修改信息).\n远程仓库使用 查看远程仓库 1 $ git remote 使用-v选项来显示对应的url.\n如果想要查看一个远程仓库的更多信息, 使用git remote show ${remoteName}\n从远程仓库中抓取与拉取 1 $ git fetch ${remoteName} 访问远程仓库, 从中拉取所有你还没有的数据, 而不会自动合并或修改当前的工作, 需要手动合并.\n使用clone会自动将其添加为远程仓库并默认为\u0026rsquo;origin'.\n如果一个分支设置为跟踪一个远程分支, 可以使用git pull来自动抓取然后合并远程分支到当前分支; 默认情况git clone会自动的设置本地master 分支跟踪clone的远程仓库的master分支\n远程仓库的移除与重命名 1 2 git remote rename ${oldName} ${newName} git remote rm ${remoteName} 分支管理 分支的新建与合并 1 $ git checkout -b ${branchName} 创建新分支并切换当前分支至新分支, 等价于:\n1 2 $ git branch ${branchName} $ git checkout ${branchName} 1 git merge ${branchName} 合并到当前分支, 使用rebase来确保在向远程分支推送时提交历史的整洁, 即rebase和merge在提交历史上的存在差异.\n分支管理 1 git branch 显示所有分支, -v选项来查看每一个分支的最后一次提交信息; --merged和--no-merged来查看已经合并或尚未合并到当前分支的的分支; -d选项来 删除已经完全合并了的分支, -D选项强制删除分支.\n配置 1 git config credential.helper store 保存使用HTTP协议的密码\n换行符 由于文本文件使用的换行符在不同的操作系统下不一致的问题(在Unix/Linux上为0x0A(LF), 而在DOS/Windows上为0x0D0A(CRLF)), 当换行符发生改变时, Git会认为整个文件被修改而导致无法diff, 此时一种解决方案是设置全局的autocrlf配置项:\n1 git config --global core.autocrlf true 其中配置项的值可以是:\ntrue: 提交时转为LF, 检出时转为CRLF false: 提交检出均不转换 input: 提交时转为LF, 检出时不转换 另外还有safecrlf配置项, 其值为:\ntrue: 拒绝包含混合换行符文件的提交 false: 允许包含混合换行符文件提交 warn: 提交包含混合换行符文件时给出警告 另外一种方案则是对每个仓库单独建一个.gitattributes文件来单独配置:\n# from https://help.github.com/articles/dealing-with-line-endings/\r# Set the default behavior, in case people don\u0026#39;t have core.autocrlf set.\r* text=auto\r# Explicitly declare text files you want to always be normalized and converted\r# to native line endings on checkout.\r*.c text\r*.h text\r# Declare files that will always have CRLF line endings on checkout.\r*.sln text eol=crlf\r# Denote all files that are truly binary and should not be modified.\r*.png binary\r*.jpg binary 其中几条规则:\ntext=auto: Git自动处理这些文件, 通常建议的默认选项 text eol=crlf: Git将在检出这些文件时自动转成CRLF, 建议将一些必须CRLF的文件设为该配置(如.bat), 另外还有eol=lf binary: Git会认为这些文件不应该改变, 等同于text -diff ","permalink":"https://www.sdlinks.net/posts/2018/git-cheat-sheet/","summary":"\u003ch2 id=\"本地操作\"\u003e本地操作\u003c/h2\u003e\n\u003ch3 id=\"状态检览\"\u003e状态检览\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ git status -s\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eXY PATH1 -\u0026gt; PATH2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003ePATH2只有在PATH1关联到不同的路径时才会显示(例如, 文件重命名).\u003c/p\u003e\n\u003cp\u003eXY是两个状态码, 在合并冲突的时候, X和Y分别表示合并双方的修改状态; 而在一般情况下X表示暂存区域(\u003cem\u003eindex\u003c/em\u003e)的状态, Y表示工作目录的状态(\u003cem\u003ework tree\u003c/em\u003e):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026rsquo; \u0026rsquo; = unmodified\u003c/li\u003e\n\u003cli\u003eM = modified\u003c/li\u003e\n\u003cli\u003eA = added\u003c/li\u003e\n\u003cli\u003eD = deleted\u003c/li\u003e\n\u003cli\u003eR = renamed\u003c/li\u003e\n\u003cli\u003eC = copied\u003c/li\u003e\n\u003cli\u003eU = updated but unmerged\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e未被追踪(\u003cem\u003euntracked\u003c/em\u003e)的文件, XY = ??; 默认不显示忽略的文件(\u003cem\u003eignored\u003c/em\u003e), 除非使用\u003ccode\u003e--ignore\u003c/code\u003e选项, 此时XY = !!.\u003c/p\u003e\n\u003ch3 id=\"查看已暂存和未暂存的修改\"\u003e查看已暂存和未暂存的修改\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ git diff\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e用来比较工作目录中当前文件和暂存区域快照之间的差异, 使用\u003ccode\u003e--staged\u003c/code\u003e选项查看已经暂存的将要添加到下次修改的内容\u003c/p\u003e\n\u003ch3 id=\"提交更新\"\u003e提交更新\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ git commit\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这种方式会启动shell的环境变量\u003ccode\u003e$EDDITOR\u003c/code\u003e所指定的软件, 一般是VIM或emacs, 或者使用\u003ccode\u003egit\tconfig\t--global\tcore.editor\u003c/code\u003e来指定编辑器,\n使用\u003ccode\u003e-v\u003c/code\u003e选项将\u003ccode\u003ediff\u003c/code\u003e的内容追加到编辑器中, 使用\u003ccode\u003e-m '${comment}'\u003c/code\u003e选项来直接添加提交信息, 而不打开编辑器.\u003c/p\u003e","title":"Git Cheat Sheet"}]